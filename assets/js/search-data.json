{
  
    
        "post0": {
            "title": "Manejo de datos con Pandas",
            "content": "1. Resumen . Vamos a ver una pequeña introducción a la librería de manipulación y analisis de datos Pandas. Con ella podremos manejar y procesar datos tabulares que nos ayudará para poder operar con ellos y obtener información de una manera muy valiosa . . 2. &#191;Qu&#233; es Pandas? . Pandas es una librería de Python que está diseñada para que el trabajo con datos relacionales o etiquetados sea fácil e intuitivo . Pandas está diseñado para muchos tipos diferentes de datos: . Datos tabulares con columnas de tipos heterogéneos, como en una tabla SQL o una hoja de cálculo de Excel | Datos de series de tiempo ordenados y desordenados (no necesariamente de frecuencia fija). | Datos matriciales arbitrarios (homogéneos o heterogéneos) con etiquetas de fila y columna | Cualquier otra forma de conjuntos de datos observacionales/estadísticos. No es necesario etiquetar los datos en absoluto para colocarlos en una estructura de datos de pandas. | . Las dos estructuras de datos principales de Pandas son las Series (unidimensional) y los DataFrames (bidimensional). Pandas está construido sobre NumPy y está destinado a integrarse bien dentro de un entorno informático científico con muchas otras bibliotecas de terceros. . Para los científicos de datos, el trabajo con datos generalmente se divide en varias etapas: recopilar y limpiar datos, analizarlos/modelarlos y luego organizar los resultados del análisis en una forma adecuada para trazarlos o mostrarlos en forma de tabla. Pandas es la herramienta ideal para todas estas tareas. . Otra característica es que pandas es rápido, muchos de los algoritmos de bajo nivel se han construido en C . 2.1. Pandas como pd . Generalmente a la hora de importar Pandas se suele importar con el alias de pd . import pandas as pd print(pd.__version__) . 1.1.5 . 3. Estructuras de datos de Pandas . En Pandas existen dos tipos de estructuras de datos: las Series y los DataFrames . 3.1. Series . El tipo de dato Serie es una matriz etiquetada unidimensional capaz de contener cualquier tipo de datos (enteros, cadenas, números de punto flotante, objetos Python, etc.). Están divididas en índices. . Para crear un tipo de dato Serie la forma más común es . serie = pd.Series(data, index=index) . Donde data puede ser . Un diccionario | Una lista o tupla | Un ndarray de Numpy | Un valor escalar | . Como uno de los tipos de datos puede ser un ndarray de Numpy, importamos Numpy para poder usarlo . import numpy as np . 3.1.1. Series desde un diccionario . diccionario = {&quot;b&quot;: 1, &quot;a&quot;: 0, &quot;c&quot;: 2} serie = pd.Series(diccionario) serie . b 1 a 0 c 2 dtype: int64 . Si se pasa un índice, se extraerán los valores de los datos correspondientes a las etiquetas del índice. Si no existen se crean como NaN (not a number) . diccionario = {&quot;b&quot;: 1, &quot;a&quot;: 0, &quot;c&quot;: 2} serie = pd.Series(diccionario, index=[&quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;a&quot;]) serie . b 1.0 c 2.0 d NaN a 0.0 dtype: float64 . 3.1.2. Series desde una lista o tupla . Si los datos provienen de una lista o tupla y no se pasa ningún índice, se creará uno con valores [0, ..., len(data)-1] . serie = pd.Series([1, 2, 3, 4]) serie . 0 1 1 2 2 3 3 4 dtype: int64 . Si se pasa un índice, este debe tener la misma longitud que los datos . serie = pd.Series([1, 2, 3, 4], index=[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]) serie . a 1 b 2 c 3 d 4 dtype: int64 . 3.1.3. Series desde un ndarray . Si los datos provienen de un ndarray y no se pasa ningún índice, se creará uno con valores [0, ..., len(data)-1] . serie = pd.Series(np.random.randn(5)) serie . 0 -1.530351 1 0.293836 2 -0.763430 3 -0.304678 4 -0.072303 dtype: float64 . Si se pasa un índice, este debe tener la misma longitud que los datos . serie = pd.Series(np.random.randn(5), index=[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]) serie . a 0.870907 b 1.395928 c -1.160544 d 0.031081 e 1.311394 dtype: float64 . 3.1.4. Series desde un escalar . Si se crea la serie desde un escalar, se creará con un único item . serie = pd.Series(5.0) serie . 0 5.0 1 4.0 dtype: float64 . Si se quieren crear más items en la serie, hay que pasarle el índice con el número de items que se quiere, de esta manera todos los items tendrán el valor del escalar . serie = pd.Series(5.0, index=[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]) serie . a 5.0 b 5.0 c 5.0 d 5.0 e 5.0 dtype: float64 . 3.1.5. Operaciones con Series . Al igual que con Numpy, podemos realizar operaciones con todos los elementos de una serie, sin tener que hacer una iteracción por cada uno de ellos . serie = pd.Series(5.0, index=[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]) print(f&quot;serie: n{serie}&quot;) print(f&quot; nserie + serie = n{serie + serie}&quot;) . serie: a 5.0 b 5.0 c 5.0 d 5.0 e 5.0 dtype: float64 serie + serie = a 10.0 b 10.0 c 10.0 d 10.0 e 10.0 dtype: float64 . serie = pd.Series(5.0, index=[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]) print(f&quot;serie: n{serie}&quot;) print(f&quot; nexp(serie) = n{np.exp(serie)}&quot;) . serie: a 5.0 b 5.0 c 5.0 d 5.0 e 5.0 dtype: float64 exp(serie) = a 148.413159 b 148.413159 c 148.413159 d 148.413159 e 148.413159 dtype: float64 . Una diferencia entre Series y ndarrays es que las operaciones entre Series alinean automáticamente los datos según sus etiquetas. Por lo tanto, se pueden escribir cálculos sin tener en cuenta si las Series involucradas tienen las mismas etiquetas. Si no se encuentra una etiqueta en una Serie u otra, el resultado se marcará como faltante (NaN). . serie = pd.Series(5.0, index=[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]) print(f&quot;serie: n{serie}&quot;) print(f&quot; nserie[1:] + serie[:-1] = n{serie[1:] + serie[:-1]}&quot;) . serie: a 5.0 b 5.0 c 5.0 d 5.0 e 5.0 dtype: float64 serie[1:] + serie[:-1] = a NaN b 10.0 c 10.0 d 10.0 e NaN dtype: float64 . 3.1.6. Atributo nombre de las series . Uno de los atributos de las Series es name, el cual corresponde al nombre que tendrán cuando se añadan a un DataFrame. Por el camino contrario, cuando se obtiene una serie de un DataFrame, esta serie tendrá como nombre el que tenía en el DataFrame . serie = pd.Series(np.random.randn(5), name=&quot;aleatorio&quot;) serie . 0 -1.230289 1 0.716663 2 0.009893 3 -0.369320 4 1.230639 Name: aleatorio, dtype: float64 . Se puede cambiar el nombre de una serie mediante el méteodo rename() . serie = serie.rename(&quot;random&quot;) serie . 0 -1.230289 1 0.716663 2 0.009893 3 -0.369320 4 1.230639 Name: random, dtype: float64 . 3.2. DataFrames . Un DataFrame es una estructura de datos etiquetada y bidimensional, con columnas de tipos potencialmente diferentes, es decir, en una columna puede haber datos de tipo entero, en otra columna datos de tipo string, etc. Puede pensar en ello como una hoja de cálculo o una tabla SQL, o un diccionario de objetos Series. . Es el objeto pandas más utilizado. Al igual que las Series, los DataFrames aceptan muchos tipos diferentes de entrada: . Junto con los datos, opcionalmente puede pasar argumentos de índice (etiquetas de fila) y columnas (etiquetas de columna). Si pasa un índice y/o columnas, está garantizando el índice y/o columnas del DataFrame resultante. Por lo tanto, un diccionario de Series más un índice específico descartará todos los datos que no coincidan con el índice pasado . Si no se pasan las etiquetas de los ejes, se construirán a partir de los datos de entrada basándose en reglas de sentido común. . 3.2.1. DataFrames desde un diccionario de Series . Si se pasa un diccionario con Series se creará el DataFrame con tantas columnas como Series tenga el diccionario . diccionario = { &quot;uno&quot;: pd.Series([1.0, 2.0, 3.0]), &quot;dos&quot;: pd.Series([4.0, 5.0, 6.0, 7.0]) } dataframe = pd.DataFrame(diccionario) dataframe . uno dos . 0 1.0 | 4.0 | . 1 2.0 | 5.0 | . 2 3.0 | 6.0 | . 3 NaN | 7.0 | . Si cada una de las Series tiene índices definidos, el DataFrame resultante será la unión de estos índices . diccionario = { &quot;uno&quot;: pd.Series([1.0, 2.0, 3.0], index=[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]), &quot;dos&quot;: pd.Series([4.0, 5.0, 6.0, 7.0], index=[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]) } dataframe = pd.DataFrame(diccionario) dataframe . uno dos . a 1.0 | 4.0 | . b 2.0 | 5.0 | . c 3.0 | 6.0 | . d NaN | 7.0 | . dataframe = pd.DataFrame(diccionario, index=[&quot;d&quot;, &quot;b&quot;, &quot;a&quot;]) dataframe . uno dos . d NaN | 7.0 | . b 2.0 | 5.0 | . a 1.0 | 4.0 | . Si se le pasa las columnas aparecerán en el orden pasado . dataframe = pd.DataFrame(diccionario, columns=[&quot;dos&quot;, &quot;tres&quot;]) dataframe . dos tres . a 4.0 | NaN | . b 5.0 | NaN | . c 6.0 | NaN | . d 7.0 | NaN | . 3.2.2. DataFrames desde un diccionario de ndarrays o listas . Todos los ndarrays o listas deben tener la misma longitud. Si se pasa un índice, también debe tener la misma longitud que los ndarrays o listas . diccionario = { &quot;uno&quot;: [1.0, 2.0, 3.0, 4.0], &quot;dos&quot;: [4.0, 3.0, 2.0, 1.0] } dataframe = pd.DataFrame(diccionario) dataframe . uno dos . 0 1.0 | 4.0 | . 1 2.0 | 3.0 | . 2 3.0 | 2.0 | . 3 4.0 | 1.0 | . 3.2.3. DataFrames desde una matriz . Si se pasa un índice tiene que tener la misma longitud que el número de filas de la matriz y si se pasan las columnas tienen que tener la misma longitud que las columnas de la matriz . matriz = np.array([[1, 3], [2, 2], [3, 1]]) dataframe = pd.DataFrame(matriz, index=[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], columns=[&quot;columna1&quot;, &quot;columna2&quot;]) dataframe . columna1 columna2 . a 1 | 3 | . b 2 | 2 | . c 3 | 1 | . 3.2.4. DataFrames desde una lista de diccionarios . lista = [{&quot;a&quot;: 1, &quot;b&quot;: 2}, {&quot;a&quot;: 5, &quot;b&quot;: 10, &quot;c&quot;: 20}] dataframe = pd.DataFrame(lista) dataframe . a b c . 0 1 | 2 | NaN | . 1 5 | 10 | 20.0 | . 3.2.5. DataFrames desde un diccionario de tuplas . diccionario = { (&quot;a&quot;, &quot;b&quot;): {(&quot;A&quot;, &quot;B&quot;): 1, (&quot;A&quot;, &quot;C&quot;): 2}, (&quot;a&quot;, &quot;a&quot;): {(&quot;A&quot;, &quot;C&quot;): 3, (&quot;A&quot;, &quot;B&quot;): 4}, (&quot;a&quot;, &quot;c&quot;): {(&quot;A&quot;, &quot;B&quot;): 5, (&quot;A&quot;, &quot;C&quot;): 6}, (&quot;b&quot;, &quot;a&quot;): {(&quot;A&quot;, &quot;C&quot;): 7, (&quot;A&quot;, &quot;B&quot;): 8}, (&quot;b&quot;, &quot;b&quot;): {(&quot;A&quot;, &quot;D&quot;): 9, (&quot;A&quot;, &quot;B&quot;): 10}, } dataframe = pd.DataFrame(diccionario) dataframe . a b . b a c a b . A B 1.0 | 4.0 | 5.0 | 8.0 | 10.0 | . C 2.0 | 3.0 | 6.0 | 7.0 | NaN | . D NaN | NaN | NaN | NaN | 9.0 | . 3.2.6. DataFrames desde una Serie . El resultado será un DataFrame con el mismo índice que la Serie de entrada, y con una columna cuyo nombre es el nombre original de la Serie (solo si no se proporciona otro nombre de columna). . diccionario = {&quot;b&quot;: 1, &quot;a&quot;: 0, &quot;c&quot;: 2} serie = pd.Series(diccionario) dataframe = pd.DataFrame(serie) dataframe . 0 . b 1 | . a 0 | . c 2 | . 4. Exploraci&#243;n de un DataFrame . Cuando un DataFrame es muy grande no se puede representar entero . california_housing_train = pd.read_csv(&quot;/content/sample_data/california_housing_train.csv&quot;) california_housing_train . longitude latitude housing_median_age total_rooms total_bedrooms population households median_income median_house_value . 0 -114.31 | 34.19 | 15.0 | 5612.0 | 1283.0 | 1015.0 | 472.0 | 1.4936 | 66900.0 | . 1 -114.47 | 34.40 | 19.0 | 7650.0 | 1901.0 | 1129.0 | 463.0 | 1.8200 | 80100.0 | . 2 -114.56 | 33.69 | 17.0 | 720.0 | 174.0 | 333.0 | 117.0 | 1.6509 | 85700.0 | . 3 -114.57 | 33.64 | 14.0 | 1501.0 | 337.0 | 515.0 | 226.0 | 3.1917 | 73400.0 | . 4 -114.57 | 33.57 | 20.0 | 1454.0 | 326.0 | 624.0 | 262.0 | 1.9250 | 65500.0 | . ... ... | ... | ... | ... | ... | ... | ... | ... | ... | . 16995 -124.26 | 40.58 | 52.0 | 2217.0 | 394.0 | 907.0 | 369.0 | 2.3571 | 111400.0 | . 16996 -124.27 | 40.69 | 36.0 | 2349.0 | 528.0 | 1194.0 | 465.0 | 2.5179 | 79000.0 | . 16997 -124.30 | 41.84 | 17.0 | 2677.0 | 531.0 | 1244.0 | 456.0 | 3.0313 | 103600.0 | . 16998 -124.30 | 41.80 | 19.0 | 2672.0 | 552.0 | 1298.0 | 478.0 | 1.9797 | 85800.0 | . 16999 -124.35 | 40.54 | 52.0 | 1820.0 | 300.0 | 806.0 | 270.0 | 3.0147 | 94600.0 | . 17000 rows × 9 columns . Por lo que es muy útil tener métodos para explorarlo y obtener información de manera rápida . 4.1. Cabeza del DataFrame . Para ver las primeras filas y hacerse una ídea de cómo es el DataFrame existe el metodo head(), que por defecto muestra las primeras 5 filas del DataFrame. Si se quiere ver un número distinto de filas introducirlo mediante el atributo n . california_housing_train.head(n=10) . longitude latitude housing_median_age total_rooms total_bedrooms population households median_income median_house_value . 0 -114.31 | 34.19 | 15.0 | 5612.0 | 1283.0 | 1015.0 | 472.0 | 1.4936 | 66900.0 | . 1 -114.47 | 34.40 | 19.0 | 7650.0 | 1901.0 | 1129.0 | 463.0 | 1.8200 | 80100.0 | . 2 -114.56 | 33.69 | 17.0 | 720.0 | 174.0 | 333.0 | 117.0 | 1.6509 | 85700.0 | . 3 -114.57 | 33.64 | 14.0 | 1501.0 | 337.0 | 515.0 | 226.0 | 3.1917 | 73400.0 | . 4 -114.57 | 33.57 | 20.0 | 1454.0 | 326.0 | 624.0 | 262.0 | 1.9250 | 65500.0 | . 5 -114.58 | 33.63 | 29.0 | 1387.0 | 236.0 | 671.0 | 239.0 | 3.3438 | 74000.0 | . 6 -114.58 | 33.61 | 25.0 | 2907.0 | 680.0 | 1841.0 | 633.0 | 2.6768 | 82400.0 | . 7 -114.59 | 34.83 | 41.0 | 812.0 | 168.0 | 375.0 | 158.0 | 1.7083 | 48500.0 | . 8 -114.59 | 33.61 | 34.0 | 4789.0 | 1175.0 | 3134.0 | 1056.0 | 2.1782 | 58400.0 | . 9 -114.60 | 34.83 | 46.0 | 1497.0 | 309.0 | 787.0 | 271.0 | 2.1908 | 48100.0 | . 4.2. Cola del DataFrame . Si lo que se quiere es ver las últimas filas se puede usar el método tail(), mediante el atributo n se elige cuantas filas mostrar . california_housing_train.tail() . longitude latitude housing_median_age total_rooms total_bedrooms population households median_income median_house_value . 16995 -124.26 | 40.58 | 52.0 | 2217.0 | 394.0 | 907.0 | 369.0 | 2.3571 | 111400.0 | . 16996 -124.27 | 40.69 | 36.0 | 2349.0 | 528.0 | 1194.0 | 465.0 | 2.5179 | 79000.0 | . 16997 -124.30 | 41.84 | 17.0 | 2677.0 | 531.0 | 1244.0 | 456.0 | 3.0313 | 103600.0 | . 16998 -124.30 | 41.80 | 19.0 | 2672.0 | 552.0 | 1298.0 | 478.0 | 1.9797 | 85800.0 | . 16999 -124.35 | 40.54 | 52.0 | 1820.0 | 300.0 | 806.0 | 270.0 | 3.0147 | 94600.0 | . 4.3. Informaci&#243;n del DataFrame . Otro método muy util es info() que nos da información del DataFrame . california_housing_train.info() . &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; RangeIndex: 17000 entries, 0 to 16999 Data columns (total 9 columns): # Column Non-Null Count Dtype -- -- 0 longitude 17000 non-null float64 1 latitude 17000 non-null float64 2 housing_median_age 17000 non-null float64 3 total_rooms 17000 non-null float64 4 total_bedrooms 17000 non-null float64 5 population 17000 non-null float64 6 households 17000 non-null float64 7 median_income 17000 non-null float64 8 median_house_value 17000 non-null float64 dtypes: float64(9) memory usage: 1.2 MB . 4.4. Filas y columnas DataFrame . Se pueden obtener los índices y las columnas de un DataFrame mediante los métodos index y columns . diccionario = { &quot;uno&quot;: pd.Series([1.0, 2.0, 3.0], index=[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]), &quot;dos&quot;: pd.Series([4.0, 5.0, 6.0, 7.0], index=[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]) } dataframe = pd.DataFrame(diccionario) indices = dataframe.index columnas = dataframe.columns print(f&quot;El DataFrame tiene los índices n t{indices} n&quot;) print(f&quot;El DataFrame tiene las columnas n t{columnas}&quot;) . El DataFrame tiene los índices Index([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;], dtype=&#39;object&#39;) El DataFrame tiene las columnas Index([&#39;uno&#39;, &#39;dos&#39;], dtype=&#39;object&#39;) . 4.5. Descripci&#243;n del DataFrame . El método describe() muestra un resumen estadístico rápido de los datos del DataFrame . california_housing_train = pd.read_csv(&quot;/content/sample_data/california_housing_train.csv&quot;) california_housing_train.describe() . longitude latitude housing_median_age total_rooms total_bedrooms population households median_income median_house_value . count 17000.000000 | 17000.000000 | 17000.000000 | 17000.000000 | 17000.000000 | 17000.000000 | 17000.000000 | 17000.000000 | 17000.000000 | . mean -119.562108 | 35.625225 | 28.589353 | 2643.664412 | 539.410824 | 1429.573941 | 501.221941 | 3.883578 | 207300.912353 | . std 2.005166 | 2.137340 | 12.586937 | 2179.947071 | 421.499452 | 1147.852959 | 384.520841 | 1.908157 | 115983.764387 | . min -124.350000 | 32.540000 | 1.000000 | 2.000000 | 1.000000 | 3.000000 | 1.000000 | 0.499900 | 14999.000000 | . 25% -121.790000 | 33.930000 | 18.000000 | 1462.000000 | 297.000000 | 790.000000 | 282.000000 | 2.566375 | 119400.000000 | . 50% -118.490000 | 34.250000 | 29.000000 | 2127.000000 | 434.000000 | 1167.000000 | 409.000000 | 3.544600 | 180400.000000 | . 75% -118.000000 | 37.720000 | 37.000000 | 3151.250000 | 648.250000 | 1721.000000 | 605.250000 | 4.767000 | 265000.000000 | . max -114.310000 | 41.950000 | 52.000000 | 37937.000000 | 6445.000000 | 35682.000000 | 6082.000000 | 15.000100 | 500001.000000 | . 4.6. Ordenaci&#243;n del DataFrame . Se pueden ordenar alfabéticamente las filas de un DataFrame mediante el método sort_index() . california_housing_train = pd.read_csv(&quot;/content/sample_data/california_housing_train.csv&quot;) california_housing_train.sort_index().head() . longitude latitude housing_median_age total_rooms total_bedrooms population households median_income median_house_value . 0 -114.31 | 34.19 | 15.0 | 5612.0 | 1283.0 | 1015.0 | 472.0 | 1.4936 | 66900.0 | . 1 -114.47 | 34.40 | 19.0 | 7650.0 | 1901.0 | 1129.0 | 463.0 | 1.8200 | 80100.0 | . 2 -114.56 | 33.69 | 17.0 | 720.0 | 174.0 | 333.0 | 117.0 | 1.6509 | 85700.0 | . 3 -114.57 | 33.64 | 14.0 | 1501.0 | 337.0 | 515.0 | 226.0 | 3.1917 | 73400.0 | . 4 -114.57 | 33.57 | 20.0 | 1454.0 | 326.0 | 624.0 | 262.0 | 1.9250 | 65500.0 | . Como en este caso las filas ya estaban ordenadas establecemos ascending=False para que el orden sea al revés . california_housing_train.sort_index(ascending=False).head() . longitude latitude housing_median_age total_rooms total_bedrooms population households median_income median_house_value . 16999 -124.35 | 40.54 | 52.0 | 1820.0 | 300.0 | 806.0 | 270.0 | 3.0147 | 94600.0 | . 16998 -124.30 | 41.80 | 19.0 | 2672.0 | 552.0 | 1298.0 | 478.0 | 1.9797 | 85800.0 | . 16997 -124.30 | 41.84 | 17.0 | 2677.0 | 531.0 | 1244.0 | 456.0 | 3.0313 | 103600.0 | . 16996 -124.27 | 40.69 | 36.0 | 2349.0 | 528.0 | 1194.0 | 465.0 | 2.5179 | 79000.0 | . 16995 -124.26 | 40.58 | 52.0 | 2217.0 | 394.0 | 907.0 | 369.0 | 2.3571 | 111400.0 | . Si lo que se quiere son ordenar las columnas hay que introducir index=1 ya que por defecto es 0 . california_housing_train.sort_index(axis=1).head() . households housing_median_age latitude longitude median_house_value median_income population total_bedrooms total_rooms . 0 472.0 | 15.0 | 34.19 | -114.31 | 66900.0 | 1.4936 | 1015.0 | 1283.0 | 5612.0 | . 1 463.0 | 19.0 | 34.40 | -114.47 | 80100.0 | 1.8200 | 1129.0 | 1901.0 | 7650.0 | . 2 117.0 | 17.0 | 33.69 | -114.56 | 85700.0 | 1.6509 | 333.0 | 174.0 | 720.0 | . 3 226.0 | 14.0 | 33.64 | -114.57 | 73400.0 | 3.1917 | 515.0 | 337.0 | 1501.0 | . 4 262.0 | 20.0 | 33.57 | -114.57 | 65500.0 | 1.9250 | 624.0 | 326.0 | 1454.0 | . Si lo que queremos es ordenar el DataFrame a través de una columna determinada tenemos que usar el método sort_values() e indicarle la etiqueta de la columna sobre la que se quiere ordenar . california_housing_train.sort_values(&#39;median_house_value&#39;) . longitude latitude housing_median_age total_rooms total_bedrooms population households median_income median_house_value . 568 -117.02 | 36.40 | 19.0 | 619.0 | 239.0 | 490.0 | 164.0 | 2.1000 | 14999.0 | . 16643 -122.74 | 39.71 | 16.0 | 255.0 | 73.0 | 85.0 | 38.0 | 1.6607 | 14999.0 | . 16801 -123.17 | 40.31 | 36.0 | 98.0 | 28.0 | 18.0 | 8.0 | 0.5360 | 14999.0 | . 3226 -117.86 | 34.24 | 52.0 | 803.0 | 267.0 | 628.0 | 225.0 | 4.1932 | 14999.0 | . 7182 -118.33 | 34.15 | 39.0 | 493.0 | 168.0 | 259.0 | 138.0 | 2.3667 | 17500.0 | . ... ... | ... | ... | ... | ... | ... | ... | ... | ... | . 15834 -122.42 | 37.81 | 52.0 | 1314.0 | 317.0 | 473.0 | 250.0 | 4.3472 | 500001.0 | . 7927 -118.40 | 33.87 | 38.0 | 2398.0 | 431.0 | 911.0 | 392.0 | 5.2319 | 500001.0 | . 3546 -117.90 | 33.63 | 28.0 | 2370.0 | 352.0 | 832.0 | 347.0 | 7.1148 | 500001.0 | . 7924 -118.40 | 33.88 | 35.0 | 1060.0 | 191.0 | 444.0 | 196.0 | 8.0015 | 500001.0 | . 14011 -122.04 | 37.26 | 24.0 | 4973.0 | 709.0 | 1692.0 | 696.0 | 7.8627 | 500001.0 | . 17000 rows × 9 columns . 4.7. Estad&#237;sticas del DataFrame . Se pueden obtener estadísticas del DataFrame, como la media, la moda, la desviación estandar . california_housing_train = pd.read_csv(&quot;/content/sample_data/california_housing_train.csv&quot;) print(f&quot;media: n{california_housing_train.mean()}&quot;) print(f&quot; n ndesviación estandar: n{california_housing_train.std()}&quot;) . media: longitude -119.562108 latitude 35.625225 housing_median_age 28.589353 total_rooms 2643.664412 total_bedrooms 539.410824 population 1429.573941 households 501.221941 median_income 3.883578 median_house_value 207300.912353 dtype: float64 desviación estandar: longitude 2.005166 latitude 2.137340 housing_median_age 12.586937 total_rooms 2179.947071 total_bedrooms 421.499452 population 1147.852959 households 384.520841 median_income 1.908157 median_house_value 115983.764387 dtype: float64 . Si se quieren obtener las estadísticas sobre las filas y no sobre las comlumnas hay que indicarlo mediante axis=1 . california_housing_train = pd.read_csv(&quot;/content/sample_data/california_housing_train.csv&quot;) print(f&quot;media: n{california_housing_train.mean(axis=1)}&quot;) print(f&quot; n ndesviación estandar: n{california_housing_train.std(axis=1)}&quot;) . media: 0 8357.597067 1 10131.527778 2 9664.642322 3 8435.029078 4 7567.436111 ... 16995 12806.408567 16996 9276.770878 16997 12049.507922 16998 10082.053300 16999 10863.022744 Length: 17000, dtype: float64 desviación estandar: 0 22026.612445 1 26352.939272 2 28514.316588 3 24366.754747 4 21730.014569 ... 16995 36979.676899 16996 26158.006771 16997 34342.876792 16998 28408.152329 16999 31407.119788 Length: 17000, dtype: float64 . Otra cosa útil que se puede obtener de los DataFrames es por ejemplo el número de veces que se repite cada item de una columna . california_housing_train[&quot;total_rooms&quot;].value_counts() . 1582.0 16 1527.0 15 1717.0 14 1471.0 14 1703.0 14 .. 157.0 1 2760.0 1 458.0 1 10239.0 1 4068.0 1 Name: total_rooms, Length: 5533, dtype: int64 . Por ejemplo podemos ver que hay un total de 16 casas con 1582 habitaciones! . 5. Adici&#243;n de columnas . Se pueden añadir columnas facilmente como operaciones de otras columnas . diccionario = { &quot;uno&quot;: pd.Series([1.0, 2.0, 3.0]), &quot;dos&quot;: pd.Series([4.0, 5.0, 6.0, 7.0]) } dataframe = pd.DataFrame(diccionario) dataframe[&quot;tres&quot;] = dataframe[&quot;uno&quot;] + dataframe[&quot;dos&quot;] dataframe[&quot;flag&quot;] = dataframe[&quot;tres&quot;] &gt; 7.0 dataframe . uno dos tres flag . 0 1.0 | 4.0 | 5.0 | False | . 1 2.0 | 5.0 | 7.0 | False | . 2 3.0 | 6.0 | 9.0 | True | . 3 NaN | 7.0 | NaN | False | . También se pueden añadir columnas indicando qué valor tendrán todos sus items . dataframe[&quot;constante&quot;] = 8.0 dataframe . uno dos tres flag constante . 0 1.0 | 4.0 | 5.0 | False | 8.0 | . 1 2.0 | 5.0 | 7.0 | False | 8.0 | . 2 3.0 | 6.0 | 9.0 | True | 8.0 | . 3 NaN | 7.0 | NaN | False | 8.0 | . Si se añade una Serie que no tiene el mismo número de índices que el DataFrame, esta se ajustará al número de índices del DatFrame . dataframe[&quot;Menos indices&quot;] = dataframe[&quot;uno&quot;][:2] dataframe . uno dos tres flag constante Menos indices . 0 1.0 | 4.0 | 5.0 | False | 8.0 | 1.0 | . 1 2.0 | 5.0 | 7.0 | False | 8.0 | 2.0 | . 2 3.0 | 6.0 | 9.0 | True | 8.0 | NaN | . 3 NaN | 7.0 | NaN | False | 8.0 | NaN | . Con los métodos anteriores la columna se añadía al final, pero si se quiere añadir la columna en una posición determinda se puede usar el método insert(). . Por ejemplo, si se quiere añadir una columna en la posición 3 (teniendo en cuenta que se empieza a contar desde la posición 0), que el nombre de la columna sea columna insertada y que su valor sea el doble que el de la columna tres se haría de la siguiente manera . dataframe.insert(loc=3, column=&quot;columna insertada&quot;, value=dataframe[&quot;tres&quot;]*2) dataframe . uno dos tres columna insertada flag constante Menos indices . 0 1.0 | 4.0 | 5.0 | 10.0 | False | 8.0 | 1.0 | . 1 2.0 | 5.0 | 7.0 | 14.0 | False | 8.0 | 2.0 | . 2 3.0 | 6.0 | 9.0 | 18.0 | True | 8.0 | NaN | . 3 NaN | 7.0 | NaN | NaN | False | 8.0 | NaN | . Si se quiere añadir más de una columna por comando se puede usar el método assign() . dataframe = dataframe.assign( columna_asignada1 = dataframe[&quot;uno&quot;] * dataframe[&quot;tres&quot;], columna_asignada2 = dataframe[&quot;dos&quot;] * dataframe[&quot;tres&quot;], ) dataframe . uno dos tres columna insertada flag constante Menos indices columna_asignada1 columna_asignada2 . 0 1.0 | 4.0 | 5.0 | 10.0 | False | 8.0 | 1.0 | 5.0 | 20.0 | . 1 2.0 | 5.0 | 7.0 | 14.0 | False | 8.0 | 2.0 | 14.0 | 35.0 | . 2 3.0 | 6.0 | 9.0 | 18.0 | True | 8.0 | NaN | 27.0 | 54.0 | . 3 NaN | 7.0 | NaN | NaN | False | 8.0 | NaN | NaN | NaN | . 6. Eliminaci&#243;n de columnas . Se puede eliminar una columna determinada mediante el método pop() . dataframe.pop(&quot;constante&quot;) dataframe . uno dos tres columna insertada flag Menos indices columna_asignada1 columna_asignada2 . 0 1.0 | 4.0 | 5.0 | 10.0 | False | 1.0 | 5.0 | 20.0 | . 1 2.0 | 5.0 | 7.0 | 14.0 | False | 2.0 | 14.0 | 35.0 | . 2 3.0 | 6.0 | 9.0 | 18.0 | True | NaN | 27.0 | 54.0 | . 3 NaN | 7.0 | NaN | NaN | False | NaN | NaN | NaN | . O mediante del . del dataframe[&quot;flag&quot;] dataframe . uno dos tres columna insertada Menos indices columna_asignada1 columna_asignada2 . 0 1.0 | 4.0 | 5.0 | 10.0 | 1.0 | 5.0 | 20.0 | . 1 2.0 | 5.0 | 7.0 | 14.0 | 2.0 | 14.0 | 35.0 | . 2 3.0 | 6.0 | 9.0 | 18.0 | NaN | 27.0 | 54.0 | . 3 NaN | 7.0 | NaN | NaN | NaN | NaN | NaN | . 7. Operaciones sobre DataFrames . Se pueden realizar operaciones sobre los DataFrames al igual que se podía hacer con Numpy . dataframe[ [&quot;uno&quot;, &quot;dos&quot;, &quot;tres&quot;] ] * 2 . uno dos tres . 0 2.0 | 8.0 | 10.0 | . 1 4.0 | 10.0 | 14.0 | . 2 6.0 | 12.0 | 18.0 | . 3 NaN | 14.0 | NaN | . np.exp(dataframe[ [&quot;uno&quot;, &quot;dos&quot;, &quot;tres&quot;] ]) . uno dos tres . 0 2.718282 | 54.598150 | 148.413159 | . 1 7.389056 | 148.413159 | 1096.633158 | . 2 20.085537 | 403.428793 | 8103.083928 | . 3 NaN | 1096.633158 | NaN | . Si se quiere realizar operaciones más complejas se puede utilizar el método apply() . dataframe = dataframe.apply(lambda x: x.max() - x.min()) dataframe . uno 2.0 dos 3.0 tres 4.0 columna insertada 8.0 Menos indices 1.0 columna_asignada1 22.0 columna_asignada2 34.0 dtype: float64 . 8. Transpuesta . Se puede hacer la transpuesta de un DataFrame mediante el método T . diccionario = { &quot;uno&quot;: pd.Series([1.0, 2.0, 3.0], index=[&quot;fila a&quot;, &quot;fila b&quot;, &quot;fila c&quot;]), &quot;dos&quot;: pd.Series([4.0, 5.0, 6.0], index=[&quot;fila a&quot;, &quot;fila b&quot;, &quot;fila c&quot;]) } dataframe = pd.DataFrame(diccionario) dataframe[&quot;tres&quot;] = dataframe[&quot;uno&quot;] + dataframe[&quot;dos&quot;] dataframe[&quot;flag&quot;] = dataframe[&quot;tres&quot;] &gt; 7.0 dataframe.T . fila a fila b fila c . uno 1 | 2 | 3 | . dos 4 | 5 | 6 | . tres 5 | 7 | 9 | . flag False | False | True | . 9. Conversi&#243;n a Numpy . Si se quiere convertir una Serie o DataFrame a Numpy se puede usar el método to_numpy() o usar la función np.asarray() . diccionario = { &quot;uno&quot;: pd.Series([1.0, 2.0, 3.0], index=[&quot;fila a&quot;, &quot;fila b&quot;, &quot;fila c&quot;]), &quot;dos&quot;: pd.Series([4.0, 5.0, 6.0], index=[&quot;fila a&quot;, &quot;fila b&quot;, &quot;fila c&quot;]) } dataframe = pd.DataFrame(diccionario) dataframe[&quot;tres&quot;] = dataframe[&quot;uno&quot;] + dataframe[&quot;dos&quot;] dataframe[&quot;flag&quot;] = dataframe[&quot;tres&quot;] &gt; 7.0 dataframe . uno dos tres flag . fila a 1.0 | 4.0 | 5.0 | False | . fila b 2.0 | 5.0 | 7.0 | False | . fila c 3.0 | 6.0 | 9.0 | True | . matriz_np = dataframe.to_numpy() matriz_np . array([[1.0, 4.0, 5.0, False], [2.0, 5.0, 7.0, False], [3.0, 6.0, 9.0, True]], dtype=object) . matriz_np = np.asarray(dataframe) matriz_np . array([[1.0, 4.0, 5.0, False], [2.0, 5.0, 7.0, False], [3.0, 6.0, 9.0, True]], dtype=object) . Este ejemplo no es el más indicado, ya que mezcla números con booleanos, y como ya explicamos en el anterior posst Cálculo matricial con Numpy, todos los elementos de un ndarray tienen que ser del mismo tipo. . En este caso estamos mezclando números con booleanos, por lo que para solucionarlo Numpy los convierte todos a objetos . Para solucionar esto nos quedamos solo con los números y los convertimos a un ndarray . matriz_np = dataframe[ [&quot;uno&quot;, &quot;dos&quot;, &quot;tres&quot;] ].to_numpy() matriz_np, matriz_np.dtype . (array([[1., 4., 5.], [2., 5., 7.], [3., 6., 9.]]), dtype(&#39;float64&#39;)) . Ahora se puede ver que se ha creado un ndarray donde todos los datos son de tipo float . 10. Lectura de datos de fuentes externas . Una de las mayores fortalezas de Pandas es poder leer datos de archivos, por lo que no es necesario crearse un DataFrame con los datos que se quieren procesar, sino que se pueden leer de un archivo . De la misma manera que se pueden crear DataFrames de archivos externos, también se pueden guardar DataFrames en archivos, para así crearte tu propio set de datos, configurarlo de la manera que quieras y guardarlo en un archivo para poder usarlo más adelante . En la siguiente tabla se muestran las funciones para leer y escribir archivos de distintos formatos . Fromato Tipo de archivo Función de lectura Función de escritura . texto | CSV | read_csv | to_csv | . texto | Fixed-Width Text File | read_fwf | | . texto | JSON | read_json | to_json | . texto | HTML | read_html | to_html | . texto | Local clipboard | read_clipboard | to_clipboard | . binary | MS Excel | read_excel | to_excel | . binary | OpenDocument | read_excel | . binary | HDF5 Format | read_hdf | to_hdf | . binary | Feather Format | read_feather | to_feather | . binary | Parquet Format | read_parquet | to_parquet | . binary | ORC Format | read_orc | . binary | Msgpack | read_msgpack | to_msgpack | . binary | Stata | read_stata | to_stata | . binary | SAS | read_sas | . binary | SPSS | read_spss | . binary | Python Pickle Format | read_pickle | to_pickle | . SQL | SQL | read_sql | to_sql | . SQL | Google BigQuery | read_gbq | to_gbq | . 11. Indexaci&#243;n en DataFrames . Hay muchas maneras de indexar en los DatFrames, . fechas = pd.date_range(&#39;1/1/2000&#39;, periods=8) dataframe = pd.DataFrame(np.random.randn(8, 4), index=fechas, columns=[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;]) dataframe . A B C D . 2000-01-01 -0.341962 | 0.639913 | 0.765817 | 0.056692 | . 2000-01-02 0.507258 | -0.942036 | -0.003828 | 0.782191 | . 2000-01-03 -1.463557 | 1.041023 | -1.321715 | 2.822735 | . 2000-01-04 1.781058 | -1.849352 | -0.620466 | -0.497001 | . 2000-01-05 0.318897 | -0.229218 | -1.095593 | -0.186248 | . 2000-01-06 0.362064 | -0.193479 | -0.779446 | -0.685112 | . 2000-01-07 -0.084632 | -0.112474 | -0.108556 | 1.031709 | . 2000-01-08 0.739424 | 0.253191 | 0.196287 | -0.242741 | . 11.1. Indexaci&#243;n por de columnas . Para seleccionar columnas dentro de un DataFrame lo podemos hacer seleccionando la columna entre corchetes [], o indicando la columna como si fuese un método del DataFrame . dataframe[&#39;A&#39;] . 2000-01-01 0.813153 2000-01-02 -0.244584 2000-01-03 0.125729 2000-01-04 0.352275 2000-01-05 -2.050976 2000-01-06 -0.312296 2000-01-07 0.897837 2000-01-08 0.271403 Freq: D, Name: A, dtype: float64 . dataframe.A . 2000-01-01 0.813153 2000-01-02 -0.244584 2000-01-03 0.125729 2000-01-04 0.352275 2000-01-05 -2.050976 2000-01-06 -0.312296 2000-01-07 0.897837 2000-01-08 0.271403 Freq: D, Name: A, dtype: float64 . Si se quiere unas filas determinadas se pasan mediante una lista . dataframe[ [&#39;A&#39;, &#39;B&#39;] ] . A B . 2000-01-01 -0.341962 | 0.639913 | . 2000-01-02 0.507258 | -0.942036 | . 2000-01-03 -1.463557 | 1.041023 | . 2000-01-04 1.781058 | -1.849352 | . 2000-01-05 0.318897 | -0.229218 | . 2000-01-06 0.362064 | -0.193479 | . 2000-01-07 -0.084632 | -0.112474 | . 2000-01-08 0.739424 | 0.253191 | . 11.2. Indexaci&#243;n de filas por posiciones . Se puede seleccionar un rango de filas de un DataFrame de la siguiente manera . dataframe[0:3] . A B C D . 2000-01-01 0.813153 | -0.869356 | 0.934293 | 0.338644 | . 2000-01-02 -0.244584 | 0.536352 | 0.322248 | 0.238903 | . 2000-01-03 0.125729 | 2.046910 | -0.877466 | -0.710034 | . Si solo se quiere seleccionar una sola fila, hay que indicar un rago de filas que incluya solo a esa, si por ejemplo se quiere seleccionar la fila numero 1 . dataframe[1:2] . A B C D . 2000-01-02 -0.244584 | 0.536352 | 0.322248 | 0.238903 | . Otro método para seleccionar una fila por su posicione es el método iloc[] . dataframe.iloc[0:3] . A B C D . 2000-01-01 0.813153 | -0.869356 | 0.934293 | 0.338644 | . 2000-01-02 -0.244584 | 0.536352 | 0.322248 | 0.238903 | . 2000-01-03 0.125729 | 2.046910 | -0.877466 | -0.710034 | . Si se quieren unas filas determinadas se pasa una lista con sus posiciones . dataframe.iloc[ [0, 2, 4] ] . A B C D . 2000-01-01 -0.341962 | 0.639913 | 0.765817 | 0.056692 | . 2000-01-03 -1.463557 | 1.041023 | -1.321715 | 2.822735 | . 2000-01-05 0.318897 | -0.229218 | -1.095593 | -0.186248 | . 11.3. Indexaci&#243;n de filas por etiquetas . Para seleccionar una fila por sus etiquetas podemos usar el método loc[] . dataframe.loc[&#39;2000-01-01&#39;] . A 0.813153 B -0.869356 C 0.934293 D 0.338644 Name: 2000-01-01 00:00:00, dtype: float64 . Si se quiere seleccionar un rango de filas podemos indexarlas mediante los dos puntos : . dataframe.loc[&#39;2000-01-01&#39;:&#39;2000-01-03&#39;] . A B C D . 2000-01-01 0.813153 | -0.869356 | 0.934293 | 0.338644 | . 2000-01-02 -0.244584 | 0.536352 | 0.322248 | 0.238903 | . 2000-01-03 0.125729 | 2.046910 | -0.877466 | -0.710034 | . Si se quiere unas filas determinadas se pasan mediante una lista . dataframe.loc[ [&#39;2000-01-01&#39;, &#39;2000-01-03&#39;, &#39;2000-01-05&#39;] ] . A B C D . 2000-01-01 -0.341962 | 0.639913 | 0.765817 | 0.056692 | . 2000-01-03 -1.463557 | 1.041023 | -1.321715 | 2.822735 | . 2000-01-05 0.318897 | -0.229218 | -1.095593 | -0.186248 | . 11.4. Selecci&#243;n de una porci&#243;n del DataFrame mediante posiciones . dataframe.iloc[0:3, 0:2] . A B . 2000-01-01 0.813153 | -0.869356 | . 2000-01-02 -0.244584 | 0.536352 | . 2000-01-03 0.125729 | 2.046910 | . Si se quieren unas filas y columnas determinadas se pasan listas con las posiciones deseadas . dataframe.iloc[ [0, 2, 4], [0, 2] ] . A C . 2000-01-01 -0.341962 | 0.765817 | . 2000-01-03 -1.463557 | -1.321715 | . 2000-01-05 0.318897 | -1.095593 | . 11.5. Selecci&#243;n de una porci&#243;n del DataFrame mediante etiquetas . dataframe.loc[&#39;2000-01-01&#39;:&#39;2000-01-03&#39;, &#39;A&#39;:&#39;B&#39;] . A B . 2000-01-01 0.813153 | -0.869356 | . 2000-01-02 -0.244584 | 0.536352 | . 2000-01-03 0.125729 | 2.046910 | . Si se quieren unas filas y columnas determinadas se pasan listas con las etiquetas deseadas . dataframe.loc[ [&#39;2000-01-01&#39;, &#39;2000-01-03&#39;, &#39;2000-01-05&#39;], [&#39;A&#39;, &#39;C&#39;] ] . A C . 2000-01-01 -0.341962 | 0.765817 | . 2000-01-03 -1.463557 | -1.321715 | . 2000-01-05 0.318897 | -1.095593 | . 11.6. Indexaci&#243;n por funci&#243;n lambda . Se pueden seleccionar datos de un DataFrame que cumplan una condición dada por una función lambda . dataframe.loc[lambda dataframe:dataframe[&#39;A&#39;]&gt;0.2] . A B C D . 2000-01-01 0.813153 | -0.869356 | 0.934293 | 0.338644 | . 2000-01-04 0.352275 | -0.456871 | -0.104079 | 0.504410 | . 2000-01-07 0.897837 | 0.925645 | -1.030516 | -0.584860 | . 2000-01-08 0.271403 | 1.527116 | 0.144970 | 1.175728 | . 11.7. Indexaci&#243;n aleatoria . Mediante el método sample() obtendremos una fila aleatoria del DataFrame . dataframe.sample() . A B C D . 2000-01-06 -0.312296 | 0.129097 | -0.991085 | 1.704535 | . Si queremos más de una muestra lo indicamos con el atributo n . dataframe.sample(n=3) . A B C D . 2000-01-08 0.271403 | 1.527116 | 0.144970 | 1.175728 | . 2000-01-01 0.813153 | -0.869356 | 0.934293 | 0.338644 | . 2000-01-03 0.125729 | 2.046910 | -0.877466 | -0.710034 | . Si lo que se quiere son columnas aleatorias hay que indicarlo mediante axis=1 . dataframe.sample(axis=1) . D . 2000-01-01 0.338644 | . 2000-01-02 0.238903 | . 2000-01-03 -0.710034 | . 2000-01-04 0.504410 | . 2000-01-05 -1.601926 | . 2000-01-06 1.704535 | . 2000-01-07 -0.584860 | . 2000-01-08 1.175728 | . Si se quiere un único item del DataFrame hay que llamar dos veces al método sample() . dataframe.sample(axis=1).sample() . D . 2000-01-05 -1.601926 | . 12. Uni&#243;n de DataFrames . 12.1. Concatenaci&#243;n de DataFrames . Para concatenar varios DataFrames usamos la el método concat(), donde se le pasará una lista con los DataFrames que se quiere unir . dataframe1 = pd.DataFrame( { &quot;A&quot;: [&quot;A0&quot;, &quot;A1&quot;, &quot;A2&quot;, &quot;A3&quot;], &quot;B&quot;: [&quot;B0&quot;, &quot;B1&quot;, &quot;B2&quot;, &quot;B3&quot;], &quot;C&quot;: [&quot;C0&quot;, &quot;C1&quot;, &quot;C2&quot;, &quot;C3&quot;], &quot;D&quot;: [&quot;D0&quot;, &quot;D1&quot;, &quot;D2&quot;, &quot;D3&quot;], }, index=[0, 1, 2, 3]) dataframe2 = pd.DataFrame( { &quot;A&quot;: [&quot;A4&quot;, &quot;A5&quot;, &quot;A6&quot;, &quot;A7&quot;], &quot;B&quot;: [&quot;B4&quot;, &quot;B5&quot;, &quot;B6&quot;, &quot;B7&quot;], &quot;C&quot;: [&quot;C4&quot;, &quot;C5&quot;, &quot;C6&quot;, &quot;C7&quot;], &quot;D&quot;: [&quot;D4&quot;, &quot;D5&quot;, &quot;D6&quot;, &quot;D7&quot;], }, index=[4, 5, 6, 7]) dataframe3 = pd.DataFrame( { &quot;A&quot;: [&quot;A8&quot;, &quot;A9&quot;, &quot;A10&quot;, &quot;A11&quot;], &quot;B&quot;: [&quot;B8&quot;, &quot;B9&quot;, &quot;B10&quot;, &quot;B11&quot;], &quot;C&quot;: [&quot;C8&quot;, &quot;C9&quot;, &quot;C10&quot;, &quot;C11&quot;], &quot;D&quot;: [&quot;D8&quot;, &quot;D9&quot;, &quot;D10&quot;, &quot;D11&quot;], }, index=[8, 9, 10, 11]) dataframe = pd.concat([dataframe1, dataframe2, dataframe3]) print(f&quot;dataframe1: n{dataframe1}&quot;) print(f&quot;dataframe2: n{dataframe2}&quot;) print(f&quot;dataframe3: n{dataframe3}&quot;) print(f&quot; ndataframe: n{dataframe}&quot;) . dataframe1: A B C D 0 A0 B0 C0 D0 1 A1 B1 C1 D1 2 A2 B2 C2 D2 3 A3 B3 C3 D3 dataframe2: A B C D 4 A4 B4 C4 D4 5 A5 B5 C5 D5 6 A6 B6 C6 D6 7 A7 B7 C7 D7 dataframe3: A B C D 8 A8 B8 C8 D8 9 A9 B9 C9 D9 10 A10 B10 C10 D10 11 A11 B11 C11 D11 dataframe: A B C D 0 A0 B0 C0 D0 1 A1 B1 C1 D1 2 A2 B2 C2 D2 3 A3 B3 C3 D3 4 A4 B4 C4 D4 5 A5 B5 C5 D5 6 A6 B6 C6 D6 7 A7 B7 C7 D7 8 A8 B8 C8 D8 9 A9 B9 C9 D9 10 A10 B10 C10 D10 11 A11 B11 C11 D11 . . Si se hubiera querido hacer la concatenación a lo largo de las columnas habría que haber introducido la variable axis=1 . 12.1.1. Intersecci&#243;n de concatenaci&#243;n . Hay dos maneras de hacer la concatenación, cogiendo todos los índices de los DataFrames o cogiendo solo los que coinciden, esto se determina mediante la variable join, que admite los valores &#39;outer&#39; (por defecto) (coge todos los índices) o &#39;inner&#39; (solo los que coinciden) . Veamos un ejemplo de &#39;outer&#39; . dataframe1 = pd.DataFrame( { &quot;A&quot;: [&quot;A0&quot;, &quot;A1&quot;, &quot;A2&quot;, &quot;A3&quot;], &quot;B&quot;: [&quot;B0&quot;, &quot;B1&quot;, &quot;B2&quot;, &quot;B3&quot;], &quot;C&quot;: [&quot;C0&quot;, &quot;C1&quot;, &quot;C2&quot;, &quot;C3&quot;], &quot;D&quot;: [&quot;D0&quot;, &quot;D1&quot;, &quot;D2&quot;, &quot;D3&quot;], }, index=[0, 1, 2, 3]) dataframe4 = pd.DataFrame( { &quot;B&quot;: [&quot;B2&quot;, &quot;B3&quot;, &quot;B6&quot;, &quot;B7&quot;], &quot;D&quot;: [&quot;D2&quot;, &quot;D3&quot;, &quot;D6&quot;, &quot;D7&quot;], &quot;F&quot;: [&quot;F2&quot;, &quot;F3&quot;, &quot;F6&quot;, &quot;F7&quot;], },index=[2, 3, 6, 7]) dataframe = pd.concat([dataframe1, dataframe4], axis=1) print(f&quot;dataframe1: n{dataframe1}&quot;) print(f&quot;dataframe2: n{dataframe4}&quot;) print(f&quot; ndataframe: n{dataframe}&quot;) . dataframe1: A B C D 0 A0 B0 C0 D0 1 A1 B1 C1 D1 2 A2 B2 C2 D2 3 A3 B3 C3 D3 dataframe2: B D F 2 B2 D2 F2 3 B3 D3 F3 6 B6 D6 F6 7 B7 D7 F7 dataframe: A B C D B D F 0 A0 B0 C0 D0 NaN NaN NaN 1 A1 B1 C1 D1 NaN NaN NaN 2 A2 B2 C2 D2 B2 D2 F2 3 A3 B3 C3 D3 B3 D3 F3 6 NaN NaN NaN NaN B6 D6 F6 7 NaN NaN NaN NaN B7 D7 F7 . . Veamos un ejemplo de &#39;inner&#39; . dataframe = pd.concat([dataframe1, dataframe4], axis=1, join=&quot;inner&quot;) print(f&quot;dataframe1: n{dataframe1}&quot;) print(f&quot;dataframe2: n{dataframe4}&quot;) print(f&quot; ndataframe: n{dataframe}&quot;) . dataframe1: A B C D 0 A0 B0 C0 D0 1 A1 B1 C1 D1 2 A2 B2 C2 D2 3 A3 B3 C3 D3 dataframe2: B D F 2 B2 D2 F2 3 B3 D3 F3 6 B6 D6 F6 7 B7 D7 F7 dataframe: A B C D B D F 2 A2 B2 C2 D2 B2 D2 F2 3 A3 B3 C3 D3 B3 D3 F3 . . 13. Datos faltantes (NaN) . En un DataFrame puede haber algunos datos faltantes, Pandas los representa como np.nan . diccionario = { &quot;uno&quot;: pd.Series([1.0, 2.0, 3.0]), &quot;dos&quot;: pd.Series([4.0, 5.0, 6.0, 7.0]) } dataframe = pd.DataFrame(diccionario) dataframe . uno dos . 0 1.0 | 4.0 | . 1 2.0 | 5.0 | . 2 3.0 | 6.0 | . 3 NaN | 7.0 | . 13.1. Eliminaci&#243;n de las filas con datos faltantes . Para no tener filas con datos faltantes se pueden eliminar estas . dataframe.dropna(how=&quot;any&quot;) . uno dos . 0 1.0 | 4.0 | . 1 2.0 | 5.0 | . 2 3.0 | 6.0 | . 13.2. Eliminaci&#243;n de las columnas con datos faltantes . dataframe.dropna(axis=1, how=&#39;any&#39;) . dos . 0 4.0 | . 1 5.0 | . 2 6.0 | . 3 7.0 | . 13.3. M&#225;scara booleana con las posiciones faltantes . pd.isna(dataframe) . uno dos . 0 False | False | . 1 False | False | . 2 False | False | . 3 True | False | . 13.4. Llenado de los datos faltantes . dataframe.fillna(value=5.5, inplace=True) dataframe . uno dos . 0 1.0 | 4.0 | . 1 2.0 | 5.0 | . 2 3.0 | 6.0 | . 3 5.5 | 7.0 | . . Tip: Poniendo la variable inplace=True se modifica el DataFrame sobre el que se está operando, así no hace falta escribir Python dataframe = dataframe.fillna(value=5.5) . 14. Series temporales . Pandas ofrece la posibilidad de trabajar con series temporales. Por ejemplo creamos una Serie de 100 datos aleatorios cada segundo desde el 01/01/2021 . indices = pd.date_range(&quot;1/1/2021&quot;, periods=100, freq=&quot;S&quot;) datos = np.random.randint(0, 500, len(indices)) serie_temporal = pd.Series(datos, index=indices) serie_temporal . 2021-01-01 00:00:00 241 2021-01-01 00:00:01 14 2021-01-01 00:00:02 190 2021-01-01 00:00:03 407 2021-01-01 00:00:04 94 ... 2021-01-01 00:01:35 275 2021-01-01 00:01:36 56 2021-01-01 00:01:37 448 2021-01-01 00:01:38 151 2021-01-01 00:01:39 316 Freq: S, Length: 100, dtype: int64 . Esta funcionalidad de Pandas es muy potente, por ejemplo, podemos tener un conjunto de datos en unas horas determinadas de un uso horario y cambiarlas a otro uso . horas = pd.date_range(&quot;3/6/2021 00:00&quot;, periods=10, freq=&quot;H&quot;) datos = np.random.randn(len(horas)) serie_horaria = pd.Series(datos, horas) serie_horaria . 2021-03-06 00:00:00 -0.853524 2021-03-06 01:00:00 -1.355372 2021-03-06 02:00:00 -1.267503 2021-03-06 03:00:00 -1.155787 2021-03-06 04:00:00 0.730935 2021-03-06 05:00:00 1.435957 2021-03-06 06:00:00 0.460912 2021-03-06 07:00:00 0.723451 2021-03-06 08:00:00 -0.853337 2021-03-06 09:00:00 0.456359 Freq: H, dtype: float64 . Localizamos los datos en un uso horario . serie_horaria_utc = serie_horaria.tz_localize(&quot;UTC&quot;) serie_horaria_utc . 2021-03-06 00:00:00+00:00 -0.853524 2021-03-06 01:00:00+00:00 -1.355372 2021-03-06 02:00:00+00:00 -1.267503 2021-03-06 03:00:00+00:00 -1.155787 2021-03-06 04:00:00+00:00 0.730935 2021-03-06 05:00:00+00:00 1.435957 2021-03-06 06:00:00+00:00 0.460912 2021-03-06 07:00:00+00:00 0.723451 2021-03-06 08:00:00+00:00 -0.853337 2021-03-06 09:00:00+00:00 0.456359 Freq: H, dtype: float64 . Y ahora las podemos cambiar a otro uso . serie_horaria_US = serie_horaria_utc.tz_convert(&quot;US/Eastern&quot;) serie_horaria_US . 2021-03-05 19:00:00-05:00 -0.853524 2021-03-05 20:00:00-05:00 -1.355372 2021-03-05 21:00:00-05:00 -1.267503 2021-03-05 22:00:00-05:00 -1.155787 2021-03-05 23:00:00-05:00 0.730935 2021-03-06 00:00:00-05:00 1.435957 2021-03-06 01:00:00-05:00 0.460912 2021-03-06 02:00:00-05:00 0.723451 2021-03-06 03:00:00-05:00 -0.853337 2021-03-06 04:00:00-05:00 0.456359 Freq: H, dtype: float64 . 15. Datos categ&#243;ricos . Pandas ofrece la posibilidad de añadir datos categóricos en un DatFrame. Supongamos el siguente DataFrame . dataframe = pd.DataFrame( {&quot;id&quot;: [1, 2, 3, 4, 5, 6], &quot;raw_grade&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;a&quot;, &quot;a&quot;, &quot;e&quot;]} ) dataframe . id raw_grade . 0 1 | a | . 1 2 | b | . 2 3 | b | . 3 4 | a | . 4 5 | a | . 5 6 | e | . Podemos convertir los datos de la columna raw_rade a datos categóricos mediante el método astype() . dataframe[&#39;grade&#39;] = dataframe[&quot;raw_grade&quot;].astype(&quot;category&quot;) dataframe . id raw_grade grade . 0 1 | a | a | . 1 2 | b | b | . 2 3 | b | b | . 3 4 | a | a | . 4 5 | a | a | . 5 6 | e | e | . Las columnas raw_grade y grade parecen iguales, pero si vemos la información del DataFrame podemos ver que no es así . dataframe.info() . &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; RangeIndex: 6 entries, 0 to 5 Data columns (total 3 columns): # Column Non-Null Count Dtype -- -- 0 id 6 non-null int64 1 raw_grade 6 non-null object 2 grade 6 non-null category dtypes: category(1), int64(1), object(1) memory usage: 334.0+ bytes . Se puede ver que la columna grade es de tipo categórico . 16. Gr&#225;ficos . Pandas ofrece la posibilidad de representar los datos de nuestros DataFrames en gráficos para poder obtener una mejor representación de ello. Para ello hace uso de la librería matplotlib que veremos en el siguiente post . 16.1. Gr&#225;fica b&#225;sica . Para representar los datos en una gráfica la manera más fácil es usar el método plot() . serie = pd.Series(np.random.randn(1000), index=pd.date_range(&quot;1/1/2000&quot;, periods=1000)) serie = serie.cumsum() serie.plot() . &lt;matplotlib.axes._subplots.AxesSubplot at 0x7fc5666b9990&gt; . En el caso de tener un DataFrame el método plot() representará cada una de las columnas del DataFrame . dataframe = pd.DataFrame( np.random.randn(1000, 4), index=ts.index, columns=[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;] ) dataframe = dataframe.cumsum() dataframe.plot() . &lt;matplotlib.axes._subplots.AxesSubplot at 0x7fc5663ce610&gt; . 16.2. Diagrama de barras vertical . Hay más métodos de crear gráficos, como el diagrama de barras vertical mediante plot.bar() . dataframe = pd.DataFrame(np.random.rand(10, 4), columns=[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]) dataframe.plot.bar() . Si queremos apilar las barras lo indicamos mediante la variable stacked=True . dataframe.plot.bar(stacked=True) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x7fc56265c5d0&gt; . 16.3. Diagrama de barras horizontal . Para crear un diagrama de barras horizontal usamos plot.barh() . dataframe.plot.barh() . &lt;matplotlib.axes._subplots.AxesSubplot at 0x7fc56247fa10&gt; . Si queremos apilar las barras lo indicamos mediante la variable stacked=True . dataframe.plot.barh(stacked=True) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x7fc562d1d2d0&gt; . 16.4. Histograma . Para crear un histograma usamos plot.hist() . dataframe = pd.DataFrame( { &quot;a&quot;: np.random.randn(1000) + 1, &quot;b&quot;: np.random.randn(1000), &quot;c&quot;: np.random.randn(1000) - 1, } ) dataframe.plot.hist(alpha=0.5) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x7fc5650711d0&gt; . Si queremos apilar las barras lo indicamos mediante la variable stacked=True . dataframe.plot.hist(alpha=0.5, stacked=True) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x7fc5625779d0&gt; . Si queremos añadir más columnas, es decir, si queremos que el histograma sea más informativo o preciso, lo indicamos mediante la variable bins . dataframe.plot.hist(alpha=0.5, stacked=True, bins=20) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x7fc562324990&gt; . 16.5. Diagramas de velas . Para crear un diagrama de velas usamos plot.box() . dataframe = pd.DataFrame(np.random.rand(10, 5), columns=[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;]) dataframe.plot.box() . &lt;matplotlib.axes._subplots.AxesSubplot at 0x7fc56201a410&gt; . 16.6. Gr&#225;ficos de &#225;reas . Para crear un gráfico de áreas usamos plot.area() . dataframe.plot.area() . &lt;matplotlib.axes._subplots.AxesSubplot at 0x7fc561e9ca50&gt; . 16.7. Diagrama de dispersi&#243;n . Para crear un diagrama de dispersión usamos plot.scatter(), donde hay que indicar las variables x e y del diagrama . dataframe.plot.scatter(x=&#39;A&#39;, y=&#39;B&#39;) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x7fc561e2ff10&gt; . 16.8. Gr&#225;fico de contenedor hexagonal . Para crear un gráfico de contenedor hexagonal usamos plot.hexbin(), donde hay que indicar las variables x e y del diagrama y el tamaño de la malla mediante gridsize . dataframe = pd.DataFrame(np.random.randn(1000, 2), columns=[&quot;a&quot;, &quot;b&quot;]) dataframe[&quot;b&quot;] = dataframe[&quot;b&quot;] + np.arange(1000) dataframe.plot.hexbin(x=&quot;a&quot;, y=&quot;b&quot;, gridsize=25) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x7fc561cdded0&gt; .",
            "url": "https://deepmaxfn.github.io/DeepMaxFN-blog/deepmaxfn/python/pandas/2021/06/15/Manejo-de-datos-con-Pandas.html",
            "relUrl": "/deepmaxfn/python/pandas/2021/06/15/Manejo-de-datos-con-Pandas.html",
            "date": " • Jun 15, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "Cálculo matricial con Numpy",
            "content": "1. Resumen . Vamos a ver una pequeña introducción a la librería de cálculo matricial Numpy. Esta librería está diseñada para todo tipo de cálculo matricial, por lo que nos vamos a quedar solo con la parte que nos será util para entender los cálculos dentro de las redes neuronales, pero nos dejaremos fuera cosas interesantes como el uso de la librería para el álgebra lineal . . 2. &#191;Qu&#233; es Numpy? . Numpy es una librería de Python diseñada para realizar cálculo matricial. El cálculo matricial es algo que se utiliza mucho en ciencia en general y en data science en particular, por lo que es necesario tener una librería que haga esto muy bien. . Su nombre quiere decir numerical python . Su objeto principal es el ndarray, que encapsula matrices de dimensión n de tipos de datos homogéneos, a diferencia de las listas de Python que pueden tener datos de distintos tipos. . Numpy tiene el objetivo de realizar el cálculo matricial mucho más rápido que con las listas de Python, pero ¿cómo es esto posible? . Numpy utiliza código compilado, mientras que Python utiliza código interpretado. La diferencia es que Python en el momento de ejecución tiene que interpretar, compilar y ejecutar el código, mientras que en Numpy ya está compilado, por lo que se ejecuta más rápido | Los ndarrays tienen un tamaño fijo, a diferencia de las listas de Python que son dinámicas. Si en Numpy se quiere modificar el tamaño de una matriz se creará una nueva y se eliminará la antigua | Todos los elementos de los ndarrays son del mismo tipo de dato, a diferencia de las listas de Python que pueden tener elementos de distinto tipo | Parte del código de Numpy está escrito en C/C++ (mucho más rápido que Python) | Los datos de las matrices se almacenan en memoria de manera continua, al contrario que las listas de Python, lo que hace que sea mucho más rápido manipularlos | . Numpy ofrece la facilidad de usar código sencillo de escribir y de leer, pero que está escrito y precompilado en C, lo que lo hace mucho más rápido. . Supongamos que queremos multiplicar dos vectores, esto se haría en C de la siguiente manera . for (i = 0; i &lt; rows; i++): { for (j = 0; j &lt; columns; j++): { c[i][j] = a[i][j]*b[i][j]; } } . Numpy ofrece la posibilidad de ejecutar este código por debajo, pero mucho más fácil de escribir y de entender mediante . c = a * b . Numpy ofrece código vectorizado, que supone no tener que escribir bucles, pero que sin embargo si están siendo ejecutados por debajo en código C optimizado y precompilado. Esto tiene las siguientes ventajas: . El código es más fácil de escribir y de leer | Al necesitarse menos líneas de código hay menos probabilidad de introducir errores | El código se parece más a la notación matemática | . 2.1. Numpy como np . Generalmente a la hora de importar Numpy se suele importar con el alias de np . import numpy as np print(np.__version__) . 1.19.5 . 3. Velociad de Numpy . Como se ha explicado Numpy realiza el cálculo mucho más rápido que las listas de Python, veamos un ejemplo en el que se realiza el producto escalar de dos matrices, mediante listas de Python y mediante ndarrays . from time import time # Dimensión de las matrices dim = 1000 shape = (dim, dim) # Se crean dos ndarrays de Numpy de dimensión dim x dim ndarray_a = np.ones(shape=shape) ndarray_b = np.ones(shape=shape) # Se crean dos listas de Python de dimensión dim x dim a partir de los ndarrays list_a = list(ndarray_a) list_b = list(ndarray_b) # Se crean el ndarray y la lista de Python donde se guardarán los resultados ndarray_c = np.empty(shape=shape) list_c = list(ndarray_c) # Producto escalar de dos listas de python t0 = time() for fila in range(dim): for columna in range(dim): list_c[fila][columna] = list_a[fila][columna] * list_b[fila][columna] t = time() t_listas = t-t0 print(f&quot;Tiempo para realizar el producto escalar de dos listas de Python de dimensiones {dim}x{dim}: {t_listas:.4f} ms&quot;) # Producto escalar de dos ndarrays de Numpy t0 = time() ndarray_c = ndarray_a * ndarray_b t = time() t_ndarrays = t-t0 print(f&quot;Tiempo para realizar el producto escalar de dos ndarrays de Numpy de dimensiones {dim}x{dim}: {t_ndarrays:.4f} ms&quot;) # Comparación de tiempos print(f&quot; nHacer el cálculo con listas de Python tarda {t_listas/t_ndarrays:.2f} veces más que con ndarrays de Numpy&quot;) . Tiempo para realizar el producto escalar de dos listas de Python de dimensiones 1000x1000: 0.7129 ms Tiempo para realizar el producto escalar de dos ndarrays de Numpy de dimensiones 1000x1000: 0.0032 ms Hacer el cálculo con listas de Python tarda 225.03 veces más que con ndarrays de Numpy . 4. Matrices en Numpy . En Numpy una matriz es un objeto ndarray . arr = np.array([1, 2, 3, 4, 5]) print(arr) print(type(arr)) . [1 2 3 4 5] &lt;class &#39;numpy.ndarray&#39;&gt; . 4.1. Como crear matrices . Con el método array() se pueden crear ndarrays introduciendo listas de Python (como el ejemplo anterior), o tuplas . arr = np.array((1, 2, 3, 4, 5)) print(arr) print(type(arr)) . [1 2 3 4 5] &lt;class &#39;numpy.ndarray&#39;&gt; . Con el método zeros() se pueden crear matrices llenas de ceros . arr = np.zeros((3, 4)) print(arr) . El método zeros_like(A) devuelve una matriz con la misma forma que la matriz A, pero llena de ceros . A = np.array((1, 2, 3, 4, 5)) arr = np.zeros_like(A) print(arr) . [0 0 0 0 0] . Con el método ones() se pueden crear matrices llenas de unos . arr = np.ones((4, 3)) print(arr) . [[1. 1. 1.] [1. 1. 1.] [1. 1. 1.] [1. 1. 1.]] . El método ones_like(A) devuelve una matriz con la misma forma que la matriz A, pero llena de ceros . A = np.array((1, 2, 3, 4, 5)) arr = np.ones_like(A) print(arr) . [1 1 1 1 1] . Con el método empty() se pueden crear matrices con las dimensiones que deseemos, pero inicializadas aleatoriamente . arr = np.empty((6, 3)) print(arr) . [[4.66169180e-310 2.35541533e-312 2.41907520e-312] [2.14321575e-312 2.46151512e-312 2.31297541e-312] [2.35541533e-312 2.05833592e-312 2.22809558e-312] [2.56761491e-312 2.48273508e-312 2.05833592e-312] [2.05833592e-312 2.29175545e-312 2.07955588e-312] [2.14321575e-312 0.00000000e+000 0.00000000e+000]] . El método empty_like(A) devuelve una matriz con la misma forma que la matriz A, pero inicializada aleatoriamente . A = np.array((1, 2, 3, 4, 5)) arr = np.empty_like(A) print(arr) . [4607182418800017408 4611686018427387904 4613937818241073152 4616189618054758400 4617315517961601024] . Con el método arange(start, stop, step) se pueden crear matrices en un rango determinado. Este método es similar al método range() de Python. . arr = np.arange(10, 30, 5) print(arr) . [10 15 20 25] . Cuando arange se usa con argumentos de coma flotante, generalmente no es posible predecir el número de elementos obtenidos, debido a que la precisión de la coma flotante es finita. . Por este motivo, suele ser mejor utilizar la función linspace(start, stop, n) que recibe como argumento la cantidad de elementos que queremos, en lugar del paso . arr = np.linspace(0, 2, 9) print(arr) . [0. 0.25 0.5 0.75 1. 1.25 1.5 1.75 2. ] . 4.2. Dimensiones de las matrices . En Numpy podemos crear matrices de cualquier dimensión. Para obtener la dimensión de un array utilizamos el método ndim . Matriz de dimensión 0, lo que equivaldría a un número . arr = np.array(42) print(arr) print(arr.ndim) . 42 0 . Matriz de dimensión 1, lo que equivaldría a un vector . arr = np.array([1, 2, 3, 4, 5]) print(arr) print(arr.ndim) . [1 2 3 4 5] 1 . Matriz de dimensión 2, lo que equivaldría a una matriz . arr = np.array([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]]) print(arr) print(arr.ndim) . [[ 1 2 3 4 5] [ 6 7 8 9 10]] 2 . Matriz de dimensión 3 . arr = np.array([ [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]], [[11, 12, 13, 14, 15], [16, 17, 18, 19, 20]] ]) print(arr) print(arr.ndim) . [[[ 1 2 3 4 5] [ 6 7 8 9 10]] [[11 12 13 14 15] [16 17 18 19 20]]] 3 . Matriz de dimensión N. A la hora de crear ndarrays se puede establecer el número de dimensiones mediante el parámetro ndim . arr = np.array([1, 2, 3, 4, 5], ndmin=6) print(arr) print(arr.ndim) . [[[[[[1 2 3 4 5]]]]]] 6 . 5. Tipo de datos . Los datos que pueden almacenar las matrices de Numpy son los siguientes: . i - Entero | b - Booleano | u - Entero sin signo | f - Flotante | c - Flotante complejo | m - Timedelta | M - Datetime | O - Objeto | S - String | U - Unicode string | V - Fragmento de memoria fijo para otro tipo (void) | . Podemos comprobar el tipo de datos que tiene una matriz mediante dtype . arr = np.array([1, 2, 3, 4]) print(arr.dtype) arr = np.array([&#39;apple&#39;, &#39;banana&#39;, &#39;cherry&#39;]) print(arr.dtype) . int64 &lt;U6 . También podemos crear matrices indicando el tipo de dato que queremos que tenga mediante dtype . arr = np.array([1, 2, 3, 4], dtype=&#39;i&#39;) print(&quot;Enteros:&quot;) print(arr) print(arr.dtype) arr = np.array([1, 2, 3, 4], dtype=&#39;f&#39;) print(&quot; nFloat:&quot;) print(arr) print(arr.dtype) arr = np.array([1, 2, 3, 4], dtype=&#39;f&#39;) print(&quot; nComplejos:&quot;) print(arr) print(arr.dtype) arr = np.array([1, 2, 3, 4], dtype=&#39;S&#39;) print(&quot; nString:&quot;) print(arr) print(arr.dtype) arr = np.array([1, 2, 3, 4], dtype=&#39;U&#39;) print(&quot; nUnicode string:&quot;) print(arr) print(arr.dtype) arr = np.array([1, 2, 3, 4], dtype=&#39;O&#39;) print(&quot; nObjeto:&quot;) print(arr) print(arr.dtype) . Enteros: [1 2 3 4] int32 Float: [1. 2. 3. 4.] float32 Complejos: [1. 2. 3. 4.] float32 String: [b&#39;1&#39; b&#39;2&#39; b&#39;3&#39; b&#39;4&#39;] |S1 Unicode string: [&#39;1&#39; &#39;2&#39; &#39;3&#39; &#39;4&#39;] &lt;U1 Objeto: [1 2 3 4] object . 6. Operaciones matem&#225;ticas . 6.1. Operaciones b&#225;sicas . Las operaciones matriciales se realizan por elementos, por ejemplo, si sumamos dos matrices se sumarán los elementos de cada matriz de la misma posición, al igual que se hace en la suma matemática de dos matrices . A = np.array([1, 2, 3]) B = np.array([1, 2, 3]) print(f&quot;Matriz A: tamaño {A.shape} n{A} n&quot;) print(f&quot;Matriz B: tamaño {B.shape} n{B} n&quot;) C = A + B print(f&quot;Matriz C: tamaño {C.shape} n{C} n&quot;) D = A - B print(f&quot;Matriz D: tamaño {D.shape} n{D}&quot;) . Matriz A: tamaño (3,) [1 2 3] Matriz B: tamaño (3,) [1 2 3] Matriz C: tamaño (3,) [2 4 6] Matriz D: tamaño (3,) [0 0 0] . Sin embargo, si hacemos la multiplicación de dos matrices también se hace la multiplicación de cada elementos de las matrices (producto escalar) . A = np.array([[3, 5], [4, 1]]) B = np.array([[1, 2], [-3, 0]]) print(f&quot;Matriz A: tamaño {A.shape} n{A} n&quot;) print(f&quot;Matriz B: tamaño {B.shape} n{B} n&quot;) C = A * B print(f&quot;Matriz C: tamaño {C.shape} n{C} n&quot;) . Matriz A: tamaño (2, 2) [[3 5] [4 1]] Matriz B: tamaño (2, 2) [[ 1 2] [-3 0]] Matriz C: tamaño (2, 2) [[ 3 10] [-12 0]] . Para hacer el producto matricial que se ha enseñado en matemáticas toda la vida hay que usar el operador @ o el método dot . A = np.array([[3, 5], [4, 1], [6, -1]]) B = np.array([[1, 2, 3], [-3, 0, 4]]) print(f&quot;Matriz A: tamaño {A.shape} n{A} n&quot;) print(f&quot;Matriz B: tamaño {B.shape} n{B} n&quot;) C = A @ B print(f&quot;Matriz C: tamaño {C.shape} n{C} n&quot;) D = A.dot(B) print(f&quot;Matriz D: tamaño {D.shape} n{D}&quot;) . Matriz A: tamaño (3, 2) [[ 3 5] [ 4 1] [ 6 -1]] Matriz B: tamaño (2, 3) [[ 1 2 3] [-3 0 4]] Matriz C: tamaño (3, 3) [[-12 6 29] [ 1 8 16] [ 9 12 14]] Matriz D: tamaño (3, 3) [[-12 6 29] [ 1 8 16] [ 9 12 14]] . Si en vez de crear una matriz nueva, se quiere modificar alguna existente se pueden usar los peradores +=, -= o *= . A = np.array([[3, 5], [4, 1]]) B = np.array([[1, 2], [-3, 0]]) print(f&quot;Matriz A: tamaño {A.shape} n{A} n&quot;) print(f&quot;Matriz B: tamaño {B.shape} n{B} n&quot;) A += B print(f&quot;Matriz A tras suma: tamaño {A.shape} n{A} n&quot;) A -= B print(f&quot;Matriz A tras resta: tamaño {A.shape} n{A} n&quot;) A *= B print(f&quot;Matriz A tras multiplicación: tamaño {A.shape} n{A} n&quot;) . Matriz A: tamaño (2, 2) [[3 5] [4 1]] Matriz B: tamaño (2, 2) [[ 1 2] [-3 0]] Matriz A tras suma: tamaño (2, 2) [[4 7] [1 1]] Matriz A tras resta: tamaño (2, 2) [[3 5] [4 1]] Matriz A tras multiplicación: tamaño (2, 2) [[ 3 10] [-12 0]] . Se pueden realizar operaciones sobre todos los elementos de una matriz, esto es gracias a una propiedad llamada brodcasting que veremos después más a fondo . A = np.array([[3, 5], [4, 1]]) print(f&quot;Matriz A: tamaño {A.shape} n{A} n&quot;) B = A * 2 print(f&quot;Matriz B: tamaño {B.shape} n{B} n&quot;) C = A ** 2 print(f&quot;Matriz C: tamaño {C.shape} n{C} n&quot;) D = 2*np.sin(A) print(f&quot;Matriz D: tamaño {D.shape} n{D}&quot;) . Matriz A: tamaño (2, 2) [[3 5] [4 1]] Matriz B: tamaño (2, 2) [[ 6 10] [ 8 2]] Matriz C: tamaño (2, 2) [[ 9 25] [16 1]] Matriz D: tamaño (2, 2) [[ 0.28224002 -1.91784855] [-1.51360499 1.68294197]] . 6.2. Funciones sobre matrices . Como se puede ver en el último cálculo, Numpy ofrece operadores de funciones sobre matrices, hay un montón de funciones que se pueden realizar sobre matrices, matemáticas, lógicas, de algebra lineal, etc. A continuación mostramos algunas . A = np.array([[3, 5], [4, 1]]) print(f&quot;A n{A} n&quot;) print(f&quot;exp(A) n{np.exp(A)} n&quot;) print(f&quot;sqrt(A) n{np.sqrt(A)} n&quot;) print(f&quot;cos(A) n{np.cos(A)} n&quot;) . A [[3 5] [4 1]] exp(A) [[ 20.08553692 148.4131591 ] [ 54.59815003 2.71828183]] sqrt(A) [[1.73205081 2.23606798] [2. 1. ]] cos(A) [[-0.9899925 0.28366219] [-0.65364362 0.54030231]] . Hay algunas funciones que devuelven información de las matrices, como la media . A = np.array([[3, 5], [4, 1]]) print(f&quot;A n{A} n&quot;) print(f&quot;A.mean() n{A.mean()} n&quot;) . A [[3 5] [4 1]] A.mean() 3.25 . Sin embargo podemos obtener dicha información de cada eje mediante el atributo axis, si este es 0 se hace sobre cada columna, mientras que si es 1 se hace sobre cada fila . A = np.array([[3, 5], [4, 1]]) print(f&quot;A n{A} n&quot;) print(f&quot;A.mean() columnas n{A.mean(axis=0)} n&quot;) print(f&quot;A.mean() filas n{A.mean(axis=1)} n&quot;) . A [[3 5] [4 1]] A.mean() columnas [3.5 3. ] A.mean() filas [4. 2.5] . 6.3. Broadcasting . Se pueden realizar operaciones matriciales, con matrices de distintas dimensiones. En este caso Numpy detectará esto y hará una proyección de la menor matriz hasta igualar a la mayor . . Esta es una gran cualidad de Numpy, que hace que se puedan realizar cálculos sobre matrices sin tener que preocuparse de igualar las dimensiones de estas . A = np.array([1, 2, 3]) print(f&quot;A n{A} n&quot;) B = A + 5 print(f&quot;B n{B} n&quot;) . A [1 2 3] B [6 7 8] . A = np.array([1, 2, 3]) B = np.ones((3,3)) print(f&quot;A n{A} n&quot;) print(f&quot;B n{B} n&quot;) C = A + B print(f&quot;C n{C} n&quot;) . A [1 2 3] B [[1. 1. 1.] [1. 1. 1.] [1. 1. 1.]] C [[2. 3. 4.] [2. 3. 4.] [2. 3. 4.]] . A = np.array([1, 2, 3]) B = np.array([[1], [2], [3]]) print(f&quot;A n{A} n&quot;) print(f&quot;B n{B} n&quot;) C = A + B print(f&quot;C n{C} n&quot;) . A [1 2 3] B [[1] [2] [3]] C [[2 3 4] [3 4 5] [4 5 6]] . 7. Indexado de matrices . El indexado de matrices se hace igual que con las listas de Python . arr = np.array([1, 2, 3, 4, 5]) arr[3] . 4 . En el caso de tener más de una dimensión se ha de indicar el índice en cada una de ellas . arr = np.array([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]]) arr[1, 2] . 8 . Se puede usar la indexación negativa . arr[-1, -2] . 9 . En caso de no indicar uno de los ejes, se considera que se quiere entero . arr = np.array([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]]) arr[1] . array([ 6, 7, 8, 9, 10]) . 7.1. Porciones de matrices . A la hora de indexar podemos quedarnos con partes de matrices al igual que se hacía con las listas de Python. . Recordar que se hacía de la siguiente manera: . start:stop:step . Donde el rango va desde el start (incluido) hasta el stop (sin incluir) con un paso de step . Si step no se indica por defecto es 1 . Por ejemplo, si queremos items de la segunda fila y de la segunda a la cuarta columna: . Seleccionamos la segunda fila con un 1 (ya que se empieza a contar desde 0) | Seleccionamos de la segunda a la cuarta fila mediante 1:4, el 1 para indicar la segunda columna y el 4 para indicar la quinta (ya que el segundo número indica la columna en la que se termina sin incluir esta columna). Los dos números teniendo en cuenta que se empieza a contar desde 0 | . print(arr) print(arr[1, 1:4]) . [[ 1 2 3 4 5] [ 6 7 8 9 10]] [7 8 9] . Podemos coger desde una posición hasta el final . arr[1, 2:] . array([ 8, 9, 10]) . Desde el inicio hasta una posición . arr[1, :3] . array([6, 7, 8]) . Establecer el rango con números negativos . arr[1, -3:-1] . array([8, 9]) . Elegir el paso . arr[1, 1:4:2] . array([7, 9]) . 7.2. Iteracci&#243;n sobre matrices . La iteración sobre matrices multidimensionales se realiza con respecto al primer eje . M = np.array( [[[ 0, 1, 2], [ 10, 12, 13]], [[100,101,102], [110,112,113]]]) print(f&#39;Matriz de dimensión: {M.shape} n&#39;) i = 0 for fila in M: print(f&#39;Fila {i}: {fila}&#39;) i += 1 . Matriz de dimensión: (2, 2, 3) Fila 0: [[ 0 1 2] [10 12 13]] Fila 1: [[100 101 102] [110 112 113]] . Sin embargo, si lo que queremos en iterar por cada item podemos usar el método &#39;flat&#39; . i = 0 for fila in M.flat: print(f&#39;Elemento {i}: {fila}&#39;) i += 1 . Elemento 0: 0 Elemento 1: 1 Elemento 2: 2 Elemento 3: 10 Elemento 4: 12 Elemento 5: 13 Elemento 6: 100 Elemento 7: 101 Elemento 8: 102 Elemento 9: 110 Elemento 10: 112 Elemento 11: 113 . 8. Copia de matrices . En Numpy tenemos dos maneras de copiar matrices, mediante copy, que realiza una copia nueva de la matriz, y mediante view que realiza una vista de la matriz original . La copia es propietaria de los datos y cualquier cambio realizado en la copia no afectará la matriz original, y cualquier cambio realizado en la matriz original no afectará la copia. . La vista no es propietaria de los datos y cualquier cambio realizado en la vista afectará a la matriz original, y cualquier cambio realizado en la matriz original afectará la vista. . 8.1. Copy . arr = np.array([1, 2, 3, 4, 5]) copy_arr = arr.copy() arr[0] = 42 copy_arr[1] = 43 print(f&#39;Original: {arr}&#39;) print(f&#39;Copia: {copy_arr}&#39;) . Original: [42 2 3 4 5] Copia: [ 1 43 3 4 5] . 8.2. View . arr = np.array([1, 2, 3, 4, 5]) view_arr = arr.view() arr[0] = 42 view_arr[1] = 43 print(f&#39;Original: {arr}&#39;) print(f&#39;Vista: {view_arr}&#39;) . Original: [42 43 3 4 5] Vista: [42 43 3 4 5] . 8.3. Propietario de los datos . Ante la duda de si tenemos una copia o una vista podemos usar base . arr = np.array([1, 2, 3, 4, 5]) copy_arr = arr.copy() view_arr = arr.view() print(copy_arr.base) print(view_arr.base) . None [1 2 3 4 5] . 9. Forma de las matrices . Podemos saber la forma que tiene la matriz mediante el método shape. Este nos devolverá una tupla, el tamaño de la tupla representa las dimensiones de la matriz, en cada elemento de la tupla se indica el número de items en cada una de las dimensiones de la matriz . arr = np.array([ [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]], [[11, 12, 13, 14, 15], [16, 17, 18, 19, 20]] ]) print(arr) print(arr.shape) . [[[ 1 2 3 4 5] [ 6 7 8 9 10]] [[11 12 13 14 15] [16 17 18 19 20]]] (2, 2, 5) . 9.1. Reshape . Podemos cambiar la forma de las matrices a la que queramos mediante el método reshape. . Por ejemplo, la matriz antrerior, que tiene una forma de (2, 2, 4). Podemos pasarla a (5, 4) . arr_reshape = arr.reshape(5, 4) print(arr_reshape) print(arr_reshape.shape) . [[ 1 2 3 4] [ 5 6 7 8] [ 9 10 11 12] [13 14 15 16] [17 18 19 20]] (5, 4) . Hay que tener en cuenta que para redimensionar las matrices el número de items de la nueva forma tiene que tener el mismo número de items de la primera forma . Es decir, en el ejemplo anterior, la primera matriz tenía 20 items (2x2x4), y la nueva matriz tiene 20 items (5x4). Lo que no podemos es redimensionarla a una matriz de tamaño (3, 4), ya que en total habría 12 items . arr_reshape = arr.reshape(3, 4) . ValueError Traceback (most recent call last) &lt;ipython-input-12-29e85875d1df&gt; in &lt;module&gt;() -&gt; 1 arr_reshape = arr.reshape(3, 4) ValueError: cannot reshape array of size 20 into shape (3,4) . 9.2. Dimensi&#243;n desconocida . En el caso que queramos cambiar la forma de una matriz y una de las dimensiones nos de igual, o no la conozcamos, podemos hacer que Numpy la calcule por nosotros introduciendo un -1 como parámetro . arr = np.array([ [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]], [[11, 12, 13, 14, 15], [16, 17, 18, 19, 20]] ]) arr_reshape = arr.reshape(2, -1) print(arr_reshape) print(arr_reshape.shape) . [[ 1 2 3 4 5 6 7 8 9 10] [11 12 13 14 15 16 17 18 19 20]] (2, 10) . Hay que tener en cuenta que no se puede poner cualquier número en las dimensiones conocidas. El número de items de la matriz original tiene que ser un múltipo de las dimensiones conocidas. . En el ejemplo anterior, la matriz tiene 20 items, que es múltiplo de 2, dimensión conocida introducida. No se hubiera podido poner un 3 como dimensión conocida, ya que 20 no es múltiplo de 3, y no habría ningún número que se pueda poner en la dimensión desconocida que haga que en total haya 20 items. . 9.3. Aplanamiento de matrices . Podemos aplanar las matrices, es decir, pasarlas a una sola dimensión mediante reshape(-1). De esta manera, tenga las dimensiones que sea la matriz original, la nueva siempre tendrá una sola dimensión . arr = np.array([ [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]], [[11, 12, 13, 14, 15], [16, 17, 18, 19, 20]] ]) arr_flatten = arr.reshape(-1) print(arr_flatten) print(arr_flatten.shape) . [ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20] (20,) . Otra forma de aplanar una matriz es mediante el método ravel() . arr = np.array([ [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]], [[11, 12, 13, 14, 15], [16, 17, 18, 19, 20]] ]) arr_flatten = arr.ravel() print(arr_flatten) print(arr_flatten.shape) . [ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20] (20,) . 9.4. Matriz transpuesta . Se puede obtener la traspuesta de una matriz mediante el método T. Hacer la traspuesta de una matriz es intercambiar las filas y las columnas de la matriz, en la siguiente imagen se ve un ejemplo que lo aclara más . . arr = np.array([[1, 0, 4], [0, 5, 0], [6, 0, -9]]) arr_t = arr.T print(arr_t) print(arr_t.shape) . [[ 1 0 6] [ 0 5 0] [ 4 0 -9]] (3, 3) . 10. Apilado de matrices . 10.1. Apilamiento vertical . Se pueden apilar matricecs verticalmente (uniendo filas) mediante el método vstack() . a = np.array([[1, 1, 1], [2, 2, 2], [3, 3, 3]]) b = np.array([[4, 4, 4], [5, 5, 5], [6, 6, 6]]) c = np.vstack((a,b)) c . array([[1, 1, 1], [2, 2, 2], [3, 3, 3], [4, 4, 4], [5, 5, 5], [6, 6, 6]]) . Si se tienen matrices de más de 2 dimensiones vsatck() apilará a lo largo de la primera dimensión . a = np.array([ [[1, 1], [2, 2]], [[3, 3], [4, 4]] ]) b = np.array([ [[5, 5], [6, 6]], [[7, 7], [8, 8]] ]) c = np.vstack((a,b)) c . array([[[1, 1], [2, 2]], [[3, 3], [4, 4]], [[5, 5], [6, 6]], [[7, 7], [8, 8]]]) . 10.2. Apilamiento horizontal . Se pueden apilar matrices horizontalmente (uniendo columnas) mediante el método hstack() . a = np.array([[1, 2, 3], [1, 2, 3], [1, 2, 3]]) b = np.array([[4, 5, 6], [4, 5, 6], [4, 5, 6]]) c = np.hstack((a,b)) c . array([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]]) . Si se tienen matrices de más de 2 dimensiones hsatck() apilará a lo largo de la segunda dimensión . a = np.array([ [[1, 1], [2, 2]], [[3, 3], [4, 4]] ]) b = np.array([ [[5, 5], [6, 6]], [[7, 7], [8, 8]] ]) c = np.hstack((a,b)) c . array([[[1, 1], [2, 2], [5, 5], [6, 6]], [[3, 3], [4, 4], [7, 7], [8, 8]]]) . Otra manera de agregar columnas a una matriz es mediante el método column_stack() . a = np.array([[1, 2, 3], [1, 2, 3], [1, 2, 3]]) b = np.array([4, 4, 4]) c = np.column_stack((a,b)) c . array([[1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 3, 4]]) . 10.3. Apilamiento en profundidad . Se pueden apilar matrices en profundidad (tercera dimensión) mediante el método dstack() . a = np.array([ [[1, 1], [2, 2]], [[3, 3], [4, 4]] ]) b = np.array([ [[1, 1], [2, 2]], [[3, 3], [4, 4]] ]) c = np.dstack((a,b)) print(f&quot;c: {c} n&quot;) print(f&quot;a.shape: {a.shape}, b.shape: {b.shape}, c.shape: {c.shape}&quot;) . c: [[[1 1 1 1] [2 2 2 2]] [[3 3 3 3] [4 4 4 4]]] a.shape: (2, 2, 2), b.shape: (2, 2, 2), c.shape: (2, 2, 4) . Si se tienen matrices de más de 4 dimensiones dsatck() apilará a lo largo de la tercera dimensión . a = np.array([1, 2, 3, 4, 5], ndmin=4) b = np.array([1, 2, 3, 4, 5], ndmin=4) c = np.dstack((a,b)) print(f&quot;a.shape: {a.shape}, b.shape: {b.shape}, c.shape: {c.shape}&quot;) . a.shape: (1, 1, 1, 5), b.shape: (1, 1, 1, 5), c.shape: (1, 1, 2, 5) . 10.3. Apilamiento personalizado . Mediante el método concatenate() se puede elegir el eje en el que se quieren apilar las matrices . a = np.array([ [[1, 1], [2, 2]], [[3, 3], [4, 4]] ]) b = np.array([ [[5, 5], [6, 6]], [[7, 7], [8, 8]] ]) conc0 = np.concatenate((a,b), axis=0) # concatenamiento en el primer eje conc1 = np.concatenate((a,b), axis=1) # concatenamiento en el segundo eje conc2 = np.concatenate((a,b), axis=2) # concatenamiento en el tercer eje print(f&quot;conc0: {conc0} n&quot;) print(f&quot;conc1: {conc1} n&quot;) print(f&quot;conc2: {conc2}&quot;) . conc0: [[[1 1] [2 2]] [[3 3] [4 4]] [[5 5] [6 6]] [[7 7] [8 8]]] conc1: [[[1 1] [2 2] [5 5] [6 6]] [[3 3] [4 4] [7 7] [8 8]]] conc2: [[[1 1 5 5] [2 2 6 6]] [[3 3 7 7] [4 4 8 8]]] . 11. Dividir matrices . 11.1. Dividir verticalmente . Se pueden dividir matricecs verticalmente (separando filas) mediante el método vsplit() . a = np.array([[1.1, 1.2, 1.3, 1.4], [2.1, 2.2, 2.3, 2.4], [3.1, 3.2, 3.3, 3.4], [4.1, 4.2, 4.3, 4.4]]) [a1, a2] = np.vsplit(a, 2) print(f&quot;a1: {a1} n&quot;) print(f&quot;a2: {a2}&quot;) . a1: [[1.1 1.2 1.3 1.4] [2.1 2.2 2.3 2.4]] a2: [[3.1 3.2 3.3 3.4] [4.1 4.2 4.3 4.4]] . Si se tienen matrices de más de 2 dimensiones vsplit() dividirá a lo largo de la primera dimensión . a = np.array([ [[1, 1], [2, 2]], [[3, 3], [4, 4]] ]) [a1, a2] = np.vsplit(a, 2) print(f&quot;a1: {a1} n&quot;) print(f&quot;a2: {a2}&quot;) . a1: [[[1 1] [2 2]]] a2: [[[3 3] [4 4]]] . 11.2. Dividir horizontalmente . Se pueden dividir matrices horizontalmente (separando columnas) mediante el método hsplit() . a = np.array([[1.1, 1.2, 1.3, 1.4], [2.1, 2.2, 2.3, 2.4], [3.1, 3.2, 3.3, 3.4], [4.1, 4.2, 4.3, 4.4]]) [a1, a2] = np.hsplit(a, 2) print(f&quot;a1: {a1} n&quot;) print(f&quot;a2: {a2}&quot;) . a1: [[1.1 1.2] [2.1 2.2] [3.1 3.2] [4.1 4.2]] a2: [[1.3 1.4] [2.3 2.4] [3.3 3.4] [4.3 4.4]] . Si se tienen matrices de más de 2 dimensiones hsplit() dividirá a lo largo de la segunda dimensión . a = np.array([ [[1, 1], [2, 2]], [[3, 3], [4, 4]] ]) [a1, a2] = np.hsplit(a, 2) print(f&quot;a1: {a1} n&quot;) print(f&quot;a2: {a2}&quot;) . a1: [[[1 1]] [[3 3]]] a2: [[[2 2]] [[4 4]]] . 11.3. Dividir de manera personalizada . Mediante el método array_split() se puede elegir el eje en el que se quieren dividir las matrices . a = np.array([ [[1, 1], [2, 2]], [[3, 3], [4, 4]] ]) [a1_eje0, a2_eje0] = np.array_split(a, 2, axis=0) [a1_eje1, a2_eje1] = np.array_split(a, 2, axis=1) [a1_eje2, a2_eje2] = np.array_split(a, 2, axis=2) print(f&quot;a1_eje0: {a1_eje0} n&quot;) print(f&quot;a2_eje0: {a2_eje0} n n&quot;) print(f&quot;a1_eje1: {a1_eje1} n&quot;) print(f&quot;a2_eje1: {a2_eje1} n n&quot;) print(f&quot;a1_eje2: {a1_eje2} n&quot;) print(f&quot;a2_eje2: {a2_eje2}&quot;) . a1_eje0: [[[1 1] [2 2]]] a2_eje0: [[[3 3] [4 4]]] a1_eje1: [[[1 1]] [[3 3]]] a2_eje1: [[[2 2]] [[4 4]]] a1_eje2: [[[1] [2]] [[3] [4]]] a2_eje2: [[[1] [2]] [[3] [4]]] . 12. B&#250;squeda en matrices . Si se quiere buscar un valor dentro de una matriz se puede usar el método where() que devuelve las posiciones donde la matriz vale el valor que estamos buscando . arr = np.array([1, 2, 3, 4, 5, 4, 4]) ids = np.where(arr == 4) ids . (array([3, 5, 6]),) . Se pueden usar funciones para buscar, por ejemplo, siqueremos buscar en qué posiciones los valores son pares . arr = np.array([1, 2, 3, 4, 5, 6, 7, 8]) ids = np.where(arr%2) ids . (array([0, 2, 4, 6]),) . 13. Ordenar matrices . Mediante el método sort() podemos ordenar matrices . arr = np.array([3, 2, 0, 1]) arr_ordenado = np.sort(arr) arr_ordenado . array([0, 1, 2, 3]) . Si lo que tenemos son strings, los ordena alfabéticamente . arr = np.array([&#39;banana&#39;, &#39;apple&#39;, &#39;cherry&#39;]) arr_ordenado = np.sort(arr) arr_ordenado . array([&#39;apple&#39;, &#39;banana&#39;, &#39;cherry&#39;], dtype=&#39;&lt;U6&#39;) . Y las matrices de boooleanos también las ordena . arr = np.array([True, False, True]) arr_ordenado = np.sort(arr) arr_ordenado . array([False, True, True]) . Si se tienen matrices de más de una dimensión las ordena por dimensiones, es decir, si se tiene una matriz de 2 dimensiones ordena los números de la primera fila entre ellos y los de la segunda fila entre ellos . arr = np.array([[3, 2, 4], [5, 0, 1]]) arr_ordenado = np.sort(arr) arr_ordenado . array([[2, 3, 4], [0, 1, 5]]) . Por defecto ordena siempre con respecto a las filas, pero si se quiere que ordene con respecto a otra dimensión, se tiene que especificar mediante la variable axis . arr = np.array([[3, 2, 4], [5, 0, 1]]) arr_ordenado0 = np.sort(arr, axis=0) # Se ordena con respecto a la primera dimensión arr_ordenado1 = np.sort(arr, axis=1) # Se ordena con respecto a la segunda dimensión print(f&quot;arr_ordenado0: {arr_ordenado0} n&quot;) print(f&quot;arr_ordenado1: {arr_ordenado1} n&quot;) . arr_ordenado0: [[3 0 1] [5 2 4]] arr_ordenado1: [[2 3 4] [0 1 5]] . 14. Filtros en matrices . Numpy ofrece la posiibilidad de buscar ciertos elementos de una matriz y crear una nueva . Esto lo hace creando una matriz de índices booleanos, es decir, crea una nueva matriz que indica con cuales posiciones nos quedamos de la matriz y con cuales no . Veamos una ejemplo de una matriz de índices booleanos . arr = np.array([37, 85, 12, 45, 69, 22]) indices_booleanos = [False, False, True, False, False, True] arr_filter = arr[indices_booleanos] print(f&quot;Array original: {arr}&quot;) print(f&quot;indices booleanos: {indices_booleanos}&quot;) print(f&quot;Array filtrado: {arr_filter}&quot;) . Array original: [37 85 12 45 69 22] indices booleanos: [False, False, True, False, False, True] Array filtrado: [12 22] . Como se puede ver, el array filtrado (arr_filetr), solo se ha quedado del array original (arr) con los elementos que coinciden con aquellos en los que el array indices_booleanos vale True . Otra cosa que podemos ver es que solo se ha quedado con los elementos pares, por lo que ahora pasaremos a ver cómo se hace para quedarse con los ellementos pares de una matriz, sin tener que hacerlo a mano como lo hemos hecho en el ejemplo anterior . arr = np.array([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]]) indices_booleanos = arr % 2 == 0 arr_filter = arr[indices_booleanos] print(f&quot;Array original: {arr} n&quot;) print(f&quot;indices booleanos: {indices_booleanos} n&quot;) print(f&quot;Array filtrado: {arr_filter}&quot;) . Array original: [[ 1 2 3 4 5] [ 6 7 8 9 10]] indices booleanos: [[False True False True False] [ True False True False True]] Array filtrado: [ 2 4 6 8 10] .",
            "url": "https://deepmaxfn.github.io/DeepMaxFN-blog/deepmaxfn/python/numpy/2021/04/23/Calculo-matricial-con-Numpy.html",
            "relUrl": "/deepmaxfn/python/numpy/2021/04/23/Calculo-matricial-con-Numpy.html",
            "date": " • Apr 23, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "Introducción a Python",
            "content": "1. Resumen . Vamos a hacer una breve introducción a Python, explicando los tipos de datos que tenemos, los operadores, el uso de funciones y de clases. Además veremos cómo usar los objetos iterables, cómo usar módulos, etc. . . 2. Tipos de datos de Python . Existen 7 tipos de datos en Python . De tipo texto:str | Numéricos:int, float, complex | Secuencias: list, tuple, range | Mapping: dict | Sets: set, frozenset | Booleanos: bool | Binarios: bytes, bytearray, memoryview | Podemos obtener el tipo de dato mediante la función type() . type(5.) . float . Python es un lenguaje de tipado dinámico, es decir puedes tener una variable de un tipo y luego asignarle otro tipo . a = 5 type(a) . int . a = &#39;DeepMaxFn&#39; type(a) . str . Python tipa las variables por ti, pero si las quieres tipar tu se puede hacer . b = int(5.1) type(b), b . (int, 5) . Aunque b se ha inicializado como 5.1, es decir, debería ser de tipo float, al tiparlo nosotros a tipo int, vemos que es de tipo int y además su valor es 5 . 2.1. Strings . Los strings son cadenas de caracteres, estos se pueden definir con doble comilla &quot; o comilla simple &#39; . string = &quot;DeepMaxFn&quot; string . &#39;DeepMaxFn&#39; . string = &#39;DeepMaxFn&#39; string . &#39;DeepMaxFn&#39; . Para escribir un string muy largo y no tener una fila que ocupe mucho espacio se puede introducir en varias lineas . string = &quot;&quot;&quot;Este es un ejemplo de como estoy introduciendo un string en varias lineas&quot;&quot;&quot; string . &#39;Este es un ejemplo de ncomo estoy introduciendo un string nen varias lineas&#39; . string = &#39;&#39;&#39;Este es un ejemplo de como estoy introduciendo un string en varias lineas&#39;&#39;&#39; string . &#39;Este es un ejemplo de ncomo estoy introduciendo un string nen varias lineas&#39; . Sin embargo vemos que en medio ha metido el caracter n, este caracter indica el salto de linea. Si usamos la función print() veremos como ya no aparece . print(string) . Este es un ejemplo de como estoy introduciendo un string en varias lineas . Como hemos dicho los strings son cadenas de caracteres, por lo que podemos navegar e iterar a traves de ellos . for i in range(10): # Se indica a la función print que cuando imprima no termine con un salto de # linea para escribir todo en la misma linea print(string[i], end=&#39;&#39;) . Este es un . Podemos obtener la longitud de nuestro string mediante la función len() . len(string) . 73 . Checkear si hay ulgun string determinado dentro del nuestro . &#39;ejemplo&#39; in string . True . Los strings tienen ciertos atributos útiles, como poner todo en mayusculas . print(string.upper()) . ESTE ES UN EJEMPLO DE COMO ESTOY INTRODUCIENDO UN STRING EN VARIAS LINEAS . Todo en minúsculas . print(string.lower()) . este es un ejemplo de como estoy introduciendo un string en varias lineas . Reemplazar caracteres . print(string.replace(&#39;o&#39;, &#39;@&#39;)) . Este es un ejempl@ de c@m@ est@y intr@duciend@ un string en varias lineas . Obtener todas las palabras . print(string.split()) . [&#39;Este&#39;, &#39;es&#39;, &#39;un&#39;, &#39;ejemplo&#39;, &#39;de&#39;, &#39;como&#39;, &#39;estoy&#39;, &#39;introduciendo&#39;, &#39;un&#39;, &#39;string&#39;, &#39;en&#39;, &#39;varias&#39;, &#39;lineas&#39;] . Puedes ver todos los métodos de los strings en este enlace . Otra cosa util que se puede hacer con los strings es concatenarlos . string1 = &#39;DeepMax&#39; string2 = &#39;Fn&#39; string1 + string2 . &#39;DeepMaxFn&#39; . Antes explicamos que el caracter n correspondía a una salto de linea, este caracter especial corresponde a una serie de caracteres especiales llamados Escape Characters. Veamos otros . Si declaramos un string con doble comilla y queremos añadir una doble comilla dentro del string usamos el escape character &quot; . print(&quot;Este es el blog de &quot;DeepMaxFn &quot;&quot;) . Este es el blog de &#34;DeepMaxFn&#34; . Lo mismo con la comilla simple, añadimos &#39; . print(&#39;Este es el blog de &#39;DeepMaxFn &#39;&#39;) . Este es el blog de &#39;DeepMaxFn&#39; . Ahora tenemos el problema de si queremos añadir el caracter ya que como hemos visto es un escape character, así que lo solucionamos poniendo doble barra (backslash) . print(&#39;Este es el blog de DeepMaxFn &#39;) . Este es el blog de DeepMaxFn . Ya vimos antes el escape character de nueva linea n . print(&#39;Este es el blog de nDeepMaxFn&#39;) . Este es el blog de DeepMaxFn . Si queremos escribir desde el inicio de linea añadimos r . print(&#39;Esto no se imprimirá rEste es el blog de DeepMaxFn&#39;) . Este es el blog de DeepMaxFn . Si queremos añadir añadir un espacio grande (sangría) usamos t . print(&#39;Este es el blog de tDeepMaxFn&#39;) . Este es el blog de DeepMaxFn . Podemos borrar un caracter con b . print(&#39;Este es el blog de bDeepMaxFn&#39;) . Este es el blog de DeepMaxFn . Podemos añadir el codigo ASCII en octal mediante ooo . print(&#39; 104 145 145 160 115 141 170 106 156&#39;) . DeepMaxFn . O añadir el codigo ASCII en hexadecimal mediante xhh . print(&#39; x44 x65 x65 x70 x4d x61 x78 x46 x6e&#39;) . DeepMaxFn . Por último, podemos convertir otro tipo de dato a string . n = 5 print(type (n)) string = str(n) print(type(string)) . &lt;class &#39;int&#39;&gt; &lt;class &#39;str&#39;&gt; . 2.2. N&#250;meros . 2.2.1. Enteros . Numeros de tipo entero . n = 5 n, type(n) . (5, int) . 2.2.2. Float . Números de tipo de coma flotante . n = 5.1 n, type(n) . (5.1, float) . 2.2.3. Complejos . Números complejos . n = 3 + 5j n, type(n) . ((3+5j), complex) . 2.2.4. Conversi&#243;n . Se puede convertir entre tipos de números . n = 5 n = float(n) n, type(n) . (5.0, float) . n = 5.1 n = complex(n) n, type(n) . ((5.1+0j), complex) . n = 5.1 n = int(n) n, type(n) . (5, int) . No se puede convertir un numero complex a tipo int o tipo float . 2.3. Secuencias . 2.3.1. Listas . Las listas guardan múltiples items en una variable. Se declaran mediante los símbolos [], con los items separados por comas . lista = [&#39;item0&#39;, &#39;item1&#39;, &#39;item2&#39;, &#39;item3&#39;, &#39;item4&#39;, &#39;item5&#39;] lista . [&#39;item0&#39;, &#39;item1&#39;, &#39;item2&#39;, &#39;item3&#39;, &#39;item4&#39;, &#39;item5&#39;] . Podemos obtener la longitud de una lista mediante la función len() . len(lista) . 6 . Las listas pueden tener items de distintos tipos . lista = [&#39;item0&#39;, 1, True, 5.3, &quot;item4&quot;, 5, 6.6] lista . [&#39;item0&#39;, 1, True, 5.3, &#39;item4&#39;, 5, 6.6] . En Python se empieza a contar desde la posición 0, es decir, si queremos obtener la primera posición de la lista . lista[0] . &#39;item0&#39; . Pero una de las cosas potentes de Python es que si queremos acceder a la última posición podemos usar índices negativos . lista[-1] . 6.6 . Si en vez de la última posición de la lista queremos la penúltima . lista[-2] . 5 . Si solo queremos un rango de valores, por ejemplo, del segundo al quinto item accedemos mediante [2:5] . lista[2:5] . [True, 5.3, &#39;item4&#39;] . Si se omite el primer número del rango singnifica que queremos desde el primer item de la lista hasta el item indicado, es decir, si queremos desde el primer item hasta el quinto usamos [:5] . lista[:5] . [&#39;item0&#39;, 1, True, 5.3, &#39;item4&#39;] . Si se omite el último número del rango significa que queremos desde el item indicado hasta el último, es decir, si queremos desde el tercer item hasta el último usamos [3:] . lista[3:] . [5.3, &#39;item4&#39;, 5, 6.6] . Podemos escoger el rango de items también con números negativos, es decir, si queremos desde el antepenúltimo hasta el penúltimo usamos [-3:-1]. Esto es útil cuando se tiene listas que no se sabe su longitud, pero se sabe que se quiere un rango de valores del final, porque por ejemplo, la lista se ha creado con medidas que se van tomando y se quiere saber las últimas medias . lista[-3:-1] . [&#39;item4&#39;, 5] . Se puede comprobar si un item está en la lista . &#39;item4&#39; in lista . True . 2.3.1.1. Editar listas . Las listas en Python son dinámicas, es decir, se pueden modificar. Por ejemplo se puede modificar el tercer item . lista[2] = False lista . [&#39;item0&#39;, 1, False, 5.3, &#39;item4&#39;, 5, 6.6] . También se puede modificat un rango de valores . lista[1:4] = [1.1, True, 3] lista . [&#39;item0&#39;, 1.1, True, 3, &#39;item4&#39;, 5, 6.6] . Se pueden añadir valores al final de la lista mediante el método append() . lista.append(&#39;item7&#39;) lista . [&#39;item0&#39;, 1.1, True, 3, &#39;item4&#39;, 5, 6.6, &#39;item7&#39;] . O podemos insertar un valor en una posición determinada mediante el método insert() . lista.insert(2, &#39;insert&#39;) lista . [&#39;item0&#39;, 1.1, &#39;insert&#39;, True, 3, &#39;item4&#39;, 5, 6.6, &#39;item7&#39;] . Se pueden unir listas mediante el método extend() . lista2 = [&#39;item8&#39;, &#39;item9&#39;] lista.extend(lista2) lista . [&#39;item0&#39;, 1.1, &#39;insert&#39;, True, 3, &#39;item4&#39;, 5, 6.6, &#39;item7&#39;, &#39;item8&#39;, &#39;item9&#39;] . No es necesario extender la lista mediante otra lista, se puede hacer mediante otro tipo de dato iterable de Python (tuplas, sets, diccionarios, etc) . tupla = (&#39;item10&#39;, &#39;item11&#39;) lista.extend(tupla) lista . [&#39;item0&#39;, 1.1, &#39;insert&#39;, True, 3, &#39;item4&#39;, 5, 6.6, &#39;item7&#39;, &#39;item8&#39;, &#39;item9&#39;, &#39;item10&#39;, &#39;item11&#39;] . Podemos eliminar una posición determinada mediante el método pop() . lista.pop(2) lista . [&#39;item0&#39;, 1.1, True, 3, &#39;item4&#39;, 5, 6.6, &#39;item7&#39;, &#39;item8&#39;, &#39;item9&#39;, &#39;item10&#39;, &#39;item11&#39;] . Si no se especifica el indice se elimina el último item . lista.pop() lista . [&#39;item0&#39;, 1.1, True, 3, &#39;item4&#39;, 5, 6.6, &#39;item7&#39;, &#39;item8&#39;, &#39;item9&#39;, &#39;item10&#39;] . O se puede eliminar un item sabiendo su valor mediante el método remove() . lista.remove(&#39;item7&#39;) lista . [&#39;item0&#39;, 1.1, True, 3, &#39;item4&#39;, 5, 6.6, &#39;item8&#39;, &#39;item9&#39;, &#39;item10&#39;] . Con la función del() se puede eliminar también un item de la posición indicada . del lista[3] lista . [&#39;item0&#39;, 1.1, True, &#39;item4&#39;, 5, 6.6, &#39;item8&#39;, &#39;item9&#39;, &#39;item10&#39;] . Si no se indica el índice se elimina la lista entera . Con el método clear() deja la lista vacía . lista.clear() lista . [] . Se puede obtener la cantidad de items con un valor determinado mediante el método count() . lista = [5, 4, 6, 5, 7, 8, 5, 3, 1, 5] lista.count(5) . 4 . También se puede obtener el primer índice de un item con un valor determinado mediante el método index() . lista = [5, 4, 6, 5, 7, 8, 5, 3, 1, 5] lista.index(5) . 0 . 2.3.1.2. List comprehension . Podemos operar a través de la lista . fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;, &quot;kiwi&quot;, &quot;mango&quot;] newlist = [] # Iteramos por todos los items de la lista for x in fruits: # Si el item contiene el caracter &quot;a&quot; lo añadimos a newlist if &quot;a&quot; in x: newlist.append(x) newlist . [&#39;apple&#39;, &#39;banana&#39;, &#39;mango&#39;] . Otras de las cosas potentes de Python son las list comprehension, que permiten hacer todo en una sola linea y que el código quede más compacto . fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;, &quot;kiwi&quot;, &quot;mango&quot;] newlist = [x for x in fruits if &quot;a&quot; in x] newlist . [&#39;apple&#39;, &#39;banana&#39;, &#39;mango&#39;] . La sintaxis es la siguiente . newlist = [expression for item in iterable if condition == True] . Se puede aprovechar para realizar operaciones en la lista original . newlist = [x.upper() for x in fruits if &quot;a&quot; in x] newlist . [&#39;APPLE&#39;, &#39;BANANA&#39;, &#39;MANGO&#39;] . 2.3.1.3. Ordenar listas . Para ordenar listas usamos el método sort() . lista = [5, 8, 3, 4, 9, 5, 6] lista.sort() lista . [3, 4, 5, 5, 6, 8, 9] . También nos las ordena allfabéticamente . lista = [&quot;orange&quot;, &quot;mango&quot;, &quot;kiwi&quot;, &quot;pineapple&quot;, &quot;banana&quot;] lista.sort() lista . [&#39;banana&#39;, &#39;kiwi&#39;, &#39;mango&#39;, &#39;orange&#39;, &#39;pineapple&#39;] . A la hora de ordenar alfabéticamente distingue entre mayúsculas y minúsculas . lista = [&quot;orange&quot;, &quot;mango&quot;, &quot;kiwi&quot;, &quot;Pineapple&quot;, &quot;banana&quot;] lista.sort() lista . [&#39;Pineapple&#39;, &#39;banana&#39;, &#39;kiwi&#39;, &#39;mango&#39;, &#39;orange&#39;] . Se pueden ordenar en orden descendente mediante el atributo reverse = True . lista = [5, 8, 3, 4, 9, 5, 6] lista.sort(reverse = True) lista . [9, 8, 6, 5, 5, 4, 3] . Se pueden ordenar de la manera que queramos mediante el atributo key . def myfunc(n): # devuelve el valor absoluto de n - 50 return abs(n - 50) lista = [100, 50, 65, 82, 23] lista.sort(key = myfunc) lista . [50, 65, 23, 82, 100] . Se puede aprovechar esto para que por ejemplo, a la hora de ordenar no distinga entre mayúsculas y minúsculas . lista = [&quot;orange&quot;, &quot;mango&quot;, &quot;kiwi&quot;, &quot;Pineapple&quot;, &quot;banana&quot;] lista.sort(key = str.lower) lista . [&#39;banana&#39;, &#39;kiwi&#39;, &#39;mango&#39;, &#39;orange&#39;, &#39;Pineapple&#39;] . Se puede voltear la lista mediante el método reverse . lista = [5, 8, 3, 4, 9, 5, 6] lista.reverse() lista . [6, 5, 9, 4, 3, 8, 5] . 2.3.1.4. Copiar listas . No se pueden copiar listas mediante lista1 = lista2, ya que si se modifica lista1 también se modifica lista2 . lista1 = [5, 8, 3, 4, 9, 5, 6] lista2 = lista1 lista1[0] = True lista2 . [True, 8, 3, 4, 9, 5, 6] . Por lo que hay que usar el método copy() . lista1 = [5, 8, 3, 4, 9, 5, 6] lista2 = lista1.copy() lista1[0] = True lista2 . [5, 8, 3, 4, 9, 5, 6] . O hay que usar el constructor de listas list() . lista1 = [5, 8, 3, 4, 9, 5, 6] lista2 = list(lista1) lista1[0] = True lista2 . [5, 8, 3, 4, 9, 5, 6] . 2.3.1.5. Concatenar listas . Se pueden concatenar listas mediante el operador + . lista1 = [5, 8, 3, 4, 9, 5, 6] lista2 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] lista = lista1 + lista2 lista . [5, 8, 3, 4, 9, 5, 6, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;] . O mediante el método extend . lista1 = [5, 8, 3, 4, 9, 5, 6] lista2 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] lista1.extend(lista2) lista1 . [5, 8, 3, 4, 9, 5, 6, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;] . Otra forma de concatenar es repetir la tupla X veces mediante el operador * . lista1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] lista2 = lista1 * 3 lista2 . [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;] . 2.3.2. Tuplas . Las tuplas son similares a las listas, guardan múltiples items en una variable, pueden contener items de distintos tipos, pero no s epueden modificar, ni reordenar. Se definen mediante (), con los items separados por comas . Al no poderse modificar hace que las tuplas se ejecuten un poco más rápido que las listas, por lo que si no necesitas modificar los datos es mejor utilizar tuplas en vez de listas . tupla = (&#39;item0&#39;, 1, True, 3.3, &#39;item4&#39;, True) tupla . (&#39;item0&#39;, 1, True, 3.3, &#39;item4&#39;, True) . Se puede obtener su longitud mediante la función len() . len (tupla) . 6 . Para crear tuplas con un único elemento es necesario añadir una coma . tupla = (&#39;item0&#39;,) tupla, type(tupla) . ((&#39;item0&#39;,), tuple) . Para acceder a un elemento de la tupla se procede igual que con las listas . tupla = (&#39;item0&#39;, 1, True, 3.3, &#39;item4&#39;, True) print(tupla[0]) print(tupla[-1]) print(tupla[2:4]) print(tupla[-4:-2]) . item0 True (True, 3.3) (True, 3.3) . Podemos comprobar si hay un item en la tupla . &#39;item4&#39; in tupla . True . 2.3.2.1. Modificar tuplas . Aunque las tuplas no son modificables, se pueden modificar conviertiéndolas a listas, modificando la lista y después volviéndola a convertir a tupla . lista = list(tupla) lista[4] = &#39;ITEM4&#39; tupla = tuple(lista) tupla . (&#39;item0&#39;, 1, True, 3.3, &#39;ITEM4&#39;, True) . Al convertirla a lista podemos hacer todas las modificaciones vistas en las listas . Lo que sí se puede es eliminar la tupla entera . del tupla if &#39;tupla&#39; not in locals(): print(&quot;tupla eliminada&quot;) . tupla eliminada . 2.3.2.2. Desempaquetar tuplas . Cuando creamos tuplas, en realidad estamos empaquetando datos . tupla = (&#39;item0&#39;, 1, True, 3.3, &#39;item4&#39;, True) tupla . (&#39;item0&#39;, 1, True, 3.3, &#39;item4&#39;, True) . pero podemos desempaquetarlos . item0, item1, item2, item3, item4, item5 = tupla item0, item1, item2, item3, item4, item5 . (&#39;item0&#39;, 1, True, 3.3, &#39;item4&#39;, True) . Si queremos sacar menos datos que la longitud de la tupla añadimos un * . item0, item1, item2, *item3 = tupla item0, item1, item2, item3 . (&#39;item0&#39;, 1, True, [3.3, &#39;item4&#39;, True]) . Se puede poner el asterisco * en otra parte si por ejemplo lo que queremos es el último item . item0, item1, *item2, item5 = tupla item0, item1, item2, item5 . (&#39;item0&#39;, 1, [True, 3.3, &#39;item4&#39;], True) . 2.3.2.3. Concatenar tuplas . Se pueden concatenar tuplas mediante el operador + . tupla1 = (&quot;a&quot;, &quot;b&quot; , &quot;c&quot;) tupla2 = (1, 2, 3) tupla3 = tupla1 + tupla2 tupla3 . (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, 1, 2, 3) . Otra forma de concatenar es repetir la tupla X veces mediante el operador * . tupla1 = (&quot;a&quot;, &quot;b&quot; , &quot;c&quot;) tupla2 = tupla1 * 3 tupla2 . (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;) . 2.3.2.4. M&#233;todos de las tuplas . Las tuplas tienen dos métodos, el primero es el método count() que devuelve el número de veces que existe un item dentro de la tupla . tupla = (5, 4, 6, 5, 7, 8, 5, 3, 1, 5) tupla.count(5) . 4 . Otro método es index() que devuelve la primera posición de un item dentro de la tupla . tupla = (5, 4, 6, 5, 7, 8, 5, 3, 1, 5) tupla.index(5) . 0 . 2.3.3. Range . Con range() podemos crear una secuencia de números, comenzando desde 0 (de forma predeterminada), se incrementa en 1 (de forma predeterminada) y se detiene antes de un número especificado . range(start, stop, step) . Por ejemplo si queremos una secuencia de 0 a 5 (sin incluir el 5) . for i in range(5): print(f&#39;{i} &#39;, end=&#39;&#39;) . 0 1 2 3 4 . Si por ejemplo no queremos que empiece en 0 . for i in range(2, 5): print(f&#39;{i} &#39;, end=&#39;&#39;) . 2 3 4 . for i in range(-2, 5): print(f&#39;{i} &#39;, end=&#39;&#39;) . -2 -1 0 1 2 3 4 . Por último, si no queremos que se incremente en 1. Si por ejemplo queremos una secuencia de número pares . for i in range(0, 10, 2): print(f&#39;{i} &#39;, end=&#39;&#39;) . 0 2 4 6 8 . 2.4. Diccionarios . Los diccionarios se usan para guardar datos en pares key:data. Son modificables, no ordenados y no permiten duplicidades. Se definen mediante los símbolos {}. Admiten items de distintos tipos de datos . diccionario = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964, &quot;colors&quot;: [&quot;red&quot;, &quot;white&quot;, &quot;blue&quot;] } diccionario . {&#39;brand&#39;: &#39;Ford&#39;, &#39;colors&#39;: [&#39;red&#39;, &#39;white&#39;, &#39;blue&#39;], &#39;model&#39;: &#39;Mustang&#39;, &#39;year&#39;: 1964} . Como se ha dicho no permiten duplicidades . diccionario = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964, &quot;year&quot;: 2000, &quot;colors&quot;: [&quot;red&quot;, &quot;white&quot;, &quot;blue&quot;] } diccionario[&quot;year&quot;] . 2000 . Se puede obtener su longitud mediante la función len() . len(diccionario) . 4 . Como se puede ver la longitud es 4 y no 5, ya que year lo cuenta solo una vez . 2.4.1. Acceder a los items . Para acceder a un item lo podemos hacer a través de su key . diccionario[&quot;model&quot;] . &#39;Mustang&#39; . También se puede acceder mediante el método get() . diccionario.get(&quot;model&quot;) . &#39;Mustang&#39; . Para saber todas las keys de los diccionarios se puede usar el método keys() . diccionario.keys() . dict_keys([&#39;brand&#39;, &#39;model&#39;, &#39;year&#39;, &#39;colors&#39;]) . Se puede usar una variable para apuntar a las keys del diccionario, con lo que llamándola una vez es necesario . diccionario = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964 } # Se declara una vez la variable que apunta a las keys x = diccionario.keys() print(x) # Se añade una nueva key diccionario[&quot;color&quot;] = &quot;white&quot; # Se consulta la variable que apunta a las key print(x) . dict_keys([&#39;brand&#39;, &#39;model&#39;, &#39;year&#39;]) dict_keys([&#39;brand&#39;, &#39;model&#39;, &#39;year&#39;, &#39;color&#39;]) . Para obtener los valores del diccionario se puede usar el método &#39;values()&#39; . diccionario.values() . dict_values([&#39;Ford&#39;, &#39;Mustang&#39;, 2000, [&#39;red&#39;, &#39;white&#39;, &#39;blue&#39;]]) . Se puede usar una variable para apuntar a los valuess del diccionario, con lo que llamándola una vez es necesario . diccionario = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964 } # Se declara una vez la variable que apunta a los values x = diccionario.values() print(x) # Se modifica un value diccionario[&quot;year&quot;] = 2020 # Se consulta la variable que apunta a los values print(x) . dict_values([&#39;Ford&#39;, &#39;Mustang&#39;, 1964]) dict_values([&#39;Ford&#39;, &#39;Mustang&#39;, 2020]) . Si lo que se quiere son los items enteros, es decir keys y values hay que usar el método items() . diccionario.items() . dict_items([(&#39;brand&#39;, &#39;Ford&#39;), (&#39;model&#39;, &#39;Mustang&#39;), (&#39;year&#39;, 2020)]) . Se puede usar una variable para apuntar a los items del diccionario, con lo que llamándola una vez es necesario . diccionario = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964 } # Se declara una vez la variable que apunta a los items x = diccionario.items() print(x) # Se modifica un value diccionario[&quot;year&quot;] = 2020 # Se consulta la variable que apunta a los items print(x) . dict_items([(&#39;brand&#39;, &#39;Ford&#39;), (&#39;model&#39;, &#39;Mustang&#39;), (&#39;year&#39;, 1964)]) dict_items([(&#39;brand&#39;, &#39;Ford&#39;), (&#39;model&#39;, &#39;Mustang&#39;), (&#39;year&#39;, 2020)]) . Se puede checkear si una key existe en el diccionario . &quot;model&quot; in diccionario . True . 2.4.2. Modificar los items . Se puede modificar un item accediendo a el directamente . diccionario = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964 } # Se modifica un item diccionario[&quot;year&quot;] = 2020 diccionario . {&#39;brand&#39;: &#39;Ford&#39;, &#39;model&#39;: &#39;Mustang&#39;, &#39;year&#39;: 2020} . O se puede modificar mediante el método update() . diccionario = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964 } # Se modifica un item diccionario.update({&quot;year&quot;: 2020}) diccionario . {&#39;brand&#39;: &#39;Ford&#39;, &#39;model&#39;: &#39;Mustang&#39;, &#39;year&#39;: 2020} . 2.4.3. A&#241;adir items . Se puede añadir un item añadiéndolo sin más . diccionario = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964 } # Se modifica un item diccionario[&quot;colour&quot;] = &quot;blue&quot; diccionario . {&#39;brand&#39;: &#39;Ford&#39;, &#39;colour&#39;: &#39;blue&#39;, &#39;model&#39;: &#39;Mustang&#39;, &#39;year&#39;: 1964} . O se puede añadir mediante el método update() . diccionario = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964 } # Se modifica un item diccionario.update({&quot;colour&quot;: &quot;blue&quot;}) diccionario . {&#39;brand&#39;: &#39;Ford&#39;, &#39;colour&#39;: &#39;blue&#39;, &#39;model&#39;: &#39;Mustang&#39;, &#39;year&#39;: 1964} . 2.4.4. Eliminar items . Se puede eliminar un item con una key específica mediante el método pop() . diccionario = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964 } # Se elimina un item diccionario.pop(&quot;model&quot;) diccionario . {&#39;brand&#39;: &#39;Ford&#39;, &#39;year&#39;: 1964} . O se puede eliminar un item con una key específica mediante del indicando el nombre de la key entre los símbolos [] . diccionario = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964 } # Se elimina un item del diccionario[&quot;model&quot;] diccionario . {&#39;brand&#39;: &#39;Ford&#39;, &#39;year&#39;: 1964} . Se elimina el diccionario entero si se usa del y no se especifica la key de un item . diccionario = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964 } # Se elimina un item del diccionario if &#39;diccionario&#39; not in locals(): print(&quot;diccionario eliminado&quot;) . diccionario eliminado . Si lo que se quiere es eliminar el último item introducido se puede usar el método popitem() . diccionario = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964 } # Se elimina el último item introducido diccionario.popitem() diccionario . {&#39;brand&#39;: &#39;Ford&#39;, &#39;model&#39;: &#39;Mustang&#39;} . Si se quiere limpiar el diccionario hay que usar el método clear() . diccionario = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964 } diccionario.clear() diccionario . {} . 2.4.5. Copiar diccionarios . No se pueden copiar diccionarios mediante diccionario1 = diccionario2, ya que si se modifica diccionario1 también se modifica diccionario2 . diccionario1 = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964 } diccionario2 = diccionario1 diccionario1[&quot;year&quot;] = 2000 diccionario2[&quot;year&quot;] . 2000 . Por lo que hay que usar el método copy() . diccionario1 = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964 } diccionario2 = diccionario1.copy() diccionario1[&quot;year&quot;] = 2000 diccionario2[&quot;year&quot;] . 1964 . O hay que usar el constructor de diccionarios dict() . diccionario1 = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964 } diccionario2 = dict(diccionario1) diccionario1[&quot;year&quot;] = 2000 diccionario2[&quot;year&quot;] . 1964 . 2.4.6. Diccionarios nested . Los diccionarios pueden tener itemss de cualquier tipo de dato, incluso otros diccionarios. A este tipo de diccionarios se les denomina diccionarios nested . diccionario_nested = { &quot;child1&quot; : { &quot;name&quot; : &quot;Emil&quot;, &quot;year&quot; : 2004 }, &quot;child2&quot; : { &quot;name&quot; : &quot;Tobias&quot;, &quot;year&quot; : 2007 }, &quot;child3&quot; : { &quot;name&quot; : &quot;Linus&quot;, &quot;year&quot; : 2011 } } diccionario_nested . {&#39;child1&#39;: {&#39;name&#39;: &#39;Emil&#39;, &#39;year&#39;: 2004}, &#39;child2&#39;: {&#39;name&#39;: &#39;Tobias&#39;, &#39;year&#39;: 2007}, &#39;child3&#39;: {&#39;name&#39;: &#39;Linus&#39;, &#39;year&#39;: 2011}} . child1 = { &quot;name&quot; : &quot;Emil&quot;, &quot;year&quot; : 2004 } child2 = { &quot;name&quot; : &quot;Tobias&quot;, &quot;year&quot; : 2007 } child3 = { &quot;name&quot; : &quot;Linus&quot;, &quot;year&quot; : 2011 } diccionario_nested = { &quot;child1&quot; : child1, &quot;child2&quot; : child2, &quot;child3&quot; : child3 } diccionario_nested . {&#39;child1&#39;: {&#39;name&#39;: &#39;Emil&#39;, &#39;year&#39;: 2004}, &#39;child2&#39;: {&#39;name&#39;: &#39;Tobias&#39;, &#39;year&#39;: 2007}, &#39;child3&#39;: {&#39;name&#39;: &#39;Linus&#39;, &#39;year&#39;: 2011}} . 2.4.7. M&#233;todos de los diccionarios . Estos son los métodos que se pueden usar en los diccionarios . 2.5. Sets . 2.5.1. Set . Los setss se utilizan en python para guardar un conjunto de items en una sola variable. Se puede guardar items de distinto tipo. Son no ordenados y no tienen indice. . Se diferencian de las listas en que no tienen ni orden ni índice. . Se declaran mediante los símbolos {} . Como set es una palabra reservada en Python creamos un set con el nombre set_ . set_ = {&#39;item0&#39;, 1, 5.3, &quot;item4&quot;, 5, 6.6} set_ . {1, 5, 5.3, 6.6, &#39;item0&#39;, &#39;item4&#39;} . No puede haber items duplicados, si encuentra algún item duplicado se queda solo con uno . set_ = {&#39;item0&#39;, 1, 5.3, &quot;item4&quot;, 5, 6.6, &#39;item0&#39;} set_ . {1, 5, 5.3, 6.6, &#39;item0&#39;, &#39;item4&#39;} . Se puede obtener la longitud del set mediante la función len() . len(set_) . 6 . Como se puede ver la longitud del set es 6 y no 7, ya que se queda con un solo &#39;item0&#39; . Se puede checkear si un item se encuentra en el set . &#39;item4&#39; in set_ . True . 2.5.1.1. A&#241;adir items . Se puede añadir un item al set mediante el método add() . set_.add(8.8) set_ . {1, 5, 5.3, 6.6, 8.8, &#39;item0&#39;, &#39;item4&#39;} . Se puede añadir otro set mediante el método update() . set2 = {&quot;item5&quot;, &quot;item6&quot;, 7} set_.update(set2) set_ . {1, 5, 5.3, 6.6, 7, 8.8, &#39;item0&#39;, &#39;item4&#39;, &#39;item5&#39;, &#39;item6&#39;} . También se pueden añadir items de tipos de datos iterables de Python . lista = [&quot;item9&quot;, 10, 11.2] set_.update(lista) set_ . {1, 10, 11.2, 5, 5.3, 6.6, 7, 8.8, &#39;item0&#39;, &#39;item4&#39;, &#39;item5&#39;, &#39;item6&#39;, &#39;item9&#39;} . 2.5.1.2. Eliminar items . Se puede eliminar un item determinado mediante el método remove() . set_.remove(&#39;item9&#39;) set_ . {1, 10, 11.2, 5, 5.3, 6.6, 7, 8.8, &#39;item0&#39;, &#39;item4&#39;, &#39;item5&#39;, &#39;item6&#39;} . O mediante el método discard() . set_.discard(&#39;item6&#39;) set_ . {1, 10, 11.2, 5, 5.3, 6.6, 7, 8.8, &#39;item0&#39;, &#39;item4&#39;, &#39;item5&#39;} . Mediante el método pop() se puede eliminar el último item, pero como los sets no son ordenados no hay manera de saber cúal es el último item. El método pop() devuelve el item eliminado . print(f&quot;set antes de pop(): {set_}&quot;) eliminado = set_.pop() print(f&quot;Se ha eliminado {eliminado}&quot;) . set antes de pop(): {1, 5, 5.3, 6.6, 8.8, 7, 10, 11.2, &#39;item4&#39;, &#39;item0&#39;, &#39;item5&#39;} Se ha eliminado 1 . Mediante el método clear() se puede vaciar el set . set_.clear() set_ . set() . Por úlitmo, con del se puede eliminar el set . del set_ if &#39;set_&#39; not in locals(): print(&quot;set eliminado&quot;) . set eliminado . 2.5.1.3. Unir items . Una forma de unir sets es mediante el método union() . set1 = {&quot;a&quot;, &quot;b&quot; , &quot;c&quot;} set2 = {1, 2, 3} set3 = set1.union(set2) set3 . {1, 2, 3, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;} . Otra forma es mediante el método update(), pero de esta manera se añade un set en otro, no se crea uno nuevo . set1 = {&quot;a&quot;, &quot;b&quot; , &quot;c&quot;} set2 = {1, 2, 3} set1.update(set2) set1 . {1, 2, 3, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;} . Estos métodos de union elimina los duplicados, pero si queremos obtener los items duplicados en dos sets usamos el método intersection() . set1 = {&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;} set2 = {&quot;google&quot;, &quot;microsoft&quot;, &quot;apple&quot;} set3 = set1.intersection(set2) set3 . {&#39;apple&#39;} . Si queremos obtener los items duplicados en dos sets, pero sin crear un set nuevo, usamos el método intersection_update() . set1 = {&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;} set2 = {&quot;google&quot;, &quot;microsoft&quot;, &quot;apple&quot;} set1.intersection_update(set2) set1 . {&#39;apple&#39;} . Ahora al revés, si queremos quedarnos con los no duplicados usamos el método symmetric_difference(). . La diferencia entre eso y la unión entre dos sets es que en la unión se queda con todos los items, pero los que están duplicados solo los coge una vez. Ahora nos quedamos con los que no están duplicados . set1 = {&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;} set2 = {&quot;google&quot;, &quot;microsoft&quot;, &quot;apple&quot;} set3 = set1.symmetric_difference(set2) set3 . {&#39;banana&#39;, &#39;cherry&#39;, &#39;google&#39;, &#39;microsoft&#39;} . Si queremos quedarnos con los no duplicados sin crear un set nuevo usamos el método symmetric_difference_update() . set1 = {&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;} set2 = {&quot;google&quot;, &quot;microsoft&quot;, &quot;apple&quot;} set1.symmetric_difference_update(set2) set1 . {&#39;banana&#39;, &#39;cherry&#39;, &#39;google&#39;, &#39;microsoft&#39;} . 2.5.1.4. M&#233;todos de los sets . Estos son los métodos que se pueden usar en los sets . 2.5.2. Frozenset . Los frozensets son como los sets pero con la salvedad de que son inmutables, al igual que las tuplas son como las lists pero inmutables. Por lo que no podremos añadir o eliminar items . 2.6. Booleanos . Hay solo dos booleanos en Python: True y False . Mediante la función bool() se puede evaluar si cualquier cosa es True o False . print(bool(&quot;Hello&quot;)) print(bool(15)) print(bool(0)) . True True False . 2.6.1. Otros tipos de datos True o False . Los siguientes datos son True: . Cualquier string que no esté vacío | Cualquier número escepto el 0 | Cualquier lista, tupla, diccionario o set que no esté vacío | . print(bool(&quot;Hola&quot;)) print(bool(&quot;&quot;)) . True False . print(bool(3)) print(bool(0)) . True False . lista = [1, 2, 3] print(bool(lista)) lista = [] print(bool(lista)) . True False . tupla = (1, 2, 3) print(bool(tupla)) tupla = () print(bool(tupla)) . True False . diccionario = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964, &quot;colors&quot;: [&quot;red&quot;, &quot;white&quot;, &quot;blue&quot;] } print(bool(diccionario)) diccionario.clear() print(bool(diccionario)) . True False . set_ = {&#39;item0&#39;, 1, 5.3, &quot;item4&quot;, 5, 6.6} print(bool(set_)) set_.clear() print(bool(set_)) . True False . 2.7. Binarios . 2.7.1. Bytes . El tipo bytes es una secuencia inmutable de bytes. Solo admiten caracteres ASCII. También se pueden representar los bytes mediante números enteros cuyo valores deben cumplir 0 &lt;= x &lt; 256 . Para crear un tipo byte debemos introducir antes el caracter b . byte = b&quot;DeepMaxFN&quot; byte . b&#39;DeepMaxFN&#39; . También se pueden crear mediante su contructor bytes() . byte = bytes(10) byte . b&#39; x00 x00 x00 x00 x00 x00 x00 x00 x00 x00&#39; . byte = bytes(range(10)) byte . b&#39; x00 x01 x02 x03 x04 x05 x06 x07 x08 t&#39; . Se pueden concatenar bytes mediante el operador + . byte1 = b&#39;DeepMax&#39; byte2 = b&#39;FN&#39; byte3 = byte1 + byte2 byte3 . b&#39;DeepMaxFN&#39; . O medainte la repetición con el operador * . byte1 = b&#39;DeepMaxFN &#39; byte2 = byte1 * 3 byte2 . b&#39;DeepMaxFN DeepMaxFN DeepMaxFN &#39; . Podemos comprobar si un caracter está dentro de la cadena . b&#39;D&#39; in byte1 . True . Estos son los métodos que se pueden usar en los bytes . 2.7.2. Bytearray . Los bytearrays son igual que los bytes solo que son mutables . byte_array = bytearray(b&#39;DeepMaxFN&#39;) byte_array . bytearray(b&#39;DeepMaxFN&#39;) . 2.7.3. Memoryview . Los objetos memoryview permiten que el código Python acceda a los datos internos de un objeto que admite el protocolo de búfer sin realizar copias. . La función memoryview() permite el acceso directo de lectura y escritura a los datos orientados a bytes de un objeto sin necesidad de copiarlos primero. Eso puede generar grandes ganancias de rendimiento cuando se opera con objetos grandes, ya que no crea una copia al cortar. . Protocolo de búfer, puede crear otro objeto de acceso para modificar los datos grandes sin copiarlos. Esto hace que el programa utilice menos memoria y aumenta la velocidad de ejecución. . byte_array = bytearray(&#39;XYZ&#39;, &#39;utf-8&#39;) print(f&#39;Antes de acceder a la memoria: {byte_array}&#39;) mem_view = memoryview(byte_array) mem_view[2]= 74 print(f&#39;Después de acceder a la memoria: {byte_array}&#39;) . Antes de acceder a la memoria: bytearray(b&#39;XYZ&#39;) Después de acceder a la memoria: bytearray(b&#39;XYJ&#39;) . 3. Operadores . 3.1. Operadores aritm&#233;ticos . Operador suma + . 3 + 5 . 8 . Oeprador resta - . 3 - 5 . -2 . Operador multiplicación * . 3 * 5 . 15 . Operador división / . 3 / 5 . 0.6 . Operador módulo %. Devuelve el resto de una división . 25 % 2 . 1 . Operador exponente ** . 5 ** 2 . 25 . Operador división entera // . 25 // 2 . 12 . 3.2. Operadores de comparaci&#243;n . Operador es igual == . 1 == 1 . True . Operador es distinto != . 1 != 2 . True . Operador es mayor que &gt; . 3 &gt; 2 . True . Operador es menor que &lt; . 2 &lt; 3 . True . Operador es mayor o igual que &gt;= . 3 &gt;= 3 . True . Operador es menor o igual que &lt;= . 3 &lt;= 3 . True . 3.3. Operadores l&#243;gicos . Operador and . True and True . True . Operador or . True or False . True . Operador not . not False . True . 3.4. Operadores de identidad . Operador is . 5.3 is 5.3 . True . Operador is not . 5.3 is not 5 . True . 3.5. Operadores de pertenencia . Operador in . x = [&quot;apple&quot;, &quot;banana&quot;] &quot;banana&quot; in x . True . Operador not in . x = [&quot;apple&quot;, &quot;banana&quot;] &quot;orange&quot; not in x . True . 3.6. Operadores bit a bit . Operador AND &amp; . a = 60 # 60 = 0011 1100 b = 13 # 13 = 0000 1101 c = a &amp; b; # 12 = 0000 1100 c . 12 . Operador OR | . a = 60 # 60 = 0011 1100 b = 13 # 13 = 0000 1101 c = a | b; # 61 = 0011 1101 c . 61 . Operador XOR ^ . a = 60 # 60 = 0011 1100 b = 13 # 13 = 0000 1101 c = a ^ b; # 49 = 0011 0001 c . 49 . Operador NOT ~ . a = 60 # 60 = 0011 1100 c = ~a; # -61 = 1100 0011 c . -61 . Operador desplazamiento hacia la izquierda &lt;&lt; . a = 60 # 60 = 0011 1100 c = a &lt;&lt; 2; # 240 = 1111 0000 c . 240 . Operador desplazamiento hacia la derecha &gt;&gt; . a = 60 # 60 = 0011 1100 c = a &gt;&gt; 2; # 15 = 0000 1111 c . 15 . 3.7. Operadores de asignaci&#243;n . Operador = . a = 5 a . 5 . Operador +=. x += y es equivalente a x = x + y . a += 5 a . 10 . Operador -=. x -= y es equivalente a `x = x - y . a -= 5 a . 5 . Operador *=. x *= y es equivalente a `x = x * y . a *= 3 a . 15 . Operador /=. x /= y es equivalente a `x = x / y . a /= 3 a . 5.0 . Operador %=. x %= y es equivalente a `x = x % y . a = 25 a %= 2 a . 1 . Operador //=. x //= y es equivalente a `x = x // y . a = 25 a //= 2 a . 12 . Operador **=. x **= y es equivalente a `x = x ** y . a = 5 a **= 2 a . 25 . Operador &amp;=. x &amp;= y es equivalente a `x = x &amp; y . a = 60 # 60 = 0011 1100 b = 13 # 13 = 0000 1101 a &amp;= b; # 12 = 0000 1100 a . 12 . Operador |=. x |= y es equivalente a `x = x | y . a = 60 # 60 = 0011 1100 b = 13 # 13 = 0000 1101 a |= b; # 61 = 0011 1101 a . 61 . Operador ^=. x ^= y es equivalente a `x = x ^ y . a = 60 # 60 = 0011 1100 b = 13 # 13 = 0000 1101 a ^= b; # 49 = 0011 0001 a . 49 . Operador &gt;&gt;=. x &gt;&gt;= y es equivalente a `x = x &gt;&gt; y . a = 60 # 60 = 0011 1100 a &lt;&lt;= 2; # 240 = 1111 0000 a . 240 . Operador &lt;&lt;=. x &lt;&lt;= y es equivalente a `x = x &lt;&lt; y . a = 60 # 60 = 0011 1100 a &gt;&gt;= 2; # 15 = 0000 1111 a . 15 . 4. Control de flujo . Para poder utilizar las herramientas de control de flujo es necesario añadir la sentencia, dos puntos : y en una nueva línea escribir el códgo con indentación . A diferencia de otros lenguajes, Python necesita la indentación (añadir un espacio en blanco) para definir el código de dentro de una herramienta de control de flujo . 4.1. If . Mediante if podemos crear condiciones . if len(&#39;DeepMaxFN&#39;) == 9: print(&#39;DeepMaxFN tiene 9 caracteres&#39;) . DeepMaxFN tiene 9 caracteres . Si queremos crear más de una condición podemos usar elif . if len(&#39;DeepMaxFN&#39;) &lt; 9: print(&#39;DeepMaxFN tiene menos de 9 caracteres&#39;) elif len(&#39;DeepMaxFN&#39;) == 9: print(&#39;DeepMaxFN tiene 9 caracteres&#39;) . DeepMaxFN tiene 9 caracteres . Si lo que queremos es que se ejecute algo en caso de que no se cumpla ninguna de las condiciones indicadas podemos usar else . if len(&#39;DeepMaxFN&#39;) &lt; 9: print(&#39;DeepMaxFN tiene menos de 9 caracteres&#39;) elif len(&#39;DeepMaxFN&#39;) &gt; 9: print(&#39;DeepMaxFN tiene más de 9 caracteres&#39;) else: print(&#39;DeepMaxFN tiene 9 caracteres&#39;) . DeepMaxFN tiene 9 caracteres . Si queremos escribir todo en una sola línea . if len(&#39;DeepMaxFN&#39;) == 9: print(&#39;DeepMaxFN tiene 9 caracteres&#39;) . DeepMaxFN tiene 9 caracteres . Igual, si queremos escribir todo en una línea, pero con varias condiciones . print(&#39;DeepMaxFN tiene menos de 9 caracteres&#39;) if len(&#39;DeepMaxFN&#39;) &lt; 9 else print(&#39;DeepMaxFN tiene más de 9 caracteres&#39;) if len(&#39;DeepMaxFN&#39;) &gt; 9 else print(&#39;DeepMaxFN tiene 9 caracteres&#39;) . DeepMaxFN tiene 9 caracteres . Si por ejemplo queremos hacer la estructura del if pero no queremos, de momento, codificar una de las condiciones podemos usar pass . if len(&#39;DeepMaxFN&#39;) &lt; 9: print(&#39;DeepMaxFN tiene menos de 9 caracteres&#39;) elif len(&#39;DeepMaxFN&#39;) &gt; 9: pass else: print(&#39;DeepMaxFN tiene 9 caracteres&#39;) . DeepMaxFN tiene 9 caracteres . 4.2. While . El bucle while se ejecuta mientras la condición sea True . i = 0 string = &#39;DeepMaxFN&#39; while len(string) &gt; i: print(string[i], end=&#39;&#39;) i += 1 . DeepMaxFN . Si queremos que el bucle pare por alguna condición usamos break . i = 0 string = &#39;DeepMaxFN&#39; while len(string) &gt; i: if string[i] == &#39;F&#39;: break print(string[i], end=&#39;&#39;) i += 1 . DeepMax . Si queremos que una de las iteracciones no se ejecute por alguna razón usamos continue . i = 0 string = &#39;Deep Max FN&#39; while len(string) &gt; i: if string[i] == &#39; &#39;: i += 1 continue print(string[i], end=&#39;&#39;) i += 1 . DeepMaxFN . Mediante else se puede ejecutar un bloque de código si la condición del while no es True . i = 0 string = &#39;DeepMaxFN&#39; while len(string) &gt; i: print(string[i], end=&#39;&#39;) i += 1 else: print(&quot; nSe ha terminado el while&quot;) . DeepMaxFN Se ha terminado el while . 4.3. For . El bucle for se usa para ejecutar código mientras se itera por una secuencia, esta secuencia puede ser un cualquir elemento iterable de Python (string, lista, tupla, range, diccionario, set) . string = &#39;DeepMaxFN&#39; for x in string: print(x, end=&#39;&#39;) . DeepMaxFN . lista = [&#39;D&#39;, &#39;e&#39;, &#39;e&#39;, &#39;p&#39;, &#39;M&#39;, &#39;a&#39;, &#39;x&#39;, &#39;F&#39;, &#39;N&#39;] for x in lista: print(x, end=&#39;&#39;) . DeepMaxFN . tupla = (&#39;D&#39;, &#39;e&#39;, &#39;e&#39;, &#39;p&#39;, &#39;M&#39;, &#39;a&#39;, &#39;x&#39;, &#39;F&#39;, &#39;N&#39;) for x in tupla: print(x, end=&#39;&#39;) . DeepMaxFN . string = &#39;DeepMaxFN&#39; for i in range(len(string)): print(string[i], end=&#39;&#39;) . DeepMaxFN . diccionario = { &quot;letra1&quot;: &quot;D&quot;, &quot;letra2&quot;: &quot;e&quot;, &quot;letra3&quot;: &quot;e&quot;, &quot;letra4&quot;: &quot;p&quot;, &quot;letra5&quot;: &quot;M&quot;, &quot;letra6&quot;: &quot;a&quot;, &quot;letra7&quot;: &quot;x&quot;, &quot;letra8&quot;: &quot;F&quot;, &quot;letra9&quot;: &quot;N&quot; } for x in diccionario.values(): print(x, end=&#39;&#39;) . DeepMaxFN . También se puede iterar por los sets, pero como son elementos no ordenados, no tendremos control del orden de ejecución . set_ = {&#39;D&#39;, &#39;e&#39;, &#39;e&#39;, &#39;p&#39;, &#39;M&#39;, &#39;a&#39;, &#39;x&#39;, &#39;F&#39;, &#39;N&#39;} for x in set_: print(x, end=&#39;&#39;) . epaFDxNM . Si queremos que el bucle pare por alguna condición usamos break . string = &#39;DeepMaxFN&#39; for x in string: if x == &#39;F&#39;: break print(x, end=&#39;&#39;) . DeepMax . Si queremos que una de las iteracciones no se ejecute por alguna razón usamos continue . string = &#39;Deep Max FN&#39; for x in string: if x == &#39; &#39;: continue print(x, end=&#39;&#39;) . DeepMaxFN . Mediante else se puede ejecutar un bloque de código si la condición del while no es True . string = &#39;DeepMaxFN&#39; for x in string: print(x, end=&#39;&#39;) else: print(&quot; nSe ha terminado el for&quot;) . DeepMaxFN Se ha terminado el for . Si por ejemplo queremos hacer la estructura del for pero no queremos, de momento, codificar el interior podemos usar pass . string = &#39;DeepMaxFN&#39; for x in string: pass print(&#39;Interior del for no codificado&#39;) . Interior del for no codificado . 5. Funciones . Una función es una porción de código que se puede ejecutar tantas veces como quieras. Se le puede pasar argumentos y puede devolver datos como resultado . Para definir una función se comienza con la palabra reservada def seguido del nombre de la función, paréntesis (), dos puntos : y a continuación en una nueva línea indentado el código de la función . def funcion(): print(&#39;DeepmaxFN&#39;) . Para llamar a la función solo es necesario escribir su nombre . funcion() . DeepmaxFN . A las funciones se le pueden pasar todos los argumentos que se quiera, dentro de los paréntesis y separados por comas . def funcion(string1, string2): print(string1 + &#39; &#39; + string2) funcion(&quot;Hola&quot;, &quot;DeepMaxFN&quot;) . Hola DeepMaxFN . Cuando se llama a la función hay que pasarle el mismo número de argumentos que se han declarado, si se pasan más o menos obtendremos un error. . Si no sabemos los argumentos que va a recibir la función se puede usar *args, es decir, poniendo un * antes de los argumentos se indica que el número de argumentos es libre. . Al hacer esto se le pasa una tupla (recordemos que es inmutable) con los argumentos . def funcion(*argumentos): numero_argumentos = len(argumentos) for i in range(numero_argumentos): print(argumentos[i], end=&#39; &#39;) funcion(&quot;funcion&quot;, &quot;con&quot;, &quot;varios&quot;, &quot;argumentos&quot;, &quot;sin&quot;, &quot;especificar&quot;, &quot;cuantos&quot;) . funcion con varios argumentos sin especificar cuantos . En caso de no saber el orden de los argumentos de una función, podemos indicar el argumento que le queremos pasar indicando su nombre . def funcion(argumento1, argumento2, argumento3): print(argumento1 + &#39; &#39;+ argumento2 + &#39; &#39; + argumento3) funcion(argumento3 = &quot;DeepmaxFN&quot;, argumento1 = &quot;Blog&quot;, argumento2 = &quot;de&quot;) . Blog de DeepmaxFN . En caso de querer pasar los argumentos con su nombre, pero en caso de no saber cuantos argumentos se van a pasar se puede usar **kargs. En este caso se le pasará un diccionario con los argumentos . def funcion(**kargumentos): print(&quot;Autor del blog: &quot; + kargumentos[&quot;autor&quot;]) funcion(blog = &quot;Blog&quot;, pertenencia = &quot;de&quot;, autor = &quot;DeepMaxFN&quot;) . Autor del blog: DeepMaxFN . Si queremos que algún argumento tenga un valor por defecto lo podemos indicar entre los paréntesis de la función. De esta manera si a la hora de llamar a la función no se pasa dicho argumento, este en la función tendrá el valor por defecto . def funcion(argumento1, argumento2, argumento3 = &quot;DeepMaxFN&quot;): print(argumento1 + &#39; &#39;+ argumento2 + &#39; &#39; + argumento3) funcion(&quot;Blog&quot;, &quot;de&quot;) . Blog de DeepMaxFN . Se puede pasar cualquier tipo de dato como argumento, por ejemplo si se pasa un lista como argumento, dentro de la función, dicho argumento será tratado como una lista . def funcion(argumento): longitud_lista = len(argumento) for i in range(longitud_lista): print(argumento[i], end=&#39; &#39;) funcion([&quot;Blog&quot;, &quot;de&quot;, &quot;DeepMaxFN&quot;]) . Blog de DeepMaxFN . Las funciones pueden devolver datos, esto se hace mediante la palabra reservada return . def funcion(argumento): longitud_lista = len(argumento) string = &quot;&quot; for i in range(longitud_lista): string = string + argumento[i] + &#39; &#39; return string print(funcion([&quot;Blog&quot;, &quot;de&quot;, &quot;DeepMaxFN&quot;])) . Blog de DeepMaxFN . Pueden devolver más de un dato . def funcion(argumento): longitud_lista = len(argumento) string0 = argumento[0] string1 = argumento[1] string2 = argumento[2] return string0, string1, string2 dato0, dato1, dato2 = funcion([&quot;Blog&quot;, &quot;de&quot;, &quot;DeepMaxFN&quot;]) print(dato0 + &#39; &#39; + dato1 + &#39; &#39; + dato2) . Blog de DeepMaxFN . Si uno de los datos devueltos no nos interesa podemos pasar de el mediante _ . def funcion(argumento): longitud_lista = len(argumento) string0 = argumento[0] string1 = argumento[1] string2 = argumento[2] return string0, string1, string2 _, _, dato_de_interes = funcion([&quot;Blog&quot;, &quot;de&quot;, &quot;DeepMaxFN&quot;]) print(dato_de_interes) . DeepMaxFN . Si por ejemplo queremos hacer la estructura de la función pero no queremos, de momento, codificar el interior podemos usar pass . def funcion(): pass funcion() . Una función puede llamarse a si misma, a esto se le llama recursión o recursividad de la función. . Por ejemplo podemos usar esta cualidad para calcular el factorial de un número . def factorial(n): if n == 0 or n == 1: return 1 else: return n * factorial(n-1) factorial(5) . 120 . 5.1. Built in functions . Hay una serie de funciones ya definidas en Python que se pueden usar, como por ejemplo la función abs(), que devuelve el valor absoluto . abs(-5) . 5 . A continuación se muestra una lista de estas funciones . import builtins dir(builtins) . [&#39;ArithmeticError&#39;, &#39;AssertionError&#39;, &#39;AttributeError&#39;, &#39;BaseException&#39;, &#39;BlockingIOError&#39;, &#39;BrokenPipeError&#39;, &#39;BufferError&#39;, &#39;BytesWarning&#39;, &#39;ChildProcessError&#39;, &#39;ConnectionAbortedError&#39;, &#39;ConnectionError&#39;, &#39;ConnectionRefusedError&#39;, &#39;ConnectionResetError&#39;, &#39;DeprecationWarning&#39;, &#39;EOFError&#39;, &#39;Ellipsis&#39;, &#39;EnvironmentError&#39;, &#39;Exception&#39;, &#39;False&#39;, &#39;FileExistsError&#39;, &#39;FileNotFoundError&#39;, &#39;FloatingPointError&#39;, &#39;FutureWarning&#39;, &#39;GeneratorExit&#39;, &#39;IOError&#39;, &#39;ImportError&#39;, &#39;ImportWarning&#39;, &#39;IndentationError&#39;, &#39;IndexError&#39;, &#39;InterruptedError&#39;, &#39;IsADirectoryError&#39;, &#39;KeyError&#39;, &#39;KeyboardInterrupt&#39;, &#39;LookupError&#39;, &#39;MemoryError&#39;, &#39;ModuleNotFoundError&#39;, &#39;NameError&#39;, &#39;None&#39;, &#39;NotADirectoryError&#39;, &#39;NotImplemented&#39;, &#39;NotImplementedError&#39;, &#39;OSError&#39;, &#39;OverflowError&#39;, &#39;PendingDeprecationWarning&#39;, &#39;PermissionError&#39;, &#39;ProcessLookupError&#39;, &#39;RecursionError&#39;, &#39;ReferenceError&#39;, &#39;ResourceWarning&#39;, &#39;RuntimeError&#39;, &#39;RuntimeWarning&#39;, &#39;StopAsyncIteration&#39;, &#39;StopIteration&#39;, &#39;SyntaxError&#39;, &#39;SyntaxWarning&#39;, &#39;SystemError&#39;, &#39;SystemExit&#39;, &#39;TabError&#39;, &#39;TimeoutError&#39;, &#39;True&#39;, &#39;TypeError&#39;, &#39;UnboundLocalError&#39;, &#39;UnicodeDecodeError&#39;, &#39;UnicodeEncodeError&#39;, &#39;UnicodeError&#39;, &#39;UnicodeTranslateError&#39;, &#39;UnicodeWarning&#39;, &#39;UserWarning&#39;, &#39;ValueError&#39;, &#39;Warning&#39;, &#39;ZeroDivisionError&#39;, &#39;__IPYTHON__&#39;, &#39;__build_class__&#39;, &#39;__debug__&#39;, &#39;__doc__&#39;, &#39;__import__&#39;, &#39;__loader__&#39;, &#39;__name__&#39;, &#39;__package__&#39;, &#39;__spec__&#39;, &#39;abs&#39;, &#39;all&#39;, &#39;any&#39;, &#39;ascii&#39;, &#39;bin&#39;, &#39;bool&#39;, &#39;bytearray&#39;, &#39;bytes&#39;, &#39;callable&#39;, &#39;chr&#39;, &#39;classmethod&#39;, &#39;compile&#39;, &#39;complex&#39;, &#39;copyright&#39;, &#39;credits&#39;, &#39;delattr&#39;, &#39;dict&#39;, &#39;dir&#39;, &#39;display&#39;, &#39;divmod&#39;, &#39;dreload&#39;, &#39;enumerate&#39;, &#39;eval&#39;, &#39;exec&#39;, &#39;filter&#39;, &#39;float&#39;, &#39;format&#39;, &#39;frozenset&#39;, &#39;get_ipython&#39;, &#39;getattr&#39;, &#39;globals&#39;, &#39;hasattr&#39;, &#39;hash&#39;, &#39;help&#39;, &#39;hex&#39;, &#39;id&#39;, &#39;input&#39;, &#39;int&#39;, &#39;isinstance&#39;, &#39;issubclass&#39;, &#39;iter&#39;, &#39;len&#39;, &#39;license&#39;, &#39;list&#39;, &#39;locals&#39;, &#39;map&#39;, &#39;max&#39;, &#39;memoryview&#39;, &#39;min&#39;, &#39;next&#39;, &#39;object&#39;, &#39;oct&#39;, &#39;open&#39;, &#39;ord&#39;, &#39;pow&#39;, &#39;print&#39;, &#39;property&#39;, &#39;range&#39;, &#39;repr&#39;, &#39;reversed&#39;, &#39;round&#39;, &#39;set&#39;, &#39;setattr&#39;, &#39;slice&#39;, &#39;sorted&#39;, &#39;staticmethod&#39;, &#39;str&#39;, &#39;sum&#39;, &#39;super&#39;, &#39;tuple&#39;, &#39;type&#39;, &#39;vars&#39;, &#39;zip&#39;] . 5.2. Documentaci&#243;n de una funci&#243;n . Se puede añadir una explicación de una fucnión que creemos mediante un comentario al inicio de la función, de esta manera cuando llamemos a la built in function help() nos mostrará dicha explicación. . def funcion(): &quot;Esta es la explicación de la función&quot; None help(funcion) . Help on function funcion in module __main__: funcion() Esta es la explicación de la función . Otra opción para ver la explicación de la función es usar el método __doc__ de la función . funcion.__doc__ . &#39;Esta es la explicación de la función&#39; . 5.3. Decoradores . Los decoradores son una funcionalidad de Python que premiten añadir características nuevas a una función . Se crea una función decorador que tiene como parámetro otra función. Entonces la función decorador añade la característica nueva a la función que recibe . def decorador(parametro_funcion): &quot;&quot;&quot;Agrega barritas arriba y abajo de la funcion&quot;&quot;&quot; def envoltorio(): &quot;&quot;&quot;Aplica las barritas al texto&quot;&quot;&quot; print(&quot;==================&quot;) parametro_funcion() print(&quot;==================&quot;) return envoltorio def funcion(): print(&quot;DeepMaxFN&quot;) funcion_envoltorio = decorador(funcion) print(&#39;Función sin decoradores: &#39;) funcion() print(&#39; nFunción con decoradores: &#39;) funcion_envoltorio() . Función sin decoradores: DeepMaxFN Función con decoradores: ================== DeepMaxFN ================== . Pero otra manera más potente de usar los decoradores es mediante el uso de @ y el nombre del decorador antes de la función. . Es decir, primero se define el decorador y a continuación se llama a una función con el decorador definido . def decorador2(parametro_funcion2): &quot;&quot;&quot;Agrega barritas arriba y abajo de la funcion&quot;&quot;&quot; def envoltorio2(): &quot;&quot;&quot;Aplica las barritas al texto&quot;&quot;&quot; print(&quot;==================&quot;) parametro_funcion2() print(&quot;==================&quot;) return envoltorio2 @decorador2 def funcion2(): print(&quot;DeepMaxFN&quot;) print(&#39;Función con decoradores: &#39;) funcion2() . Función con decoradores: ================== DeepMaxFN ================== . 6. Funciones adicionales . 6.1. Funciones lambda . Una función lambda es una pequeña función anónima. . Una función lambda puede tomar cualquier número de argumentos, pero solo puede tener una expresión. . Las funciones lambda se definen de la siguiente manera: . lambda arguments : expression . x = lambda a : a + 10 print(x(5)) . 15 . x = lambda a, b, c : a + b + c print(x(5, 6, 2)) . 13 . El poder de lambda se muestra mejor cuando los usa como una función anónima dentro de otra función. . def myfunc(n): return lambda a : a * n mydoubler = myfunc(2) mytripler = myfunc(3) print(f&quot;mydoubler: {mydoubler(11)}&quot;) print(f&quot;mytripler: {mytripler(11)}&quot;) . mydoubler: 22 mytripler: 33 . 6.2. Funci&#243;n map . La función map permite aplicar a cada elemento de una estructura iterable una función . lista = [1, 2, 3] def funcion_mas_1(valor): return valor + 1 lista_modificada = list(map(funcion_mas_1, lista)) lista_modificada . [2, 3, 4] . Esto es equivalente a usar list comprehension . lista_modificada = [funcion_mas_1(x) for x in lista] lista_modificada . [2, 3, 4] . 6.3. Funci&#243;n filter . La función filter permite seleccionar los elementos de una estructura iterable que cumplan con una característica . lista = [1, 2, 3, 4, 5, 6, 7] def esPar(valor): return valor % 2 == 0 lista_filtrada = list(filter(esPar, lista)) lista_filtrada . [2, 4, 6] . Esto es equivalente a usar list comprehension . lista_filtrada = [x for x in lista if esPar(x)] lista_filtrada . [2, 4, 6] . 6.4. Funci&#243;n reduce . La función reduce permite realizar tareas acumulativas en estructuras iterables . from functools import reduce lista = [1, 2, 3] def acumular(valor, acumulador): print(f&#39;valor = {valor}, acumulador = {acumulador}, acumulacion = {valor + acumulador}&#39;) return valor + acumulador acumulacion = reduce(acumular, lista) print(f&#39; nacumulacion = {acumulacion}&#39;) . valor = 1, acumulador = 2, acumulacion = 3 valor = 3, acumulador = 3, acumulacion = 6 acumulacion = 6 . 2+3+4+5+6+7 . 27 . 6.5. Funci&#243;n zip . Con la función zip se puede compibar varias estructuras iterables en una sola, es decir permite agrupar varias estructuras Ax en una sola estructura B. La estructura B está formada por tuplas de los elementos de las estructuras Ax . nombres = [&quot;Manolo&quot;, &quot;Andres&quot;, &quot;Fernando&quot;] altura = [181, 178, 180] my_zip = list(zip(nombres, altura)) my_zip . [(&#39;Manolo&#39;, 181), (&#39;Andres&#39;, 178), (&#39;Fernando&#39;, 180)] . 7. Clases y objetos . Python es un lenguaje de programación orientado a objetos. Casi todo en Python es un objeto, con sus propiedades y métodos. . Una clase es como un constructor de objetos o un &quot;plano&quot; para crear objetos. . Para crear una clase se usa la palabra reservada class . class Clase: variable = &#39;DeepMaxFN&#39; . Una vez creada la clase se puede crear un objeto de dicha clase . objeto = Clase() Clase.variable . &#39;DeepMaxFN&#39; . Normalmente las clases tienen una función inicial, que se ejecuta cuando se crea un objeto de la clase. Esta función se denomina dunder init y se escribe __init__(). A la función dunder init se le tiene que pasar siempre la variable self, que indica la propia clase, y a continuación, las variables que se quiera . Con esta función se suelen inicializar las variables de las clases, o se ejecuta el código que se necesite cuando se crea un objeto de la clase . class Persona: def __init__(self, nombre, edad): self.nombre = nombre self.edad = edad objeto_persona = Persona(&quot;Miguel&quot;, 36) print(objeto_persona.nombre) print(objeto_persona.edad) . Miguel 36 . Además de la función inicial dunder init, se pueden crear más funciones. A estas funciones se les llama métodos de la clase. A estos métodos siempre hay que pasarles la variable self . class Persona: def __init__(self, nombre, edad): self.nombre = nombre self.edad = edad def saludar(self): print(f&#39;Hola mi nombre es {self.nombre} y tengo {self.edad} años&#39;) objeto_persona = Persona(&quot;Miguel&quot;, 36) objeto_persona.saludar() . Hola mi nombre es Miguel y tengo 36 años . La variable self no tiene por qué ser llamada self, puede tener cualquier nombre, pero dentro de cada clase tiene que ser siempre el mismo. Pero por convenio se suele usar self . class Persona: def __init__(yo_mismo, nombre, edad): yo_mismo.nombre = nombre yo_mismo.edad = edad def saludar(yo_mismo): print(f&#39;Hola mi nombre es {yo_mismo.nombre} y tengo {yo_mismo.edad} años&#39;) objeto_persona = Persona(&quot;Miguel&quot;, 36) objeto_persona.saludar() . Hola mi nombre es Miguel y tengo 36 años . Se pueden modificar las variables de los objetos . objeto_persona.nombre = &#39;Marta&#39; objeto_persona.saludar() . Hola mi nombre es Marta y tengo 36 años . Incluso eliminarlas . del objeto_persona.nombre . También se puede eliminar el objeto entero . del objeto_persona . Si por ejemplo queremos hacer la estructura de la clase pero no queremos, de momento, codificar el interior podemos usar pass . class Persona: pass objeto_persona = Persona() . 7.1. Herencia . La herencia nos permite definir una clase que hereda todos los métodos y propiedades de otra clase. . La clase padre es la clase de la que se hereda, también llamada clase base. . La clase hija es la clase que hereda de otra clase, también llamada clase derivada. . Creamos una clase padre . class Persona: def __init__(self, nombre, apellido): self.nombre = nombre self.apellido = apellido def imprimir_nombre(self): print(f&#39;Me llamo {self.nombre} {self.apellido}&#39;) objeto_padre = Persona(&quot;Laura&quot;, &quot;Perez&quot;) objeto_padre.imprimir_nombre() . Me llamo Laura Perez . Para crear la clase hija hay que indicar entre paréntesis, a la hora de declarar la clase, de qué clase hereda . class Estudiante(Persona): pass . Y a la hora de crear el objeto de la clase hija, se le pasan los parámetros que la clase padre necesita . objeto_hijo = Estudiante(&quot;Mariano&quot;, &quot;Sanz&quot;) objeto_hijo.imprimir_nombre() . Me llamo Mariano Sanz . Hasta ahora la clase hija ha heredado las funciones de la clase padre, pero podemos modificarlas reescribiéndolas. Por ejemplo reescribiendo la función duder init. . Si se reescribe la función dunder init, si queremos que se llame a la función dunder init de la clase padre hay que llamarla. . Para esto hay dos maneras, una es mediante el nombre de la clase padre, en este caso hay que pasarle la variable self . class Estudiante(Persona): def __init__(self, nombre, apellido): Persona.__init__(self, nombre, apellido) objeto_hijo = Estudiante(&quot;Mariano&quot;, &quot;Sanz&quot;) objeto_hijo.imprimir_nombre() . Me llamo Mariano Sanz . Otra forma es mediante super(), en este caso no hace falta pasarle la variable self . class Estudiante(Persona): def __init__(self, nombre, apellido): super().__init__(nombre, apellido) objeto_hijo = Estudiante(&quot;Mariano&quot;, &quot;Sanz&quot;) objeto_hijo.imprimir_nombre() . Me llamo Mariano Sanz . Al modificar las funciones se puede añadir código nuevo . class Estudiante(Persona): def __init__(self, nombre, apellido, curso): Persona.__init__(self, nombre, apellido) self.curso = curso def imprimir_nombre(self): Persona.imprimir_nombre(self) print(f&#39;Estoy en el curso número {self.curso}&#39;) objeto_hijo = Estudiante(&quot;Mariano&quot;, &quot;Sanz&quot;, 4) objeto_hijo.imprimir_nombre() . Me llamo Mariano Sanz Estoy en el curso número 4 . Por último se pueden añadir nuevos métodos . class Estudiante(Persona): def __init__(self, nombre, apellido, curso): Persona.__init__(self, nombre, apellido) self.curso = curso def imprimir_nombre(self): Persona.imprimir_nombre(self) print(f&#39;Estoy en el curso número {self.curso}&#39;) def imprimir_estudiante(self): print(&quot;Soy un estudiante del curso número {self.curso}&quot;) objeto_hijo = Estudiante(&quot;Mariano&quot;, &quot;Sanz&quot;, 4) objeto_hijo.imprimir_nombre() objeto_hijo.imprimir_estudiante() . Me llamo Mariano Sanz Estoy en el curso número 4 Soy un estudiante del curso número {self.curso} . 8. Iteradores . Un iterador es un objeto que contiene un número contable de valores. . Un iterador es un objeto sobre el que se puede iterar, lo que significa que puede atravesar todos los valores. . Técnicamente, en Python, un iterador es un objeto que implementa el protocolo del iterador, que consta de los métodos __iter__() y __next__(). . Las listas, tuplas, diccionarios y conjuntos son todos objetos iterables. Son contenedores iterables de los que puede obtener un iterador. . Todos estos objetos tienen un método iter() que se usa para obtener un iterador: . tupla = (&quot;manzana&quot;, &quot;plátano&quot;, &quot;cereza&quot;) iterable = iter(tupla) print(next(iterable)) print(next(iterable)) print(next(iterable)) . manzana plátano cereza . string = &quot;plátano&quot; iterable = iter(string) print(next(iterable), end=&#39; &#39;) print(next(iterable), end=&#39; &#39;) print(next(iterable), end=&#39; &#39;) print(next(iterable), end=&#39; &#39;) print(next(iterable), end=&#39; &#39;) print(next(iterable), end=&#39; &#39;) print(next(iterable), end=&#39; &#39;) . p l á t a n o . El bucle for en realidad crea un objeto iterador y ejecuta el método next() para cada bucle. . tupla = (&quot;manzana&quot;, &quot;plátano&quot;, &quot;cereza&quot;) for x in tupla: print(x) . manzana plátano cereza . string = &quot;plátano&quot; for x in string: print(x, end=&#39; &#39;) . p l á t a n o . 8.1. Crear un objeto iterador . Para crear un objeto/clase como iterador, hay que implementar los métodos __iter__() y __next__(). . class Numeros: def __iter__(self): self.a = 1 return self def __next__(self): x = self.a self.a += 1 return x objeto_iterador = Numeros() iterador = iter(objeto_iterador) print(next(iterador), end=&#39; &#39;) print(next(iterador), end=&#39; &#39;) print(next(iterador), end=&#39; &#39;) print(next(iterador), end=&#39; &#39;) print(next(iterador), end=&#39; &#39;) . 1 2 3 4 5 . El ejemplo anterior continuaría para siempre si tuviera suficientes llámadas a next(), o si se usara en un bucle for. . Para evitar que la iteración continúe para siempre, podemos usar la declaración StopIteration. . En el método __next__(), podemos agregar una condición de terminación para generar un error si la iteración se realiza un número específico de veces: . class Numeros: def __iter__(self): self.a = 1 return self def __next__(self): if self.a &lt;= 20: x = self.a self.a += 1 return x else: raise StopIteration objeto_iterador = Numeros() iterador = iter(objeto_iterador) for x in iterador: print(x, end=&#39; &#39;) . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 . 9. Alcance de variables . Una variable solo está disponible dentro de la región en la que se crea. A esto se le llama alcance . 9.1. Alcance local . Una variable creada dentro de una función pertenece al ámbito local de esa función y solo se puede usar dentro de esa función. . def funcion(): x = 300 print(x) funcion() . 300 . La variable x no está disponible fuera de la función, pero está disponible para cualquier función dentro de la función . def funcion(): x = 300 def funcion_interna(): print(x) funcion_interna() funcion() . 300 . 9.2. Alcance global . Una variable creada en el cuerpo principal del código Python es una variable global y pertenece al ámbito global. . Las variables globales están disponibles desde cualquier ámbito, global y local. . x = 300 def funcion(): print(f&#39;Ámbito local: {x}&#39;) funcion() print(f&#39;Ámbito global: {x}&#39;) . Ámbito local: 300 Ámbito global: 300 . Si se crean dos variables, una global y otra local, las dos con el mismo nombre, Python las creará como dos variables distintas . x = 300 def funcion(): x = 200 print(f&#39;Variable local: {x}&#39;) funcion() print(f&#39;Variable global: {x}&#39;) . Variable local: 200 Variable global: 300 . Si se necesita crear una variable global, pero está declarada en el ámbito local, se puede usar la palabra clave global. . La palabra clave global hace que la variable sea global. . def funcion(): global x x = 300 funcion() print(f&#39;Variable global: {x}&#39;) . Variable global: 300 . Además, el uso de la palabra clave global realizar un cambio en una variable global dentro de una función. . x = 300 def funcion(): global x x = 200 funcion() print(f&#39;Variable global: {x}&#39;) . Variable global: 200 . 10. M&#243;dulos . Un módulo es un archivo que contiene un conjunto de funciones que desea incluir en su aplicación. . Para crear un módulo, simplemente guarde el código que desea en un archivo con la extensión de archivo .py . . Tip: En los cuadernos Jupyter (Colab es un cuaderno Jupyter en linea) si escribimos el caracter ! antes de un comando podremos ejecutar comandos de consola . Primero vamos a ver en qué directorio estamos, para eso usamos el comando pwd (print working directory) . !pwd . /content . A continuación veamos qué archivos hay es nuestro directorio. Esto lo haremos mediante el comando ls (list) . !ls /content . sample_data . Vemos que solo está la carpeta sample_data . %%writefile modulo.py def funcion_del_modulo(nombre): print(&quot;Hola, &quot; + nombre) . Overwriting modulo.py . Volvemos a ver qué archivos hay en nuestro directorio . !ls /content . modulo.py sample_data . Vemos que se ha creado un archivo modulo.py. Ya podemos usarlo . Para usar un módulo externo hay que usar la palabra import. Para usar las funciones del módulo hay que poner primero el nombre del módulo, un . y a continuación el nombre de la función que se quiere usar . import modulo modulo.funcion_del_modulo(&#39;DeepMaxFN&#39;) . Hola, DeepMaxFN . Si queremos que dentro de nuestro código, el módulo tenga un nombre determinado podemos usar la palabra as . import modulo as mod mod.funcion_del_modulo(&#39;DeepMaxFN&#39;) . Hola, DeepMaxFN . Si el módulo tiene varias funciones, pero solo queremos importar una podemos mediante el uso de las palabras from e import. La forma sería . from &lt;modulo&gt; import &lt;funcion&gt; . En este caso no hace falta indicar el nombre del módulo al llamar a la función . %%writefile modulo.py def funcion1_del_modulo(nombre): print(&quot;Hola, &quot; + nombre + &quot;, funcion 1&quot;) def funcion2_del_modulo(nombre): print(&quot;Hola, &quot; + nombre + &quot;, funcion 2&quot;) def funcion3_del_modulo(nombre): print(&quot;Hola, &quot; + nombre + &quot;, funcion 3&quot;) . Writing modulo.py . from modulo import funcion2_del_modulo funcion2_del_modulo(&#39;DeepMaxFN&#39;) . Hola, DeepMaxFN, funcion 2 . No solo podemos usar módulos creados por nosotros, sino módulos ya instalados (built-in modules) . Por ejemplo podemos usar el módulo platform . import platform x = platform.system() x . &#39;Linux&#39; . 11. Try... Except . Cuando ocurre un error, o una excepción como se llama realmente, Python normalmente se detendrá y generará un mensaje de error. . Estas excepciones se pueden manejar usando las declaraciones try y except . try: print(variable_no_declarada) except: print(&quot;Ha ocurrido una excepción&quot;) . Ha ocurrido una excepción . Dado que el bloque try genera un error, entonces se ejecutará el bloque except . Sin el bloque try, el programa se bloquearía y generaría un error . Se pueden definir tantos bloques de excepción como se desee, por ejemplo, si se quiere ejecutar un bloque de código especial para un tipo de error especial . try: print(x) except NameError: print(&quot;La variable &#39;x &#39; no está definida&quot;) except: print(&quot;Algo inesperado ha ocurrido&quot;) . La variable &#39;x&#39; no está definida . Se puede usar la palabra else para indicar el caso en el que no haya ocurrido un error . try: print(&#39;DeepMaxFN&#39;) except NameError: print(&quot;Ha ocurrido una excepción&quot;) else: print(&#39;Todo OK&#39;) . DeepMaxFN Todo OK . con la palabra finally se ejecutará un codigo al final haya ocurrido una excepción o no . try: print(x) except: print(&quot;Ha ocurrido una excepción&quot;) finally: print(&quot;&#39;try except&#39; finallizado&quot;) . Ha ocurrido una excepción &#39;try except&#39; finallizado . Esto puede resultar útil para cerrar objetos y limpiar recursos . class Clase: variable = &#39;DeepMaxFN&#39; objeto = Clase() try: print(Clase.mi_variable) except: print(&quot;Ha ocurrido una excepción&quot;) finally: del objeto . Ha ocurrido una excepción . 11.1. Crear una excepci&#243;n . Como desarrollador de Python, se puede elegir lanzar una excepción si ocurre una condición. . Para lanzar (o generar) una excepción, hay que usar la palabra clave raise . def division(numerador, denominador): if denominador == 0: raise Exception(&quot;El denominador no puede ser 0&quot;) return numerador/denominador print(division(10, 0)) . Exception Traceback (most recent call last) &lt;ipython-input-9-33fb6066fa78&gt; in &lt;module&gt;() 5 return numerador/denominador 6 -&gt; 7 print(division(10, 0)) &lt;ipython-input-9-33fb6066fa78&gt; in division(numerador, denominador) 1 def division(numerador, denominador): 2 if denominador == 0: -&gt; 3 raise Exception(&#34;El denominador no puede ser 0&#34;) 4 5 return numerador/denominador Exception: El denominador no puede ser 0 . Se puede definir qué tipo de error generar y el texto que se imprimirá al usuario . def division(numerador, denominador): if denominador == 0: raise TypeError(&quot;El denominador no puede ser 0&quot;) return numerador/denominador print(division(10, 0)) . TypeError Traceback (most recent call last) &lt;ipython-input-10-26bfa63ae44c&gt; in &lt;module&gt;() 5 return numerador/denominador 6 -&gt; 7 print(division(10, 0)) &lt;ipython-input-10-26bfa63ae44c&gt; in division(numerador, denominador) 1 def division(numerador, denominador): 2 if denominador == 0: -&gt; 3 raise TypeError(&#34;El denominador no puede ser 0&#34;) 4 5 return numerador/denominador TypeError: El denominador no puede ser 0 . 12. Keywords o palabras reservadas . Durante este post en varias ocasiones han aparecido palabras reservadas de Python o keywords, estas son una serie de palabras reservadas por Python . A continuación se muestra una lista de las keywords . import keyword keyword.kwlist . [&#39;False&#39;, &#39;None&#39;, &#39;True&#39;, &#39;and&#39;, &#39;as&#39;, &#39;assert&#39;, &#39;break&#39;, &#39;class&#39;, &#39;continue&#39;, &#39;def&#39;, &#39;del&#39;, &#39;elif&#39;, &#39;else&#39;, &#39;except&#39;, &#39;finally&#39;, &#39;for&#39;, &#39;from&#39;, &#39;global&#39;, &#39;if&#39;, &#39;import&#39;, &#39;in&#39;, &#39;is&#39;, &#39;lambda&#39;, &#39;nonlocal&#39;, &#39;not&#39;, &#39;or&#39;, &#39;pass&#39;, &#39;raise&#39;, &#39;return&#39;, &#39;try&#39;, &#39;while&#39;, &#39;with&#39;, &#39;yield&#39;] .",
            "url": "https://deepmaxfn.github.io/DeepMaxFN-blog/deepmaxfn/python/2021/02/11/Introducci%C3%B3n-a-Python.html",
            "relUrl": "/deepmaxfn/python/2021/02/11/Introducci%C3%B3n-a-Python.html",
            "date": " • Feb 11, 2021"
        }
        
    
  
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "Soy Máximo Fernández, un ingeniero electrónico entusiasta del data science . This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://deepmaxfn.github.io/DeepMaxFN-blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
      ,"page9": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://deepmaxfn.github.io/DeepMaxFN-blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}