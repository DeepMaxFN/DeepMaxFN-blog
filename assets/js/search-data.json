{
  
    
        "post0": {
            "title": "Introducción a Python",
            "content": "1. Resumen . Vamos a hacer una breve introducción a Python, explicando los tipos de datos que tenemos, los operadores, el uso de funciones y de clases. Además veremos cómo usar los objetos iterables, cómo usar módulos, etc. . . 2. Tipos de datos de Python . Existen 7 tipos de datos en Python . De tipo texto:str | Numéricos:int, float, complex | Secuencias: list, tuple, range | Mapping: dict | Sets: set, frozenset | Booleanos: bool | Binarios: bytes, bytearray, memoryview | Podemos obtener el tipo de dato mediante la función type() . type(5.) . float . Python es un lenguaje de tipado dinámico, es decir puedes tener una variable de un tipo y luego asignarle otro tipo . a = 5 type(a) . int . a = &#39;DeepMaxFn&#39; type(a) . str . Python tipa las variables por ti, pero si las quieres tipar tu se puede hacer . b = int(5.1) type(b), b . (int, 5) . Aunque b se ha inicializado como 5.1, es decir, debería ser de tipo float, al tiparlo nosotros a tipo int, vemos que es de tipo int y además su valor es 5 . 2.1. Strings . Los strings son cadenas de caracteres, estos se pueden definir con doble comilla &quot; o comilla simple &#39; . string = &quot;DeepMaxFn&quot; string . &#39;DeepMaxFn&#39; . string = &#39;DeepMaxFn&#39; string . &#39;DeepMaxFn&#39; . Para escribir un string muy largo y no tener una fila que ocupe mucho espacio se puede introducir en varias lineas . string = &quot;&quot;&quot;Este es un ejemplo de como estoy introduciendo un string en varias lineas&quot;&quot;&quot; string . &#39;Este es un ejemplo de ncomo estoy introduciendo un string nen varias lineas&#39; . string = &#39;&#39;&#39;Este es un ejemplo de como estoy introduciendo un string en varias lineas&#39;&#39;&#39; string . &#39;Este es un ejemplo de ncomo estoy introduciendo un string nen varias lineas&#39; . Sin embargo vemos que en medio ha metido el caracter n, este caracter indica el salto de linea. Si usamos la función print() veremos como ya no aparece . print(string) . Este es un ejemplo de como estoy introduciendo un string en varias lineas . Como hemos dicho los strings son cadenas de caracteres, por lo que podemos navegar e iterar a traves de ellos . for i in range(10): # Se indica a la función print que cuando imprima no termine con un salto de # linea para escribir todo en la misma linea print(string[i], end=&#39;&#39;) . Este es un . Podemos obtener la longitud de nuestro string mediante la función len() . len(string) . 73 . Checkear si hay ulgun string determinado dentro del nuestro . &#39;ejemplo&#39; in string . True . Los strings tienen ciertos atributos útiles, como poner todo en mayusculas . print(string.upper()) . ESTE ES UN EJEMPLO DE COMO ESTOY INTRODUCIENDO UN STRING EN VARIAS LINEAS . Todo en minúsculas . print(string.lower()) . este es un ejemplo de como estoy introduciendo un string en varias lineas . Reemplazar caracteres . print(string.replace(&#39;o&#39;, &#39;@&#39;)) . Este es un ejempl@ de c@m@ est@y intr@duciend@ un string en varias lineas . Obtener todas las palabras . print(string.split()) . [&#39;Este&#39;, &#39;es&#39;, &#39;un&#39;, &#39;ejemplo&#39;, &#39;de&#39;, &#39;como&#39;, &#39;estoy&#39;, &#39;introduciendo&#39;, &#39;un&#39;, &#39;string&#39;, &#39;en&#39;, &#39;varias&#39;, &#39;lineas&#39;] . Puedes ver todos los métodos de los strings en este enlace . Otra cosa util que se puede hacer con los strings es concatenarlos . string1 = &#39;DeepMax&#39; string2 = &#39;Fn&#39; string1 + string2 . &#39;DeepMaxFn&#39; . Antes explicamos que el caracter n correspondía a una salto de linea, este caracter especial corresponde a una serie de caracteres especiales llamados Escape Characters. Veamos otros . Si declaramos un string con doble comilla y queremos añadir una doble comilla dentro del string usamos el escape character &quot; . print(&quot;Este es el blog de &quot;DeepMaxFn &quot;&quot;) . Este es el blog de &#34;DeepMaxFn&#34; . Lo mismo con la comilla simple, añadimos &#39; . print(&#39;Este es el blog de &#39;DeepMaxFn &#39;&#39;) . Este es el blog de &#39;DeepMaxFn&#39; . Ahora tenemos el problema de si queremos añadir el caracter ya que como hemos visto es un escape character, así que lo solucionamos poniendo doble barra (backslash) . print(&#39;Este es el blog de DeepMaxFn &#39;) . Este es el blog de DeepMaxFn . Ya vimos antes el escape character de nueva linea n . print(&#39;Este es el blog de nDeepMaxFn&#39;) . Este es el blog de DeepMaxFn . Si queremos escribir desde el inicio de linea añadimos r . print(&#39;Esto no se imprimirá rEste es el blog de DeepMaxFn&#39;) . Este es el blog de DeepMaxFn . Si queremos añadir añadir un espacio grande (sangría) usamos t . print(&#39;Este es el blog de tDeepMaxFn&#39;) . Este es el blog de DeepMaxFn . Podemos borrar un caracter con b . print(&#39;Este es el blog de bDeepMaxFn&#39;) . Este es el blog de DeepMaxFn . Podemos añadir el codigo ASCII en octal mediante ooo . print(&#39; 104 145 145 160 115 141 170 106 156&#39;) . DeepMaxFn . O añadir el codigo ASCII en hexadecimal mediante xhh . print(&#39; x44 x65 x65 x70 x4d x61 x78 x46 x6e&#39;) . DeepMaxFn . Por último, podemos convertir otro tipo de dato a string . n = 5 print(type (n)) string = str(n) print(type(string)) . &lt;class &#39;int&#39;&gt; &lt;class &#39;str&#39;&gt; . 2.2. N&#250;meros . 2.2.1. Enteros . Numeros de tipo entero . n = 5 n, type(n) . (5, int) . 2.2.2. Float . Números de tipo de coma flotante . n = 5.1 n, type(n) . (5.1, float) . 2.2.3. Complejos . Números complejos . n = 3 + 5j n, type(n) . ((3+5j), complex) . 2.2.4. Conversi&#243;n . Se puede convertir entre tipos de números . n = 5 n = float(n) n, type(n) . (5.0, float) . n = 5.1 n = complex(n) n, type(n) . ((5.1+0j), complex) . n = 5.1 n = int(n) n, type(n) . (5, int) . No se puede convertir un numero complex a tipo int o tipo float . 2.3. Secuencias . 2.3.1. Listas . Las listas guardan múltiples items en una variable. Se declaran mediante los símbolos [], con los items separados por comas . lista = [&#39;item0&#39;, &#39;item1&#39;, &#39;item2&#39;, &#39;item3&#39;, &#39;item4&#39;, &#39;item5&#39;] lista . [&#39;item0&#39;, &#39;item1&#39;, &#39;item2&#39;, &#39;item3&#39;, &#39;item4&#39;, &#39;item5&#39;] . Podemos obtener la longitud de una lista mediante la función len() . len(lista) . 6 . Las listas pueden tener items de distintos tipos . lista = [&#39;item0&#39;, 1, True, 5.3, &quot;item4&quot;, 5, 6.6] lista . [&#39;item0&#39;, 1, True, 5.3, &#39;item4&#39;, 5, 6.6] . En Python se empieza a contar desde la posición 0, es decir, si queremos obtener la primera posición de la lista . lista[0] . &#39;item0&#39; . Pero una de las cosas potentes de Python es que si queremos acceder a la última posición podemos usar índices negativos . lista[-1] . 6.6 . Si en vez de la última posición de la lista queremos la penúltima . lista[-2] . 5 . Si solo queremos un rango de valores, por ejemplo, del segundo al quinto item accedemos mediante [2:5] . lista[2:5] . [True, 5.3, &#39;item4&#39;] . Si se omite el primer número del rango singnifica que queremos desde el primer item de la lista hasta el item indicado, es decir, si queremos desde el primer item hasta el quinto usamos [:5] . lista[:5] . [&#39;item0&#39;, 1, True, 5.3, &#39;item4&#39;] . Si se omite el último número del rango significa que queremos desde el item indicado hasta el último, es decir, si queremos desde el tercer item hasta el último usamos [3:] . lista[3:] . [5.3, &#39;item4&#39;, 5, 6.6] . Podemos escoger el rango de items también con números negativos, es decir, si queremos desde el antepenúltimo hasta el penúltimo usamos [-3:-1]. Esto es útil cuando se tiene listas que no se sabe su longitud, pero se sabe que se quiere un rango de valores del final, porque por ejemplo, la lista se ha creado con medidas que se van tomando y se quiere saber las últimas medias . lista[-3:-1] . [&#39;item4&#39;, 5] . Se puede comprobar si un item está en la lista . &#39;item4&#39; in lista . True . 2.3.1.1. Editar listas . Las listas en Python son dinámicas, es decir, se pueden modificar. Por ejemplo se puede modificar el tercer item . lista[2] = False lista . [&#39;item0&#39;, 1, False, 5.3, &#39;item4&#39;, 5, 6.6] . También se puede modificat un rango de valores . lista[1:4] = [1.1, True, 3] lista . [&#39;item0&#39;, 1.1, True, 3, &#39;item4&#39;, 5, 6.6] . Se pueden añadir valores al final de la lista mediante el método append() . lista.append(&#39;item7&#39;) lista . [&#39;item0&#39;, 1.1, True, 3, &#39;item4&#39;, 5, 6.6, &#39;item7&#39;] . O podemos insertar un valor en una posición determinada mediante el método insert() . lista.insert(2, &#39;insert&#39;) lista . [&#39;item0&#39;, 1.1, &#39;insert&#39;, True, 3, &#39;item4&#39;, 5, 6.6, &#39;item7&#39;] . Se pueden unir listas mediante el método extend() . lista2 = [&#39;item8&#39;, &#39;item9&#39;] lista.extend(lista2) lista . [&#39;item0&#39;, 1.1, &#39;insert&#39;, True, 3, &#39;item4&#39;, 5, 6.6, &#39;item7&#39;, &#39;item8&#39;, &#39;item9&#39;] . No es necesario extender la lista mediante otra lista, se puede hacer mediante otro tipo de dato iterable de Python (tuplas, sets, diccionarios, etc) . tupla = (&#39;item10&#39;, &#39;item11&#39;) lista.extend(tupla) lista . [&#39;item0&#39;, 1.1, &#39;insert&#39;, True, 3, &#39;item4&#39;, 5, 6.6, &#39;item7&#39;, &#39;item8&#39;, &#39;item9&#39;, &#39;item10&#39;, &#39;item11&#39;] . Podemos eliminar una posición determinada mediante el método pop() . lista.pop(2) lista . [&#39;item0&#39;, 1.1, True, 3, &#39;item4&#39;, 5, 6.6, &#39;item7&#39;, &#39;item8&#39;, &#39;item9&#39;, &#39;item10&#39;, &#39;item11&#39;] . Si no se especifica el indice se elimina el último item . lista.pop() lista . [&#39;item0&#39;, 1.1, True, 3, &#39;item4&#39;, 5, 6.6, &#39;item7&#39;, &#39;item8&#39;, &#39;item9&#39;, &#39;item10&#39;] . O se puede eliminar un item sabiendo su valor mediante el método remove() . lista.remove(&#39;item7&#39;) lista . [&#39;item0&#39;, 1.1, True, 3, &#39;item4&#39;, 5, 6.6, &#39;item8&#39;, &#39;item9&#39;, &#39;item10&#39;] . Con la función del() se puede eliminar también un item de la posición indicada . del lista[3] lista . [&#39;item0&#39;, 1.1, True, &#39;item4&#39;, 5, 6.6, &#39;item8&#39;, &#39;item9&#39;, &#39;item10&#39;] . Si no se indica el índice se elimina la lista entera . Con el método clear() deja la lista vacía . lista.clear() lista . [] . Se puede obtener la cantidad de items con un valor determinado mediante el método count() . lista = [5, 4, 6, 5, 7, 8, 5, 3, 1, 5] lista.count(5) . 4 . También se puede obtener el primer índice de un item con un valor determinado mediante el método index() . lista = [5, 4, 6, 5, 7, 8, 5, 3, 1, 5] lista.index(5) . 0 . 2.3.1.2. List comprehension . Podemos operar a través de la lista . fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;, &quot;kiwi&quot;, &quot;mango&quot;] newlist = [] # Iteramos por todos los items de la lista for x in fruits: # Si el item contiene el caracter &quot;a&quot; lo añadimos a newlist if &quot;a&quot; in x: newlist.append(x) newlist . [&#39;apple&#39;, &#39;banana&#39;, &#39;mango&#39;] . Otras de las cosas potentes de Python son las list comprehension, que permiten hacer todo en una sola linea y que el código quede más compacto . fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;, &quot;kiwi&quot;, &quot;mango&quot;] newlist = [x for x in fruits if &quot;a&quot; in x] newlist . [&#39;apple&#39;, &#39;banana&#39;, &#39;mango&#39;] . La sintaxis es la siguiente . newlist = [expression for item in iterable if condition == True] . Se puede aprovechar para realizar operaciones en la lista original . newlist = [x.upper() for x in fruits if &quot;a&quot; in x] newlist . [&#39;APPLE&#39;, &#39;BANANA&#39;, &#39;MANGO&#39;] . 2.3.1.3. Ordenar listas . Para ordenar listas usamos el método sort() . lista = [5, 8, 3, 4, 9, 5, 6] lista.sort() lista . [3, 4, 5, 5, 6, 8, 9] . También nos las ordena allfabéticamente . lista = [&quot;orange&quot;, &quot;mango&quot;, &quot;kiwi&quot;, &quot;pineapple&quot;, &quot;banana&quot;] lista.sort() lista . [&#39;banana&#39;, &#39;kiwi&#39;, &#39;mango&#39;, &#39;orange&#39;, &#39;pineapple&#39;] . A la hora de ordenar alfabéticamente distingue entre mayúsculas y minúsculas . lista = [&quot;orange&quot;, &quot;mango&quot;, &quot;kiwi&quot;, &quot;Pineapple&quot;, &quot;banana&quot;] lista.sort() lista . [&#39;Pineapple&#39;, &#39;banana&#39;, &#39;kiwi&#39;, &#39;mango&#39;, &#39;orange&#39;] . Se pueden ordenar en orden descendente mediante el atributo reverse = True . lista = [5, 8, 3, 4, 9, 5, 6] lista.sort(reverse = True) lista . [9, 8, 6, 5, 5, 4, 3] . Se pueden ordenar de la manera que queramos mediante el atributo key . def myfunc(n): # devuelve el valor absoluto de n - 50 return abs(n - 50) lista = [100, 50, 65, 82, 23] lista.sort(key = myfunc) lista . [50, 65, 23, 82, 100] . Se puede aprovechar esto para que por ejemplo, a la hora de ordenar no distinga entre mayúsculas y minúsculas . lista = [&quot;orange&quot;, &quot;mango&quot;, &quot;kiwi&quot;, &quot;Pineapple&quot;, &quot;banana&quot;] lista.sort(key = str.lower) lista . [&#39;banana&#39;, &#39;kiwi&#39;, &#39;mango&#39;, &#39;orange&#39;, &#39;Pineapple&#39;] . Se puede voltear la lista mediante el método reverse . lista = [5, 8, 3, 4, 9, 5, 6] lista.reverse() lista . [6, 5, 9, 4, 3, 8, 5] . 2.3.1.4. Copiar listas . No se pueden copiar listas mediante lista1 = lista2, ya que si se modifica lista1 también se modifica lista2 . lista1 = [5, 8, 3, 4, 9, 5, 6] lista2 = lista1 lista1[0] = True lista2 . [True, 8, 3, 4, 9, 5, 6] . Por lo que hay que usar el método copy() . lista1 = [5, 8, 3, 4, 9, 5, 6] lista2 = lista1.copy() lista1[0] = True lista2 . [5, 8, 3, 4, 9, 5, 6] . O hay que usar el constructor de listas list() . lista1 = [5, 8, 3, 4, 9, 5, 6] lista2 = list(lista1) lista1[0] = True lista2 . [5, 8, 3, 4, 9, 5, 6] . 2.3.1.5. Concatenar listas . Se pueden concatenar listas mediante el operador + . lista1 = [5, 8, 3, 4, 9, 5, 6] lista2 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] lista = lista1 + lista2 lista . [5, 8, 3, 4, 9, 5, 6, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;] . O mediante el método extend . lista1 = [5, 8, 3, 4, 9, 5, 6] lista2 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] lista1.extend(lista2) lista1 . [5, 8, 3, 4, 9, 5, 6, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;] . Otra forma de concatenar es repetir la tupla X veces mediante el operador * . lista1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] lista2 = lista1 * 3 lista2 . [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;] . 2.3.2. Tuplas . Las tuplas son similares a las listas, guardan múltiples items en una variable, pueden contener items de distintos tipos, pero no s epueden modificar, ni reordenar. Se definen mediante (), con los items separados por comas . Al no poderse modificar hace que las tuplas se ejecuten un poco más rápido que las listas, por lo que si no necesitas modificar los datos es mejor utilizar tuplas en vez de listas . tupla = (&#39;item0&#39;, 1, True, 3.3, &#39;item4&#39;, True) tupla . (&#39;item0&#39;, 1, True, 3.3, &#39;item4&#39;, True) . Se puede obtener su longitud mediante la función len() . len (tupla) . 6 . Para crear tuplas con un único elemento es necesario añadir una coma . tupla = (&#39;item0&#39;,) tupla, type(tupla) . ((&#39;item0&#39;,), tuple) . Para acceder a un elemento de la tupla se procede igual que con las listas . tupla = (&#39;item0&#39;, 1, True, 3.3, &#39;item4&#39;, True) print(tupla[0]) print(tupla[-1]) print(tupla[2:4]) print(tupla[-4:-2]) . item0 True (True, 3.3) (True, 3.3) . Podemos comprobar si hay un item en la tupla . &#39;item4&#39; in tupla . True . 2.3.2.1. Modificar tuplas . Aunque las tuplas no son modificables, se pueden modificar conviertiéndolas a listas, modificando la lista y después volviéndola a convertir a tupla . lista = list(tupla) lista[4] = &#39;ITEM4&#39; tupla = tuple(lista) tupla . (&#39;item0&#39;, 1, True, 3.3, &#39;ITEM4&#39;, True) . Al convertirla a lista podemos hacer todas las modificaciones vistas en las listas . Lo que sí se puede es eliminar la tupla entera . del tupla if &#39;tupla&#39; not in locals(): print(&quot;tupla eliminada&quot;) . tupla eliminada . 2.3.2.2. Desempaquetar tuplas . Cuando creamos tuplas, en realidad estamos empaquetando datos . tupla = (&#39;item0&#39;, 1, True, 3.3, &#39;item4&#39;, True) tupla . (&#39;item0&#39;, 1, True, 3.3, &#39;item4&#39;, True) . pero podemos desempaquetarlos . item0, item1, item2, item3, item4, item5 = tupla item0, item1, item2, item3, item4, item5 . (&#39;item0&#39;, 1, True, 3.3, &#39;item4&#39;, True) . Si queremos sacar menos datos que la longitud de la tupla añadimos un * . item0, item1, item2, *item3 = tupla item0, item1, item2, item3 . (&#39;item0&#39;, 1, True, [3.3, &#39;item4&#39;, True]) . Se puede poner el asterisco * en otra parte si por ejemplo lo que queremos es el último item . item0, item1, *item2, item5 = tupla item0, item1, item2, item5 . (&#39;item0&#39;, 1, [True, 3.3, &#39;item4&#39;], True) . 2.3.2.3. Concatenar tuplas . Se pueden concatenar tuplas mediante el operador + . tupla1 = (&quot;a&quot;, &quot;b&quot; , &quot;c&quot;) tupla2 = (1, 2, 3) tupla3 = tupla1 + tupla2 tupla3 . (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, 1, 2, 3) . Otra forma de concatenar es repetir la tupla X veces mediante el operador * . tupla1 = (&quot;a&quot;, &quot;b&quot; , &quot;c&quot;) tupla2 = tupla1 * 3 tupla2 . (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;) . 2.3.2.4. M&#233;todos de las tuplas . Las tuplas tienen dos métodos, el primero es el método count() que devuelve el número de veces que existe un item dentro de la tupla . tupla = (5, 4, 6, 5, 7, 8, 5, 3, 1, 5) tupla.count(5) . 4 . Otro método es index() que devuelve la primera posición de un item dentro de la tupla . tupla = (5, 4, 6, 5, 7, 8, 5, 3, 1, 5) tupla.index(5) . 0 . 2.3.3. Range . Con range() podemos crear una secuencia de números, comenzando desde 0 (de forma predeterminada), se incrementa en 1 (de forma predeterminada) y se detiene antes de un número especificado . range(start, stop, step) . Por ejemplo si queremos una secuencia de 0 a 5 (sin incluir el 5) . for i in range(5): print(f&#39;{i} &#39;, end=&#39;&#39;) . 0 1 2 3 4 . Si por ejemplo no queremos que empiece en 0 . for i in range(2, 5): print(f&#39;{i} &#39;, end=&#39;&#39;) . 2 3 4 . for i in range(-2, 5): print(f&#39;{i} &#39;, end=&#39;&#39;) . -2 -1 0 1 2 3 4 . Por último, si no queremos que se incremente en 1. Si por ejemplo queremos una secuencia de número pares . for i in range(0, 10, 2): print(f&#39;{i} &#39;, end=&#39;&#39;) . 0 2 4 6 8 . 2.4. Diccionarios . Los diccionarios se usan para guardar datos en pares key:data. Son modificables, no ordenados y no permiten duplicidades. Se definen mediante los símbolos {}. Admiten items de distintos tipos de datos . diccionario = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964, &quot;colors&quot;: [&quot;red&quot;, &quot;white&quot;, &quot;blue&quot;] } diccionario . {&#39;brand&#39;: &#39;Ford&#39;, &#39;colors&#39;: [&#39;red&#39;, &#39;white&#39;, &#39;blue&#39;], &#39;model&#39;: &#39;Mustang&#39;, &#39;year&#39;: 1964} . Como se ha dicho no permiten duplicidades . diccionario = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964, &quot;year&quot;: 2000, &quot;colors&quot;: [&quot;red&quot;, &quot;white&quot;, &quot;blue&quot;] } diccionario[&quot;year&quot;] . 2000 . Se puede obtener su longitud mediante la función len() . len(diccionario) . 4 . Como se puede ver la longitud es 4 y no 5, ya que year lo cuenta solo una vez . 2.4.1. Acceder a los items . Para acceder a un item lo podemos hacer a través de su key . diccionario[&quot;model&quot;] . &#39;Mustang&#39; . También se puede acceder mediante el método get() . diccionario.get(&quot;model&quot;) . &#39;Mustang&#39; . Para saber todas las keys de los diccionarios se puede usar el método keys() . diccionario.keys() . dict_keys([&#39;brand&#39;, &#39;model&#39;, &#39;year&#39;, &#39;colors&#39;]) . Se puede usar una variable para apuntar a las keys del diccionario, con lo que llamándola una vez es necesario . diccionario = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964 } # Se declara una vez la variable que apunta a las keys x = diccionario.keys() print(x) # Se añade una nueva key diccionario[&quot;color&quot;] = &quot;white&quot; # Se consulta la variable que apunta a las key print(x) . dict_keys([&#39;brand&#39;, &#39;model&#39;, &#39;year&#39;]) dict_keys([&#39;brand&#39;, &#39;model&#39;, &#39;year&#39;, &#39;color&#39;]) . Para obtener los valores del diccionario se puede usar el método &#39;values()&#39; . diccionario.values() . dict_values([&#39;Ford&#39;, &#39;Mustang&#39;, 2000, [&#39;red&#39;, &#39;white&#39;, &#39;blue&#39;]]) . Se puede usar una variable para apuntar a los valuess del diccionario, con lo que llamándola una vez es necesario . diccionario = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964 } # Se declara una vez la variable que apunta a los values x = diccionario.values() print(x) # Se modifica un value diccionario[&quot;year&quot;] = 2020 # Se consulta la variable que apunta a los values print(x) . dict_values([&#39;Ford&#39;, &#39;Mustang&#39;, 1964]) dict_values([&#39;Ford&#39;, &#39;Mustang&#39;, 2020]) . Si lo que se quiere son los items enteros, es decir keys y values hay que usar el método items() . diccionario.items() . dict_items([(&#39;brand&#39;, &#39;Ford&#39;), (&#39;model&#39;, &#39;Mustang&#39;), (&#39;year&#39;, 2020)]) . Se puede usar una variable para apuntar a los items del diccionario, con lo que llamándola una vez es necesario . diccionario = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964 } # Se declara una vez la variable que apunta a los items x = diccionario.items() print(x) # Se modifica un value diccionario[&quot;year&quot;] = 2020 # Se consulta la variable que apunta a los items print(x) . dict_items([(&#39;brand&#39;, &#39;Ford&#39;), (&#39;model&#39;, &#39;Mustang&#39;), (&#39;year&#39;, 1964)]) dict_items([(&#39;brand&#39;, &#39;Ford&#39;), (&#39;model&#39;, &#39;Mustang&#39;), (&#39;year&#39;, 2020)]) . Se puede checkear si una key existe en el diccionario . &quot;model&quot; in diccionario . True . 2.4.2. Modificar los items . Se puede modificar un item accediendo a el directamente . diccionario = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964 } # Se modifica un item diccionario[&quot;year&quot;] = 2020 diccionario . {&#39;brand&#39;: &#39;Ford&#39;, &#39;model&#39;: &#39;Mustang&#39;, &#39;year&#39;: 2020} . O se puede modificar mediante el método update() . diccionario = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964 } # Se modifica un item diccionario.update({&quot;year&quot;: 2020}) diccionario . {&#39;brand&#39;: &#39;Ford&#39;, &#39;model&#39;: &#39;Mustang&#39;, &#39;year&#39;: 2020} . 2.4.3. A&#241;adir items . Se puede añadir un item añadiéndolo sin más . diccionario = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964 } # Se modifica un item diccionario[&quot;colour&quot;] = &quot;blue&quot; diccionario . {&#39;brand&#39;: &#39;Ford&#39;, &#39;colour&#39;: &#39;blue&#39;, &#39;model&#39;: &#39;Mustang&#39;, &#39;year&#39;: 1964} . O se puede añadir mediante el método update() . diccionario = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964 } # Se modifica un item diccionario.update({&quot;colour&quot;: &quot;blue&quot;}) diccionario . {&#39;brand&#39;: &#39;Ford&#39;, &#39;colour&#39;: &#39;blue&#39;, &#39;model&#39;: &#39;Mustang&#39;, &#39;year&#39;: 1964} . 2.4.4. Eliminar items . Se puede eliminar un item con una key específica mediante el método pop() . diccionario = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964 } # Se elimina un item diccionario.pop(&quot;model&quot;) diccionario . {&#39;brand&#39;: &#39;Ford&#39;, &#39;year&#39;: 1964} . O se puede eliminar un item con una key específica mediante del indicando el nombre de la key entre los símbolos [] . diccionario = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964 } # Se elimina un item del diccionario[&quot;model&quot;] diccionario . {&#39;brand&#39;: &#39;Ford&#39;, &#39;year&#39;: 1964} . Se elimina el diccionario entero si se usa del y no se especifica la key de un item . diccionario = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964 } # Se elimina un item del diccionario if &#39;diccionario&#39; not in locals(): print(&quot;diccionario eliminado&quot;) . diccionario eliminado . Si lo que se quiere es eliminar el último item introducido se puede usar el método popitem() . diccionario = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964 } # Se elimina el último item introducido diccionario.popitem() diccionario . {&#39;brand&#39;: &#39;Ford&#39;, &#39;model&#39;: &#39;Mustang&#39;} . Si se quiere limpiar el diccionario hay que usar el método clear() . diccionario = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964 } diccionario.clear() diccionario . {} . 2.4.5. Copiar diccionarios . No se pueden copiar diccionarios mediante diccionario1 = diccionario2, ya que si se modifica diccionario1 también se modifica diccionario2 . diccionario1 = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964 } diccionario2 = diccionario1 diccionario1[&quot;year&quot;] = 2000 diccionario2[&quot;year&quot;] . 2000 . Por lo que hay que usar el método copy() . diccionario1 = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964 } diccionario2 = diccionario1.copy() diccionario1[&quot;year&quot;] = 2000 diccionario2[&quot;year&quot;] . 1964 . O hay que usar el constructor de diccionarios dict() . diccionario1 = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964 } diccionario2 = dict(diccionario1) diccionario1[&quot;year&quot;] = 2000 diccionario2[&quot;year&quot;] . 1964 . 2.4.6. Diccionarios nested . Los diccionarios pueden tener itemss de cualquier tipo de dato, incluso otros diccionarios. A este tipo de diccionarios se les denomina diccionarios nested . diccionario_nested = { &quot;child1&quot; : { &quot;name&quot; : &quot;Emil&quot;, &quot;year&quot; : 2004 }, &quot;child2&quot; : { &quot;name&quot; : &quot;Tobias&quot;, &quot;year&quot; : 2007 }, &quot;child3&quot; : { &quot;name&quot; : &quot;Linus&quot;, &quot;year&quot; : 2011 } } diccionario_nested . {&#39;child1&#39;: {&#39;name&#39;: &#39;Emil&#39;, &#39;year&#39;: 2004}, &#39;child2&#39;: {&#39;name&#39;: &#39;Tobias&#39;, &#39;year&#39;: 2007}, &#39;child3&#39;: {&#39;name&#39;: &#39;Linus&#39;, &#39;year&#39;: 2011}} . child1 = { &quot;name&quot; : &quot;Emil&quot;, &quot;year&quot; : 2004 } child2 = { &quot;name&quot; : &quot;Tobias&quot;, &quot;year&quot; : 2007 } child3 = { &quot;name&quot; : &quot;Linus&quot;, &quot;year&quot; : 2011 } diccionario_nested = { &quot;child1&quot; : child1, &quot;child2&quot; : child2, &quot;child3&quot; : child3 } diccionario_nested . {&#39;child1&#39;: {&#39;name&#39;: &#39;Emil&#39;, &#39;year&#39;: 2004}, &#39;child2&#39;: {&#39;name&#39;: &#39;Tobias&#39;, &#39;year&#39;: 2007}, &#39;child3&#39;: {&#39;name&#39;: &#39;Linus&#39;, &#39;year&#39;: 2011}} . 2.4.7. M&#233;todos de los diccionarios . Estos son los métodos que se pueden usar en los diccionarios . 2.5. Sets . 2.5.1. Set . Los setss se utilizan en python para guardar un conjunto de items en una sola variable. Se puede guardar items de distinto tipo. Son no ordenados y no tienen indice. . Se diferencian de las listas en que no tienen ni orden ni índice. . Se declaran mediante los símbolos {} . Como set es una palabra reservada en Python creamos un set con el nombre set_ . set_ = {&#39;item0&#39;, 1, 5.3, &quot;item4&quot;, 5, 6.6} set_ . {1, 5, 5.3, 6.6, &#39;item0&#39;, &#39;item4&#39;} . No puede haber items duplicados, si encuentra algún item duplicado se queda solo con uno . set_ = {&#39;item0&#39;, 1, 5.3, &quot;item4&quot;, 5, 6.6, &#39;item0&#39;} set_ . {1, 5, 5.3, 6.6, &#39;item0&#39;, &#39;item4&#39;} . Se puede obtener la longitud del set mediante la función len() . len(set_) . 6 . Como se puede ver la longitud del set es 6 y no 7, ya que se queda con un solo &#39;item0&#39; . Se puede checkear si un item se encuentra en el set . &#39;item4&#39; in set_ . True . 2.5.1.1. A&#241;adir items . Se puede añadir un item al set mediante el método add() . set_.add(8.8) set_ . {1, 5, 5.3, 6.6, 8.8, &#39;item0&#39;, &#39;item4&#39;} . Se puede añadir otro set mediante el método update() . set2 = {&quot;item5&quot;, &quot;item6&quot;, 7} set_.update(set2) set_ . {1, 5, 5.3, 6.6, 7, 8.8, &#39;item0&#39;, &#39;item4&#39;, &#39;item5&#39;, &#39;item6&#39;} . También se pueden añadir items de tipos de datos iterables de Python . lista = [&quot;item9&quot;, 10, 11.2] set_.update(lista) set_ . {1, 10, 11.2, 5, 5.3, 6.6, 7, 8.8, &#39;item0&#39;, &#39;item4&#39;, &#39;item5&#39;, &#39;item6&#39;, &#39;item9&#39;} . 2.5.1.2. Eliminar items . Se puede eliminar un item determinado mediante el método remove() . set_.remove(&#39;item9&#39;) set_ . {1, 10, 11.2, 5, 5.3, 6.6, 7, 8.8, &#39;item0&#39;, &#39;item4&#39;, &#39;item5&#39;, &#39;item6&#39;} . O mediante el método discard() . set_.discard(&#39;item6&#39;) set_ . {1, 10, 11.2, 5, 5.3, 6.6, 7, 8.8, &#39;item0&#39;, &#39;item4&#39;, &#39;item5&#39;} . Mediante el método pop() se puede eliminar el último item, pero como los sets no son ordenados no hay manera de saber cúal es el último item. El método pop() devuelve el item eliminado . print(f&quot;set antes de pop(): {set_}&quot;) eliminado = set_.pop() print(f&quot;Se ha eliminado {eliminado}&quot;) . set antes de pop(): {1, 5, 5.3, 6.6, 8.8, 7, 10, 11.2, &#39;item4&#39;, &#39;item0&#39;, &#39;item5&#39;} Se ha eliminado 1 . Mediante el método clear() se puede vaciar el set . set_.clear() set_ . set() . Por úlitmo, con del se puede eliminar el set . del set_ if &#39;set_&#39; not in locals(): print(&quot;set eliminado&quot;) . set eliminado . 2.5.1.3. Unir items . Una forma de unir sets es mediante el método union() . set1 = {&quot;a&quot;, &quot;b&quot; , &quot;c&quot;} set2 = {1, 2, 3} set3 = set1.union(set2) set3 . {1, 2, 3, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;} . Otra forma es mediante el método update(), pero de esta manera se añade un set en otro, no se crea uno nuevo . set1 = {&quot;a&quot;, &quot;b&quot; , &quot;c&quot;} set2 = {1, 2, 3} set1.update(set2) set1 . {1, 2, 3, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;} . Estos métodos de union elimina los duplicados, pero si queremos obtener los items duplicados en dos sets usamos el método intersection() . set1 = {&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;} set2 = {&quot;google&quot;, &quot;microsoft&quot;, &quot;apple&quot;} set3 = set1.intersection(set2) set3 . {&#39;apple&#39;} . Si queremos obtener los items duplicados en dos sets, pero sin crear un set nuevo, usamos el método intersection_update() . set1 = {&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;} set2 = {&quot;google&quot;, &quot;microsoft&quot;, &quot;apple&quot;} set1.intersection_update(set2) set1 . {&#39;apple&#39;} . Ahora al revés, si queremos quedarnos con los no duplicados usamos el método symmetric_difference(). . La diferencia entre eso y la unión entre dos sets es que en la unión se queda con todos los items, pero los que están duplicados solo los coge una vez. Ahora nos quedamos con los que no están duplicados . set1 = {&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;} set2 = {&quot;google&quot;, &quot;microsoft&quot;, &quot;apple&quot;} set3 = set1.symmetric_difference(set2) set3 . {&#39;banana&#39;, &#39;cherry&#39;, &#39;google&#39;, &#39;microsoft&#39;} . Si queremos quedarnos con los no duplicados sin crear un set nuevo usamos el método symmetric_difference_update() . set1 = {&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;} set2 = {&quot;google&quot;, &quot;microsoft&quot;, &quot;apple&quot;} set1.symmetric_difference_update(set2) set1 . {&#39;banana&#39;, &#39;cherry&#39;, &#39;google&#39;, &#39;microsoft&#39;} . 2.5.1.4. M&#233;todos de los sets . Estos son los métodos que se pueden usar en los sets . 2.5.2. Frozenset . Los frozensets son como los sets pero con la salvedad de que son inmutables, al igual que las tuplas son como las lists pero inmutables. Por lo que no podremos añadir o eliminar items . 2.6. Booleanos . Hay solo dos booleanos en Python: True y False . Mediante la función bool() se puede evaluar si cualquier cosa es True o False . print(bool(&quot;Hello&quot;)) print(bool(15)) print(bool(0)) . True True False . 2.6.1. Otros tipos de datos True o False . Los siguientes datos son True: . Cualquier string que no esté vacío | Cualquier número escepto el 0 | Cualquier lista, tupla, diccionario o set que no esté vacío | . print(bool(&quot;Hola&quot;)) print(bool(&quot;&quot;)) . True False . print(bool(3)) print(bool(0)) . True False . lista = [1, 2, 3] print(bool(lista)) lista = [] print(bool(lista)) . True False . tupla = (1, 2, 3) print(bool(tupla)) tupla = () print(bool(tupla)) . True False . diccionario = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964, &quot;colors&quot;: [&quot;red&quot;, &quot;white&quot;, &quot;blue&quot;] } print(bool(diccionario)) diccionario.clear() print(bool(diccionario)) . True False . set_ = {&#39;item0&#39;, 1, 5.3, &quot;item4&quot;, 5, 6.6} print(bool(set_)) set_.clear() print(bool(set_)) . True False . 2.7. Binarios . 2.7.1. Bytes . El tipo bytes es una secuencia inmutable de bytes. Solo admiten caracteres ASCII. También se pueden representar los bytes mediante números enteros cuyo valores deben cumplir 0 &lt;= x &lt; 256 . Para crear un tipo byte debemos introducir antes el caracter b . byte = b&quot;DeepMaxFN&quot; byte . b&#39;DeepMaxFN&#39; . También se pueden crear mediante su contructor bytes() . byte = bytes(10) byte . b&#39; x00 x00 x00 x00 x00 x00 x00 x00 x00 x00&#39; . byte = bytes(range(10)) byte . b&#39; x00 x01 x02 x03 x04 x05 x06 x07 x08 t&#39; . Se pueden concatenar bytes mediante el operador + . byte1 = b&#39;DeepMax&#39; byte2 = b&#39;FN&#39; byte3 = byte1 + byte2 byte3 . b&#39;DeepMaxFN&#39; . O medainte la repetición con el operador * . byte1 = b&#39;DeepMaxFN &#39; byte2 = byte1 * 3 byte2 . b&#39;DeepMaxFN DeepMaxFN DeepMaxFN &#39; . Podemos comprobar si un caracter está dentro de la cadena . b&#39;D&#39; in byte1 . True . Estos son los métodos que se pueden usar en los bytes . 2.7.2. Bytearray . Los bytearrays son igual que los bytes solo que son mutables . byte_array = bytearray(b&#39;DeepMaxFN&#39;) byte_array . bytearray(b&#39;DeepMaxFN&#39;) . 2.7.3. Memoryview . Los objetos memoryview permiten que el código Python acceda a los datos internos de un objeto que admite el protocolo de búfer sin realizar copias. . La función memoryview() permite el acceso directo de lectura y escritura a los datos orientados a bytes de un objeto sin necesidad de copiarlos primero. Eso puede generar grandes ganancias de rendimiento cuando se opera con objetos grandes, ya que no crea una copia al cortar. . Protocolo de búfer, puede crear otro objeto de acceso para modificar los datos grandes sin copiarlos. Esto hace que el programa utilice menos memoria y aumenta la velocidad de ejecución. . byte_array = bytearray(&#39;XYZ&#39;, &#39;utf-8&#39;) print(f&#39;Antes de acceder a la memoria: {byte_array}&#39;) mem_view = memoryview(byte_array) mem_view[2]= 74 print(f&#39;Después de acceder a la memoria: {byte_array}&#39;) . Antes de acceder a la memoria: bytearray(b&#39;XYZ&#39;) Después de acceder a la memoria: bytearray(b&#39;XYJ&#39;) . 3. Operadores . 3.1. Operadores aritm&#233;ticos . Operador suma + . 3 + 5 . 8 . Oeprador resta - . 3 - 5 . -2 . Operador multiplicación * . 3 * 5 . 15 . Operador división / . 3 / 5 . 0.6 . Operador módulo %. Devuelve el resto de una división . 25 % 2 . 1 . Operador exponente ** . 5 ** 2 . 25 . Operador división entera // . 25 // 2 . 12 . 3.2. Operadores de comparaci&#243;n . Operador es igual == . 1 == 1 . True . Operador es distinto != . 1 != 2 . True . Operador es mayor que &gt; . 3 &gt; 2 . True . Operador es menor que &lt; . 2 &lt; 3 . True . Operador es mayor o igual que &gt;= . 3 &gt;= 3 . True . Operador es menor o igual que &lt;= . 3 &lt;= 3 . True . 3.3. Operadores l&#243;gicos . Operador and . True and True . True . Operador or . True or False . True . Operador not . not False . True . 3.4. Operadores de identidad . Operador is . 5.3 is 5.3 . True . Operador is not . 5.3 is not 5 . True . 3.5. Operadores de pertenencia . Operador in . x = [&quot;apple&quot;, &quot;banana&quot;] &quot;banana&quot; in x . True . Operador not in . x = [&quot;apple&quot;, &quot;banana&quot;] &quot;orange&quot; not in x . True . 3.6. Operadores bit a bit . Operador AND &amp; . a = 60 # 60 = 0011 1100 b = 13 # 13 = 0000 1101 c = a &amp; b; # 12 = 0000 1100 c . 12 . Operador OR | . a = 60 # 60 = 0011 1100 b = 13 # 13 = 0000 1101 c = a | b; # 61 = 0011 1101 c . 61 . Operador XOR ^ . a = 60 # 60 = 0011 1100 b = 13 # 13 = 0000 1101 c = a ^ b; # 49 = 0011 0001 c . 49 . Operador NOT ~ . a = 60 # 60 = 0011 1100 c = ~a; # -61 = 1100 0011 c . -61 . Operador desplazamiento hacia la izquierda &lt;&lt; . a = 60 # 60 = 0011 1100 c = a &lt;&lt; 2; # 240 = 1111 0000 c . 240 . Operador desplazamiento hacia la derecha &gt;&gt; . a = 60 # 60 = 0011 1100 c = a &gt;&gt; 2; # 15 = 0000 1111 c . 15 . 3.7. Operadores de asignaci&#243;n . Operador = . a = 5 a . 5 . Operador +=. x += y es equivalente a x = x + y . a += 5 a . 10 . Operador -=. x -= y es equivalente a `x = x - y . a -= 5 a . 5 . Operador *=. x *= y es equivalente a `x = x * y . a *= 3 a . 15 . Operador /=. x /= y es equivalente a `x = x / y . a /= 3 a . 5.0 . Operador %=. x %= y es equivalente a `x = x % y . a = 25 a %= 2 a . 1 . Operador //=. x //= y es equivalente a `x = x // y . a = 25 a //= 2 a . 12 . Operador **=. x **= y es equivalente a `x = x ** y . a = 5 a **= 2 a . 25 . Operador &amp;=. x &amp;= y es equivalente a `x = x &amp; y . a = 60 # 60 = 0011 1100 b = 13 # 13 = 0000 1101 a &amp;= b; # 12 = 0000 1100 a . 12 . Operador |=. x |= y es equivalente a `x = x | y . a = 60 # 60 = 0011 1100 b = 13 # 13 = 0000 1101 a |= b; # 61 = 0011 1101 a . 61 . Operador ^=. x ^= y es equivalente a `x = x ^ y . a = 60 # 60 = 0011 1100 b = 13 # 13 = 0000 1101 a ^= b; # 49 = 0011 0001 a . 49 . Operador &gt;&gt;=. x &gt;&gt;= y es equivalente a `x = x &gt;&gt; y . a = 60 # 60 = 0011 1100 a &lt;&lt;= 2; # 240 = 1111 0000 a . 240 . Operador &lt;&lt;=. x &lt;&lt;= y es equivalente a `x = x &lt;&lt; y . a = 60 # 60 = 0011 1100 a &gt;&gt;= 2; # 15 = 0000 1111 a . 15 . 4. Control de flujo . Para poder utilizar las herramientas de control de flujo es necesario añadir la sentencia, dos puntos : y en una nueva línea escribir el códgo con indentación . A diferencia de otros lenguajes, Python necesita la indentación (añadir un espacio en blanco) para definir el código de dentro de una herramienta de control de flujo . 4.1. If . Mediante if podemos crear condiciones . if len(&#39;DeepMaxFN&#39;) == 9: print(&#39;DeepMaxFN tiene 9 caracteres&#39;) . DeepMaxFN tiene 9 caracteres . Si queremos crear más de una condición podemos usar elif . if len(&#39;DeepMaxFN&#39;) &lt; 9: print(&#39;DeepMaxFN tiene menos de 9 caracteres&#39;) elif len(&#39;DeepMaxFN&#39;) == 9: print(&#39;DeepMaxFN tiene 9 caracteres&#39;) . DeepMaxFN tiene 9 caracteres . Si lo que queremos es que se ejecute algo en caso de que no se cumpla ninguna de las condiciones indicadas podemos usar else . if len(&#39;DeepMaxFN&#39;) &lt; 9: print(&#39;DeepMaxFN tiene menos de 9 caracteres&#39;) elif len(&#39;DeepMaxFN&#39;) &gt; 9: print(&#39;DeepMaxFN tiene más de 9 caracteres&#39;) else: print(&#39;DeepMaxFN tiene 9 caracteres&#39;) . DeepMaxFN tiene 9 caracteres . Si queremos escribir todo en una sola línea . if len(&#39;DeepMaxFN&#39;) == 9: print(&#39;DeepMaxFN tiene 9 caracteres&#39;) . DeepMaxFN tiene 9 caracteres . Igual, si queremos escribir todo en una línea, pero con varias condiciones . print(&#39;DeepMaxFN tiene menos de 9 caracteres&#39;) if len(&#39;DeepMaxFN&#39;) &lt; 9 else print(&#39;DeepMaxFN tiene más de 9 caracteres&#39;) if len(&#39;DeepMaxFN&#39;) &gt; 9 else print(&#39;DeepMaxFN tiene 9 caracteres&#39;) . DeepMaxFN tiene 9 caracteres . Si por ejemplo queremos hacer la estructura del if pero no queremos, de momento, codificar una de las condiciones podemos usar pass . if len(&#39;DeepMaxFN&#39;) &lt; 9: print(&#39;DeepMaxFN tiene menos de 9 caracteres&#39;) elif len(&#39;DeepMaxFN&#39;) &gt; 9: pass else: print(&#39;DeepMaxFN tiene 9 caracteres&#39;) . DeepMaxFN tiene 9 caracteres . 4.2. While . El bucle while se ejecuta mientras la condición sea True . i = 0 string = &#39;DeepMaxFN&#39; while len(string) &gt; i: print(string[i], end=&#39;&#39;) i += 1 . DeepMaxFN . Si queremos que el bucle pare por alguna condición usamos break . i = 0 string = &#39;DeepMaxFN&#39; while len(string) &gt; i: if string[i] == &#39;F&#39;: break print(string[i], end=&#39;&#39;) i += 1 . DeepMax . Si queremos que una de las iteracciones no se ejecute por alguna razón usamos continue . i = 0 string = &#39;Deep Max FN&#39; while len(string) &gt; i: if string[i] == &#39; &#39;: i += 1 continue print(string[i], end=&#39;&#39;) i += 1 . DeepMaxFN . Mediante else se puede ejecutar un bloque de código si la condición del while no es True . i = 0 string = &#39;DeepMaxFN&#39; while len(string) &gt; i: print(string[i], end=&#39;&#39;) i += 1 else: print(&quot; nSe ha terminado el while&quot;) . DeepMaxFN Se ha terminado el while . 4.3. For . El bucle for se usa para ejecutar código mientras se itera por una secuencia, esta secuencia puede ser un cualquir elemento iterable de Python (string, lista, tupla, range, diccionario, set) . string = &#39;DeepMaxFN&#39; for x in string: print(x, end=&#39;&#39;) . DeepMaxFN . lista = [&#39;D&#39;, &#39;e&#39;, &#39;e&#39;, &#39;p&#39;, &#39;M&#39;, &#39;a&#39;, &#39;x&#39;, &#39;F&#39;, &#39;N&#39;] for x in lista: print(x, end=&#39;&#39;) . DeepMaxFN . tupla = (&#39;D&#39;, &#39;e&#39;, &#39;e&#39;, &#39;p&#39;, &#39;M&#39;, &#39;a&#39;, &#39;x&#39;, &#39;F&#39;, &#39;N&#39;) for x in tupla: print(x, end=&#39;&#39;) . DeepMaxFN . string = &#39;DeepMaxFN&#39; for i in range(len(string)): print(string[i], end=&#39;&#39;) . DeepMaxFN . diccionario = { &quot;letra1&quot;: &quot;D&quot;, &quot;letra2&quot;: &quot;e&quot;, &quot;letra3&quot;: &quot;e&quot;, &quot;letra4&quot;: &quot;p&quot;, &quot;letra5&quot;: &quot;M&quot;, &quot;letra6&quot;: &quot;a&quot;, &quot;letra7&quot;: &quot;x&quot;, &quot;letra8&quot;: &quot;F&quot;, &quot;letra9&quot;: &quot;N&quot; } for x in diccionario.values(): print(x, end=&#39;&#39;) . DeepMaxFN . También se puede iterar por los sets, pero como son elementos no ordenados, no tendremos control del orden de ejecución . set_ = {&#39;D&#39;, &#39;e&#39;, &#39;e&#39;, &#39;p&#39;, &#39;M&#39;, &#39;a&#39;, &#39;x&#39;, &#39;F&#39;, &#39;N&#39;} for x in set_: print(x, end=&#39;&#39;) . epaFDxNM . Si queremos que el bucle pare por alguna condición usamos break . string = &#39;DeepMaxFN&#39; for x in string: if x == &#39;F&#39;: break print(x, end=&#39;&#39;) . DeepMax . Si queremos que una de las iteracciones no se ejecute por alguna razón usamos continue . string = &#39;Deep Max FN&#39; for x in string: if x == &#39; &#39;: continue print(x, end=&#39;&#39;) . DeepMaxFN . Mediante else se puede ejecutar un bloque de código si la condición del while no es True . string = &#39;DeepMaxFN&#39; for x in string: print(x, end=&#39;&#39;) else: print(&quot; nSe ha terminado el for&quot;) . DeepMaxFN Se ha terminado el for . Si por ejemplo queremos hacer la estructura del for pero no queremos, de momento, codificar el interior podemos usar pass . string = &#39;DeepMaxFN&#39; for x in string: pass print(&#39;Interior del for no codificado&#39;) . Interior del for no codificado . 5. Funciones . Una función es una porción de código que se puede ejecutar tantas veces como quieras. Se le puede pasar argumentos y puede devolver datos como resultado . Para definir una función se comienza con la palabra reservada def seguido del nombre de la función, paréntesis (), dos puntos : y a continuación en una nueva línea indentado el código de la función . def funcion(): print(&#39;DeepmaxFN&#39;) . Para llamar a la función solo es necesario escribir su nombre . funcion() . DeepmaxFN . A las funciones se le pueden pasar todos los argumentos que se quiera, dentro de los paréntesis y separados por comas . def funcion(string1, string2): print(string1 + &#39; &#39; + string2) funcion(&quot;Hola&quot;, &quot;DeepMaxFN&quot;) . Hola DeepMaxFN . Cuando se llama a la función hay que pasarle el mismo número de argumentos que se han declarado, si se pasan más o menos obtendremos un error. . Si no sabemos los argumentos que va a recibir la función se puede usar *args, es decir, poniendo un * antes de los argumentos se indica que el número de argumentos es libre. . Al hacer esto se le pasa una tupla (recordemos que es inmutable) con los argumentos . def funcion(*argumentos): numero_argumentos = len(argumentos) for i in range(numero_argumentos): print(argumentos[i], end=&#39; &#39;) funcion(&quot;funcion&quot;, &quot;con&quot;, &quot;varios&quot;, &quot;argumentos&quot;, &quot;sin&quot;, &quot;especificar&quot;, &quot;cuantos&quot;) . funcion con varios argumentos sin especificar cuantos . En caso de no saber el orden de los argumentos de una función, podemos indicar el argumento que le queremos pasar indicando su nombre . def funcion(argumento1, argumento2, argumento3): print(argumento1 + &#39; &#39;+ argumento2 + &#39; &#39; + argumento3) funcion(argumento3 = &quot;DeepmaxFN&quot;, argumento1 = &quot;Blog&quot;, argumento2 = &quot;de&quot;) . Blog de DeepmaxFN . En caso de querer pasar los argumentos con su nombre, pero en caso de no saber cuantos argumentos se van a pasar se puede usar **kargs. En este caso se le pasará un diccionario con los argumentos . def funcion(**kargumentos): print(&quot;Autor del blog: &quot; + kargumentos[&quot;autor&quot;]) funcion(blog = &quot;Blog&quot;, pertenencia = &quot;de&quot;, autor = &quot;DeepMaxFN&quot;) . Autor del blog: DeepMaxFN . Si queremos que algún argumento tenga un valor por defecto lo podemos indicar entre los paréntesis de la función. De esta manera si a la hora de llamar a la función no se pasa dicho argumento, este en la función tendrá el valor por defecto . def funcion(argumento1, argumento2, argumento3 = &quot;DeepMaxFN&quot;): print(argumento1 + &#39; &#39;+ argumento2 + &#39; &#39; + argumento3) funcion(&quot;Blog&quot;, &quot;de&quot;) . Blog de DeepMaxFN . Se puede pasar cualquier tipo de dato como argumento, por ejemplo si se pasa un lista como argumento, dentro de la función, dicho argumento será tratado como una lista . def funcion(argumento): longitud_lista = len(argumento) for i in range(longitud_lista): print(argumento[i], end=&#39; &#39;) funcion([&quot;Blog&quot;, &quot;de&quot;, &quot;DeepMaxFN&quot;]) . Blog de DeepMaxFN . Las funciones pueden devolver datos, esto se hace mediante la palabra reservada return . def funcion(argumento): longitud_lista = len(argumento) string = &quot;&quot; for i in range(longitud_lista): string = string + argumento[i] + &#39; &#39; return string print(funcion([&quot;Blog&quot;, &quot;de&quot;, &quot;DeepMaxFN&quot;])) . Blog de DeepMaxFN . Pueden devolver más de un dato . def funcion(argumento): longitud_lista = len(argumento) string0 = argumento[0] string1 = argumento[1] string2 = argumento[2] return string0, string1, string2 dato0, dato1, dato2 = funcion([&quot;Blog&quot;, &quot;de&quot;, &quot;DeepMaxFN&quot;]) print(dato0 + &#39; &#39; + dato1 + &#39; &#39; + dato2) . Blog de DeepMaxFN . Si uno de los datos devueltos no nos interesa podemos pasar de el mediante _ . def funcion(argumento): longitud_lista = len(argumento) string0 = argumento[0] string1 = argumento[1] string2 = argumento[2] return string0, string1, string2 _, _, dato_de_interes = funcion([&quot;Blog&quot;, &quot;de&quot;, &quot;DeepMaxFN&quot;]) print(dato_de_interes) . DeepMaxFN . Si por ejemplo queremos hacer la estructura de la función pero no queremos, de momento, codificar el interior podemos usar pass . def funcion(): pass funcion() . Una función puede llamarse a si misma, a esto se le llama recursión o recursividad de la función. . Por ejemplo podemos usar esta cualidad para calcular el factorial de un número . def factorial(n): if n == 0 or n == 1: return 1 else: return n * factorial(n-1) factorial(5) . 120 . 6. Funciones lambda . Una función lambda es una pequeña función anónima. . Una función lambda puede tomar cualquier número de argumentos, pero solo puede tener una expresión. . Las funciones lambda se definen de la siguiente manera: . lambda arguments : expression . x = lambda a : a + 10 print(x(5)) . 15 . x = lambda a, b, c : a + b + c print(x(5, 6, 2)) . 13 . El poder de lambda se muestra mejor cuando los usa como una función anónima dentro de otra función. . def myfunc(n): return lambda a : a * n mydoubler = myfunc(2) mytripler = myfunc(3) print(f&quot;mydoubler: {mydoubler(11)}&quot;) print(f&quot;mytripler: {mytripler(11)}&quot;) . mydoubler: 22 mytripler: 33 . 7. Clases y objetos . Python es un lenguaje de programación orientado a objetos. Casi todo en Python es un objeto, con sus propiedades y métodos. . Una clase es como un constructor de objetos o un &quot;plano&quot; para crear objetos. . Para crear una clase se usa la palabra reservada class . class Clase: variable = &#39;DeepMaxFN&#39; . Una vez creada la clase se puede crear un objeto de dicha clase . objeto = Clase() Clase.variable . &#39;DeepMaxFN&#39; . Normalmente las clases tienen una función inicial, que se ejecuta cuando se crea un objeto de la clase. Esta función se denomina dunder init y se escribe __init__(). A la función dunder init se le tiene que pasar siempre la variable self, que indica la propia clase, y a continuación, las variables que se quiera . Con esta función se suelen inicializar las variables de las clases, o se ejecuta el código que se necesite cuando se crea un objeto de la clase . class Persona: def __init__(self, nombre, edad): self.nombre = nombre self.edad = edad objeto_persona = Persona(&quot;Miguel&quot;, 36) print(objeto_persona.nombre) print(objeto_persona.edad) . Miguel 36 . Además de la función inicial dunder init, se pueden crear más funciones. A estas funciones se les llama métodos de la clase. A estos métodos siempre hay que pasarles la variable self . class Persona: def __init__(self, nombre, edad): self.nombre = nombre self.edad = edad def saludar(self): print(f&#39;Hola mi nombre es {self.nombre} y tengo {self.edad} años&#39;) objeto_persona = Persona(&quot;Miguel&quot;, 36) objeto_persona.saludar() . Hola mi nombre es Miguel y tengo 36 años . La variable self no tiene por qué ser llamada self, puede tener cualquier nombre, pero dentro de cada clase tiene que ser siempre el mismo. Pero por convenio se suele usar self . class Persona: def __init__(yo_mismo, nombre, edad): yo_mismo.nombre = nombre yo_mismo.edad = edad def saludar(yo_mismo): print(f&#39;Hola mi nombre es {yo_mismo.nombre} y tengo {yo_mismo.edad} años&#39;) objeto_persona = Persona(&quot;Miguel&quot;, 36) objeto_persona.saludar() . Hola mi nombre es Miguel y tengo 36 años . Se pueden modificar las variables de los objetos . objeto_persona.nombre = &#39;Marta&#39; objeto_persona.saludar() . Hola mi nombre es Marta y tengo 36 años . Incluso eliminarlas . del objeto_persona.nombre . También se puede eliminar el objeto entero . del objeto_persona . Si por ejemplo queremos hacer la estructura de la clase pero no queremos, de momento, codificar el interior podemos usar pass . class Persona: pass objeto_persona = Persona() . 7.1. Herencia . La herencia nos permite definir una clase que hereda todos los métodos y propiedades de otra clase. . La clase padre es la clase de la que se hereda, también llamada clase base. . La clase hija es la clase que hereda de otra clase, también llamada clase derivada. . Creamos una clase padre . class Persona: def __init__(self, nombre, apellido): self.nombre = nombre self.apellido = apellido def imprimir_nombre(self): print(f&#39;Me llamo {self.nombre} {self.apellido}&#39;) objeto_padre = Persona(&quot;Laura&quot;, &quot;Perez&quot;) objeto_padre.imprimir_nombre() . Me llamo Laura Perez . Para crear la clase hija hay que indicar entre paréntesis, a la hora de declarar la clase, de qué clase hereda . class Estudiante(Persona): pass . Y a la hora de crear el objeto de la clase hija, se le pasan los parámetros que la clase padre necesita . objeto_hijo = Estudiante(&quot;Mariano&quot;, &quot;Sanz&quot;) objeto_hijo.imprimir_nombre() . Me llamo Mariano Sanz . Hasta ahora la clase hija ha heredado las funciones de la clase padre, pero podemos modificarlas reescribiéndolas. Por ejemplo reescribiendo la función duder init. . Si se reescribe la función dunder init, si queremos que se llame a la función dunder init de la clase padre hay que llamarla. . Para esto hay dos maneras, una es mediante el nombre de la clase padre, en este caso hay que pasarle la variable self . class Estudiante(Persona): def __init__(self, nombre, apellido): Persona.__init__(self, nombre, apellido) objeto_hijo = Estudiante(&quot;Mariano&quot;, &quot;Sanz&quot;) objeto_hijo.imprimir_nombre() . Me llamo Mariano Sanz . Otra forma es mediante super(), en este caso no hace falta pasarle la variable self . class Estudiante(Persona): def __init__(self, nombre, apellido): super().__init__(nombre, apellido) objeto_hijo = Estudiante(&quot;Mariano&quot;, &quot;Sanz&quot;) objeto_hijo.imprimir_nombre() . Me llamo Mariano Sanz . Al modificar las funciones se puede añadir código nuevo . class Estudiante(Persona): def __init__(self, nombre, apellido, curso): Persona.__init__(self, nombre, apellido) self.curso = curso def imprimir_nombre(self): Persona.imprimir_nombre(self) print(f&#39;Estoy en el curso número {self.curso}&#39;) objeto_hijo = Estudiante(&quot;Mariano&quot;, &quot;Sanz&quot;, 4) objeto_hijo.imprimir_nombre() . Me llamo Mariano Sanz Estoy en el curso número 4 . Por último se pueden añadir nuevos métodos . class Estudiante(Persona): def __init__(self, nombre, apellido, curso): Persona.__init__(self, nombre, apellido) self.curso = curso def imprimir_nombre(self): Persona.imprimir_nombre(self) print(f&#39;Estoy en el curso número {self.curso}&#39;) def imprimir_estudiante(self): print(&quot;Soy un estudiante del curso número {self.curso}&quot;) objeto_hijo = Estudiante(&quot;Mariano&quot;, &quot;Sanz&quot;, 4) objeto_hijo.imprimir_nombre() objeto_hijo.imprimir_estudiante() . Me llamo Mariano Sanz Estoy en el curso número 4 Soy un estudiante del curso número {self.curso} . 8. Iteradores . Un iterador es un objeto que contiene un número contable de valores. . Un iterador es un objeto sobre el que se puede iterar, lo que significa que puede atravesar todos los valores. . Técnicamente, en Python, un iterador es un objeto que implementa el protocolo del iterador, que consta de los métodos __iter__() y __next__(). . Las listas, tuplas, diccionarios y conjuntos son todos objetos iterables. Son contenedores iterables de los que puede obtener un iterador. . Todos estos objetos tienen un método iter() que se usa para obtener un iterador: . tupla = (&quot;manzana&quot;, &quot;plátano&quot;, &quot;cereza&quot;) iterable = iter(tupla) print(next(iterable)) print(next(iterable)) print(next(iterable)) . manzana plátano cereza . string = &quot;plátano&quot; iterable = iter(string) print(next(iterable), end=&#39; &#39;) print(next(iterable), end=&#39; &#39;) print(next(iterable), end=&#39; &#39;) print(next(iterable), end=&#39; &#39;) print(next(iterable), end=&#39; &#39;) print(next(iterable), end=&#39; &#39;) print(next(iterable), end=&#39; &#39;) . p l á t a n o . El bucle for en realidad crea un objeto iterador y ejecuta el método next() para cada bucle. . tupla = (&quot;manzana&quot;, &quot;plátano&quot;, &quot;cereza&quot;) for x in tupla: print(x) . manzana plátano cereza . string = &quot;plátano&quot; for x in string: print(x, end=&#39; &#39;) . p l á t a n o . 8.1. Crear un objeto iterador . Para crear un objeto/clase como iterador, hay que implementar los métodos __iter__() y __next__(). . class Numeros: def __iter__(self): self.a = 1 return self def __next__(self): x = self.a self.a += 1 return x objeto_iterador = Numeros() iterador = iter(objeto_iterador) print(next(iterador), end=&#39; &#39;) print(next(iterador), end=&#39; &#39;) print(next(iterador), end=&#39; &#39;) print(next(iterador), end=&#39; &#39;) print(next(iterador), end=&#39; &#39;) . 1 2 3 4 5 . El ejemplo anterior continuaría para siempre si tuviera suficientes llámadas a next(), o si se usara en un bucle for. . Para evitar que la iteración continúe para siempre, podemos usar la declaración StopIteration. . En el método __next__(), podemos agregar una condición de terminación para generar un error si la iteración se realiza un número específico de veces: . class Numeros: def __iter__(self): self.a = 1 return self def __next__(self): if self.a &lt;= 20: x = self.a self.a += 1 return x else: raise StopIteration objeto_iterador = Numeros() iterador = iter(objeto_iterador) for x in iterador: print(x, end=&#39; &#39;) . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 . 9. Alcance de variables . Una variable solo está disponible dentro de la región en la que se crea. A esto se le llama alcance . 9.1. Alcance local . Una variable creada dentro de una función pertenece al ámbito local de esa función y solo se puede usar dentro de esa función. . def funcion(): x = 300 print(x) funcion() . 300 . La variable x no está disponible fuera de la función, pero está disponible para cualquier función dentro de la función . def funcion(): x = 300 def funcion_interna(): print(x) funcion_interna() funcion() . 300 . 9.2. Alcance global . Una variable creada en el cuerpo principal del código Python es una variable global y pertenece al ámbito global. . Las variables globales están disponibles desde cualquier ámbito, global y local. . x = 300 def funcion(): print(f&#39;Ámbito local: {x}&#39;) funcion() print(f&#39;Ámbito global: {x}&#39;) . Ámbito local: 300 Ámbito global: 300 . Si se crean dos variables, una global y otra local, las dos con el mismo nombre, Python las creará como dos variables distintas . x = 300 def funcion(): x = 200 print(f&#39;Variable local: {x}&#39;) funcion() print(f&#39;Variable global: {x}&#39;) . Variable local: 200 Variable global: 300 . Si se necesita crear una variable global, pero está declarada en el ámbito local, se puede usar la palabra clave global. . La palabra clave global hace que la variable sea global. . def funcion(): global x x = 300 funcion() print(f&#39;Variable global: {x}&#39;) . Variable global: 300 . Además, el uso de la palabra clave global realizar un cambio en una variable global dentro de una función. . x = 300 def funcion(): global x x = 200 funcion() print(f&#39;Variable global: {x}&#39;) . Variable global: 200 . 10. M&#243;dulos . Un módulo es un archivo que contiene un conjunto de funciones que desea incluir en su aplicación. . Para crear un módulo, simplemente guarde el código que desea en un archivo con la extensión de archivo .py . Tip: En los cuadernos Jupyter (Colab es un cuaderno Jupyter en linea) si escribimos el caracter ! antes de un comando podremos ejecutar comandos de consola . !pwd . /content . 11. Try... Except .",
            "url": "https://deepmaxfn.github.io/DeepMaxFN-blog/deepmaxfn/python/2021/02/10/Introducci%C3%B3n-a-Python.html",
            "relUrl": "/deepmaxfn/python/2021/02/10/Introducci%C3%B3n-a-Python.html",
            "date": " • Feb 10, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "Introducción a Python",
            "content": "1. Resumen . Vamos a hacer una breve introducción a Python, explicando los tipos de datos que tenemos, los operadores, el uso de funciones y de clases. Además veremos cómo usar los objetos iterables, cómo usar módulos, etc. . . 2. Tipos de datos de Python . Existen 7 tipos de datos en Python . De tipo texto:str | Numéricos:int, float, complex | Secuencias: list, tuple, range | Mapping: dict | Sets: set, frozenset | Booleanos: bool | Binarios: bytes, bytearray, memoryview | Podemos obtener el tipo de dato mediante la función type() . type(5.) . float . Python es un lenguaje de tipado dinámico, es decir puedes tener una variable de un tipo y luego asignarle otro tipo . a = 5 type(a) . int . a = &#39;DeepMaxFn&#39; type(a) . str . Python tipa las variables por ti, pero si las quieres tipar tu se puede hacer . b = int(5.1) type(b), b . (int, 5) . Aunque b se ha inicializado como 5.1, es decir, debería ser de tipo float, al tiparlo nosotros a tipo int, vemos que es de tipo int y además su valor es 5 . 2.1. Strings . Los strings son cadenas de caracteres, estos se pueden definir con doble comilla &quot; o comilla simple &#39; . string = &quot;DeepMaxFn&quot; string . &#39;DeepMaxFn&#39; . string = &#39;DeepMaxFn&#39; string . &#39;DeepMaxFn&#39; . Para escribir un string muy largo y no tener una fila que ocupe mucho espacio se puede introducir en varias lineas . string = &quot;&quot;&quot;Este es un ejemplo de como estoy introduciendo un string en varias lineas&quot;&quot;&quot; string . &#39;Este es un ejemplo de ncomo estoy introduciendo un string nen varias lineas&#39; . string = &#39;&#39;&#39;Este es un ejemplo de como estoy introduciendo un string en varias lineas&#39;&#39;&#39; string . &#39;Este es un ejemplo de ncomo estoy introduciendo un string nen varias lineas&#39; . Sin embargo vemos que en medio ha metido el caracter n, este caracter indica el salto de linea. Si usamos la función print() veremos como ya no aparece . print(string) . Este es un ejemplo de como estoy introduciendo un string en varias lineas . Como hemos dicho los strings son cadenas de caracteres, por lo que podemos navegar e iterar a traves de ellos . for i in range(10): # Se indica a la función print que cuando imprima no termine con un salto de # linea para escribir todo en la misma linea print(string[i], end=&#39;&#39;) . Este es un . Podemos obtener la longitud de nuestro string mediante la función len() . len(string) . 73 . Checkear si hay ulgun string determinado dentro del nuestro . &#39;ejemplo&#39; in string . True . Los strings tienen ciertos atributos útiles, como poner todo en mayusculas . print(string.upper()) . ESTE ES UN EJEMPLO DE COMO ESTOY INTRODUCIENDO UN STRING EN VARIAS LINEAS . Todo en minúsculas . print(string.lower()) . este es un ejemplo de como estoy introduciendo un string en varias lineas . Reemplazar caracteres . print(string.replace(&#39;o&#39;, &#39;@&#39;)) . Este es un ejempl@ de c@m@ est@y intr@duciend@ un string en varias lineas . Obtener todas las palabras . print(string.split()) . [&#39;Este&#39;, &#39;es&#39;, &#39;un&#39;, &#39;ejemplo&#39;, &#39;de&#39;, &#39;como&#39;, &#39;estoy&#39;, &#39;introduciendo&#39;, &#39;un&#39;, &#39;string&#39;, &#39;en&#39;, &#39;varias&#39;, &#39;lineas&#39;] . Puedes ver todos los métodos de los strings en este enlace . Otra cosa util que se puede hacer con los strings es concatenarlos . string1 = &#39;DeepMax&#39; string2 = &#39;Fn&#39; string1 + string2 . &#39;DeepMaxFn&#39; . Antes explicamos que el caracter n correspondía a una salto de linea, este caracter especial corresponde a una serie de caracteres especiales llamados Escape Characters. Veamos otros . Si declaramos un string con doble comilla y queremos añadir una doble comilla dentro del string usamos el escape character &quot; . print(&quot;Este es el blog de &quot;DeepMaxFn &quot;&quot;) . Este es el blog de &#34;DeepMaxFn&#34; . Lo mismo con la comilla simple, añadimos &#39; . print(&#39;Este es el blog de &#39;DeepMaxFn &#39;&#39;) . Este es el blog de &#39;DeepMaxFn&#39; . Ahora tenemos el problema de si queremos añadir el caracter ya que como hemos visto es un escape character, así que lo solucionamos poniendo doble barra (backslash) . print(&#39;Este es el blog de DeepMaxFn &#39;) . Este es el blog de DeepMaxFn . Ya vimos antes el escape character de nueva linea n . print(&#39;Este es el blog de nDeepMaxFn&#39;) . Este es el blog de DeepMaxFn . Si queremos escribir desde el inicio de linea añadimos r . print(&#39;Esto no se imprimirá rEste es el blog de DeepMaxFn&#39;) . Este es el blog de DeepMaxFn . Si queremos añadir añadir un espacio grande (sangría) usamos t . print(&#39;Este es el blog de tDeepMaxFn&#39;) . Este es el blog de DeepMaxFn . Podemos borrar un caracter con b . print(&#39;Este es el blog de bDeepMaxFn&#39;) . Este es el blog de DeepMaxFn . Podemos añadir el codigo ASCII en octal mediante ooo . print(&#39; 104 145 145 160 115 141 170 106 156&#39;) . DeepMaxFn . O añadir el codigo ASCII en hexadecimal mediante xhh . print(&#39; x44 x65 x65 x70 x4d x61 x78 x46 x6e&#39;) . DeepMaxFn . Por último, podemos convertir otro tipo de dato a string . n = 5 print(type (n)) string = str(n) print(type(string)) . &lt;class &#39;int&#39;&gt; &lt;class &#39;str&#39;&gt; . 2.2. N&#250;meros . 2.2.1. Enteros . Numeros de tipo entero . n = 5 n, type(n) . (5, int) . 2.2.2. Float . Números de tipo de coma flotante . n = 5.1 n, type(n) . (5.1, float) . 2.2.3. Complejos . Números complejos . n = 3 + 5j n, type(n) . ((3+5j), complex) . 2.2.4. Conversi&#243;n . Se puede convertir entre tipos de números . n = 5 n = float(n) n, type(n) . (5.0, float) . n = 5.1 n = complex(n) n, type(n) . ((5.1+0j), complex) . n = 5.1 n = int(n) n, type(n) . (5, int) . No se puede convertir un numero complex a tipo int o tipo float . 2.3. Secuencias . 2.3.1. Listas . Las listas guardan múltiples items en una variable. Se declaran mediante los símbolos [], con los items separados por comas . lista = [&#39;item0&#39;, &#39;item1&#39;, &#39;item2&#39;, &#39;item3&#39;, &#39;item4&#39;, &#39;item5&#39;] lista . [&#39;item0&#39;, &#39;item1&#39;, &#39;item2&#39;, &#39;item3&#39;, &#39;item4&#39;, &#39;item5&#39;] . Podemos obtener la longitud de una lista mediante la función len() . len(lista) . 6 . Las listas pueden tener items de distintos tipos . lista = [&#39;item0&#39;, 1, True, 5.3, &quot;item4&quot;, 5, 6.6] lista . [&#39;item0&#39;, 1, True, 5.3, &#39;item4&#39;, 5, 6.6] . En Python se empieza a contar desde la posición 0, es decir, si queremos obtener la primera posición de la lista . lista[0] . &#39;item0&#39; . Pero una de las cosas potentes de Python es que si queremos acceder a la última posición podemos usar índices negativos . lista[-1] . 6.6 . Si en vez de la última posición de la lista queremos la penúltima . lista[-2] . 5 . Si solo queremos un rango de valores, por ejemplo, del segundo al quinto item accedemos mediante [2:5] . lista[2:5] . [True, 5.3, &#39;item4&#39;] . Si se omite el primer número del rango singnifica que queremos desde el primer item de la lista hasta el item indicado, es decir, si queremos desde el primer item hasta el quinto usamos [:5] . lista[:5] . [&#39;item0&#39;, 1, True, 5.3, &#39;item4&#39;] . Si se omite el último número del rango significa que queremos desde el item indicado hasta el último, es decir, si queremos desde el tercer item hasta el último usamos [3:] . lista[3:] . [5.3, &#39;item4&#39;, 5, 6.6] . Podemos escoger el rango de items también con números negativos, es decir, si queremos desde el antepenúltimo hasta el penúltimo usamos [-3:-1]. Esto es útil cuando se tiene listas que no se sabe su longitud, pero se sabe que se quiere un rango de valores del final, porque por ejemplo, la lista se ha creado con medidas que se van tomando y se quiere saber las últimas medias . lista[-3:-1] . [&#39;item4&#39;, 5] . Se puede comprobar si un item está en la lista . &#39;item4&#39; in lista . True . 2.3.1.1. Editar listas . Las listas en Python son dinámicas, es decir, se pueden modificar. Por ejemplo se puede modificar el tercer item . lista[2] = False lista . [&#39;item0&#39;, 1, False, 5.3, &#39;item4&#39;, 5, 6.6] . También se puede modificat un rango de valores . lista[1:4] = [1.1, True, 3] lista . [&#39;item0&#39;, 1.1, True, 3, &#39;item4&#39;, 5, 6.6] . Se pueden añadir valores al final de la lista mediante el método append() . lista.append(&#39;item7&#39;) lista . [&#39;item0&#39;, 1.1, True, 3, &#39;item4&#39;, 5, 6.6, &#39;item7&#39;] . O podemos insertar un valor en una posición determinada mediante el método insert() . lista.insert(2, &#39;insert&#39;) lista . [&#39;item0&#39;, 1.1, &#39;insert&#39;, True, 3, &#39;item4&#39;, 5, 6.6, &#39;item7&#39;] . Se pueden unir listas mediante el método extend() . lista2 = [&#39;item8&#39;, &#39;item9&#39;] lista.extend(lista2) lista . [&#39;item0&#39;, 1.1, &#39;insert&#39;, True, 3, &#39;item4&#39;, 5, 6.6, &#39;item7&#39;, &#39;item8&#39;, &#39;item9&#39;] . No es necesario extender la lista mediante otra lista, se puede hacer mediante otro tipo de dato iterable de Python (tuplas, sets, diccionarios, etc) . tupla = (&#39;item10&#39;, &#39;item11&#39;) lista.extend(tupla) lista . [&#39;item0&#39;, 1.1, &#39;insert&#39;, True, 3, &#39;item4&#39;, 5, 6.6, &#39;item7&#39;, &#39;item8&#39;, &#39;item9&#39;, &#39;item10&#39;, &#39;item11&#39;] . Podemos eliminar una posición determinada mediante el método pop() . lista.pop(2) lista . [&#39;item0&#39;, 1.1, True, 3, &#39;item4&#39;, 5, 6.6, &#39;item7&#39;, &#39;item8&#39;, &#39;item9&#39;, &#39;item10&#39;, &#39;item11&#39;] . Si no se especifica el indice se elimina el último item . lista.pop() lista . [&#39;item0&#39;, 1.1, True, 3, &#39;item4&#39;, 5, 6.6, &#39;item7&#39;, &#39;item8&#39;, &#39;item9&#39;, &#39;item10&#39;] . O se puede eliminar un item sabiendo su valor mediante el método remove() . lista.remove(&#39;item7&#39;) lista . [&#39;item0&#39;, 1.1, True, 3, &#39;item4&#39;, 5, 6.6, &#39;item8&#39;, &#39;item9&#39;, &#39;item10&#39;] . Con la función del() se puede eliminar también un item de la posición indicada . del lista[3] lista . [&#39;item0&#39;, 1.1, True, &#39;item4&#39;, 5, 6.6, &#39;item8&#39;, &#39;item9&#39;, &#39;item10&#39;] . Si no se indica el índice se elimina la lista entera . Con el método clear() deja la lista vacía . lista.clear() lista . [] . Se puede obtener la cantidad de items con un valor determinado mediante el método count() . lista = [5, 4, 6, 5, 7, 8, 5, 3, 1, 5] lista.count(5) . 4 . También se puede obtener el primer índice de un item con un valor determinado mediante el método index() . lista = [5, 4, 6, 5, 7, 8, 5, 3, 1, 5] lista.index(5) . 0 . 2.3.1.2. List comprehension . Podemos operar a través de la lista . fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;, &quot;kiwi&quot;, &quot;mango&quot;] newlist = [] # Iteramos por todos los items de la lista for x in fruits: # Si el item contiene el caracter &quot;a&quot; lo añadimos a newlist if &quot;a&quot; in x: newlist.append(x) newlist . [&#39;apple&#39;, &#39;banana&#39;, &#39;mango&#39;] . Otras de las cosas potentes de Python son las list comprehension, que permiten hacer todo en una sola linea y que el código quede más compacto . fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;, &quot;kiwi&quot;, &quot;mango&quot;] newlist = [x for x in fruits if &quot;a&quot; in x] newlist . [&#39;apple&#39;, &#39;banana&#39;, &#39;mango&#39;] . La sintaxis es la siguiente . newlist = [expression for item in iterable if condition == True] . Se puede aprovechar para realizar operaciones en la lista original . newlist = [x.upper() for x in fruits if &quot;a&quot; in x] newlist . [&#39;APPLE&#39;, &#39;BANANA&#39;, &#39;MANGO&#39;] . 2.3.1.3. Ordenar listas . Para ordenar listas usamos el método sort() . lista = [5, 8, 3, 4, 9, 5, 6] lista.sort() lista . [3, 4, 5, 5, 6, 8, 9] . También nos las ordena allfabéticamente . lista = [&quot;orange&quot;, &quot;mango&quot;, &quot;kiwi&quot;, &quot;pineapple&quot;, &quot;banana&quot;] lista.sort() lista . [&#39;banana&#39;, &#39;kiwi&#39;, &#39;mango&#39;, &#39;orange&#39;, &#39;pineapple&#39;] . A la hora de ordenar alfabéticamente distingue entre mayúsculas y minúsculas . lista = [&quot;orange&quot;, &quot;mango&quot;, &quot;kiwi&quot;, &quot;Pineapple&quot;, &quot;banana&quot;] lista.sort() lista . [&#39;Pineapple&#39;, &#39;banana&#39;, &#39;kiwi&#39;, &#39;mango&#39;, &#39;orange&#39;] . Se pueden ordenar en orden descendente mediante el atributo reverse = True . lista = [5, 8, 3, 4, 9, 5, 6] lista.sort(reverse = True) lista . [9, 8, 6, 5, 5, 4, 3] . Se pueden ordenar de la manera que queramos mediante el atributo key . def myfunc(n): # devuelve el valor absoluto de n - 50 return abs(n - 50) lista = [100, 50, 65, 82, 23] lista.sort(key = myfunc) lista . [50, 65, 23, 82, 100] . Se puede aprovechar esto para que por ejemplo, a la hora de ordenar no distinga entre mayúsculas y minúsculas . lista = [&quot;orange&quot;, &quot;mango&quot;, &quot;kiwi&quot;, &quot;Pineapple&quot;, &quot;banana&quot;] lista.sort(key = str.lower) lista . [&#39;banana&#39;, &#39;kiwi&#39;, &#39;mango&#39;, &#39;orange&#39;, &#39;Pineapple&#39;] . Se puede voltear la lista mediante el método reverse . lista = [5, 8, 3, 4, 9, 5, 6] lista.reverse() lista . [6, 5, 9, 4, 3, 8, 5] . 2.3.1.4. Copiar listas . No se pueden copiar listas mediante lista1 = lista2, ya que si se modifica lista1 también se modifica lista2 . lista1 = [5, 8, 3, 4, 9, 5, 6] lista2 = lista1 lista1[0] = True lista2 . [True, 8, 3, 4, 9, 5, 6] . Por lo que hay que usar el método copy() . lista1 = [5, 8, 3, 4, 9, 5, 6] lista2 = lista1.copy() lista1[0] = True lista2 . [5, 8, 3, 4, 9, 5, 6] . O hay que usar el constructor de listas list() . lista1 = [5, 8, 3, 4, 9, 5, 6] lista2 = list(lista1) lista1[0] = True lista2 . [5, 8, 3, 4, 9, 5, 6] . 2.3.1.5. Concatenar listas . Se pueden concatenar listas mediante el operador + . lista1 = [5, 8, 3, 4, 9, 5, 6] lista2 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] lista = lista1 + lista2 lista . [5, 8, 3, 4, 9, 5, 6, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;] . O mediante el método extend . lista1 = [5, 8, 3, 4, 9, 5, 6] lista2 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] lista1.extend(lista2) lista1 . [5, 8, 3, 4, 9, 5, 6, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;] . Otra forma de concatenar es repetir la tupla X veces mediante el operador * . lista1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] lista2 = lista1 * 3 lista2 . [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;] . 2.3.2. Tuplas . Las tuplas son similares a las listas, guardan múltiples items en una variable, pueden contener items de distintos tipos, pero no s epueden modificar, ni reordenar. Se definen mediante (), con los items separados por comas . Al no poderse modificar hace que las tuplas se ejecuten un poco más rápido que las listas, por lo que si no necesitas modificar los datos es mejor utilizar tuplas en vez de listas . tupla = (&#39;item0&#39;, 1, True, 3.3, &#39;item4&#39;, True) tupla . (&#39;item0&#39;, 1, True, 3.3, &#39;item4&#39;, True) . Se puede obtener su longitud mediante la función len() . len (tupla) . 6 . Para crear tuplas con un único elemento es necesario añadir una coma . tupla = (&#39;item0&#39;,) tupla, type(tupla) . ((&#39;item0&#39;,), tuple) . Para acceder a un elemento de la tupla se procede igual que con las listas . tupla = (&#39;item0&#39;, 1, True, 3.3, &#39;item4&#39;, True) print(tupla[0]) print(tupla[-1]) print(tupla[2:4]) print(tupla[-4:-2]) . item0 True (True, 3.3) (True, 3.3) . Podemos comprobar si hay un item en la tupla . &#39;item4&#39; in tupla . True . 2.3.2.1. Modificar tuplas . Aunque las tuplas no son modificables, se pueden modificar conviertiéndolas a listas, modificando la lista y después volviéndola a convertir a tupla . lista = list(tupla) lista[4] = &#39;ITEM4&#39; tupla = tuple(lista) tupla . (&#39;item0&#39;, 1, True, 3.3, &#39;ITEM4&#39;, True) . Al convertirla a lista podemos hacer todas las modificaciones vistas en las listas . Lo que sí se puede es eliminar la tupla entera . del tupla if &#39;tupla&#39; not in locals(): print(&quot;tupla eliminada&quot;) . tupla eliminada . 2.3.2.2. Desempaquetar tuplas . Cuando creamos tuplas, en realidad estamos empaquetando datos . tupla = (&#39;item0&#39;, 1, True, 3.3, &#39;item4&#39;, True) tupla . (&#39;item0&#39;, 1, True, 3.3, &#39;item4&#39;, True) . pero podemos desempaquetarlos . item0, item1, item2, item3, item4, item5 = tupla item0, item1, item2, item3, item4, item5 . (&#39;item0&#39;, 1, True, 3.3, &#39;item4&#39;, True) . Si queremos sacar menos datos que la longitud de la tupla añadimos un * . item0, item1, item2, *item3 = tupla item0, item1, item2, item3 . (&#39;item0&#39;, 1, True, [3.3, &#39;item4&#39;, True]) . Se puede poner el asterisco * en otra parte si por ejemplo lo que queremos es el último item . item0, item1, *item2, item5 = tupla item0, item1, item2, item5 . (&#39;item0&#39;, 1, [True, 3.3, &#39;item4&#39;], True) . 2.3.2.3. Concatenar tuplas . Se pueden concatenar tuplas mediante el operador + . tupla1 = (&quot;a&quot;, &quot;b&quot; , &quot;c&quot;) tupla2 = (1, 2, 3) tupla3 = tupla1 + tupla2 tupla3 . (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, 1, 2, 3) . Otra forma de concatenar es repetir la tupla X veces mediante el operador * . tupla1 = (&quot;a&quot;, &quot;b&quot; , &quot;c&quot;) tupla2 = tupla1 * 3 tupla2 . (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;) . 2.3.2.4. M&#233;todos de las tuplas . Las tuplas tienen dos métodos, el primero es el método count() que devuelve el número de veces que existe un item dentro de la tupla . tupla = (5, 4, 6, 5, 7, 8, 5, 3, 1, 5) tupla.count(5) . 4 . Otro método es index() que devuelve la primera posición de un item dentro de la tupla . tupla = (5, 4, 6, 5, 7, 8, 5, 3, 1, 5) tupla.index(5) . 0 . 2.3.3. Range . Con range() podemos crear una secuencia de números, comenzando desde 0 (de forma predeterminada), se incrementa en 1 (de forma predeterminada) y se detiene antes de un número especificado . range(start, stop, step) . Por ejemplo si queremos una secuencia de 0 a 5 (sin incluir el 5) . for i in range(5): print(f&#39;{i} &#39;, end=&#39;&#39;) . 0 1 2 3 4 . Si por ejemplo no queremos que empiece en 0 . for i in range(2, 5): print(f&#39;{i} &#39;, end=&#39;&#39;) . 2 3 4 . for i in range(-2, 5): print(f&#39;{i} &#39;, end=&#39;&#39;) . -2 -1 0 1 2 3 4 . Por último, si no queremos que se incremente en 1. Si por ejemplo queremos una secuencia de número pares . for i in range(0, 10, 2): print(f&#39;{i} &#39;, end=&#39;&#39;) . 0 2 4 6 8 . 2.4. Diccionarios . Los diccionarios se usan para guardar datos en pares key:data. Son modificables, no ordenados y no permiten duplicidades. Se definen mediante los símbolos {}. Admiten items de distintos tipos de datos . diccionario = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964, &quot;colors&quot;: [&quot;red&quot;, &quot;white&quot;, &quot;blue&quot;] } diccionario . {&#39;brand&#39;: &#39;Ford&#39;, &#39;colors&#39;: [&#39;red&#39;, &#39;white&#39;, &#39;blue&#39;], &#39;model&#39;: &#39;Mustang&#39;, &#39;year&#39;: 1964} . Como se ha dicho no permiten duplicidades . diccionario = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964, &quot;year&quot;: 2000, &quot;colors&quot;: [&quot;red&quot;, &quot;white&quot;, &quot;blue&quot;] } diccionario[&quot;year&quot;] . 2000 . Se puede obtener su longitud mediante la función len() . len(diccionario) . 4 . Como se puede ver la longitud es 4 y no 5, ya que year lo cuenta solo una vez . 2.4.1. Acceder a los items . Para acceder a un item lo podemos hacer a través de su key . diccionario[&quot;model&quot;] . &#39;Mustang&#39; . También se puede acceder mediante el método get() . diccionario.get(&quot;model&quot;) . &#39;Mustang&#39; . Para saber todas las keys de los diccionarios se puede usar el método keys() . diccionario.keys() . dict_keys([&#39;brand&#39;, &#39;model&#39;, &#39;year&#39;, &#39;colors&#39;]) . Se puede usar una variable para apuntar a las keys del diccionario, con lo que llamándola una vez es necesario . diccionario = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964 } # Se declara una vez la variable que apunta a las keys x = diccionario.keys() print(x) # Se añade una nueva key diccionario[&quot;color&quot;] = &quot;white&quot; # Se consulta la variable que apunta a las key print(x) . dict_keys([&#39;brand&#39;, &#39;model&#39;, &#39;year&#39;]) dict_keys([&#39;brand&#39;, &#39;model&#39;, &#39;year&#39;, &#39;color&#39;]) . Para obtener los valores del diccionario se puede usar el método &#39;values()&#39; . diccionario.values() . dict_values([&#39;Ford&#39;, &#39;Mustang&#39;, 2000, [&#39;red&#39;, &#39;white&#39;, &#39;blue&#39;]]) . Se puede usar una variable para apuntar a los valuess del diccionario, con lo que llamándola una vez es necesario . diccionario = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964 } # Se declara una vez la variable que apunta a los values x = diccionario.values() print(x) # Se modifica un value diccionario[&quot;year&quot;] = 2020 # Se consulta la variable que apunta a los values print(x) . dict_values([&#39;Ford&#39;, &#39;Mustang&#39;, 1964]) dict_values([&#39;Ford&#39;, &#39;Mustang&#39;, 2020]) . Si lo que se quiere son los items enteros, es decir keys y values hay que usar el método items() . diccionario.items() . dict_items([(&#39;brand&#39;, &#39;Ford&#39;), (&#39;model&#39;, &#39;Mustang&#39;), (&#39;year&#39;, 2020)]) . Se puede usar una variable para apuntar a los items del diccionario, con lo que llamándola una vez es necesario . diccionario = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964 } # Se declara una vez la variable que apunta a los items x = diccionario.items() print(x) # Se modifica un value diccionario[&quot;year&quot;] = 2020 # Se consulta la variable que apunta a los items print(x) . dict_items([(&#39;brand&#39;, &#39;Ford&#39;), (&#39;model&#39;, &#39;Mustang&#39;), (&#39;year&#39;, 1964)]) dict_items([(&#39;brand&#39;, &#39;Ford&#39;), (&#39;model&#39;, &#39;Mustang&#39;), (&#39;year&#39;, 2020)]) . Se puede checkear si una key existe en el diccionario . &quot;model&quot; in diccionario . True . 2.4.2. Modificar los items . Se puede modificar un item accediendo a el directamente . diccionario = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964 } # Se modifica un item diccionario[&quot;year&quot;] = 2020 diccionario . {&#39;brand&#39;: &#39;Ford&#39;, &#39;model&#39;: &#39;Mustang&#39;, &#39;year&#39;: 2020} . O se puede modificar mediante el método update() . diccionario = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964 } # Se modifica un item diccionario.update({&quot;year&quot;: 2020}) diccionario . {&#39;brand&#39;: &#39;Ford&#39;, &#39;model&#39;: &#39;Mustang&#39;, &#39;year&#39;: 2020} . 2.4.3. A&#241;adir items . Se puede añadir un item añadiéndolo sin más . diccionario = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964 } # Se modifica un item diccionario[&quot;colour&quot;] = &quot;blue&quot; diccionario . {&#39;brand&#39;: &#39;Ford&#39;, &#39;colour&#39;: &#39;blue&#39;, &#39;model&#39;: &#39;Mustang&#39;, &#39;year&#39;: 1964} . O se puede añadir mediante el método update() . diccionario = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964 } # Se modifica un item diccionario.update({&quot;colour&quot;: &quot;blue&quot;}) diccionario . {&#39;brand&#39;: &#39;Ford&#39;, &#39;colour&#39;: &#39;blue&#39;, &#39;model&#39;: &#39;Mustang&#39;, &#39;year&#39;: 1964} . 2.4.4. Eliminar items . Se puede eliminar un item con una key específica mediante el método pop() . diccionario = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964 } # Se elimina un item diccionario.pop(&quot;model&quot;) diccionario . {&#39;brand&#39;: &#39;Ford&#39;, &#39;year&#39;: 1964} . O se puede eliminar un item con una key específica mediante del indicando el nombre de la key entre los símbolos [] . diccionario = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964 } # Se elimina un item del diccionario[&quot;model&quot;] diccionario . {&#39;brand&#39;: &#39;Ford&#39;, &#39;year&#39;: 1964} . Se elimina el diccionario entero si se usa del y no se especifica la key de un item . diccionario = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964 } # Se elimina un item del diccionario if &#39;diccionario&#39; not in locals(): print(&quot;diccionario eliminado&quot;) . diccionario eliminado . Si lo que se quiere es eliminar el último item introducido se puede usar el método popitem() . diccionario = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964 } # Se elimina el último item introducido diccionario.popitem() diccionario . {&#39;brand&#39;: &#39;Ford&#39;, &#39;model&#39;: &#39;Mustang&#39;} . Si se quiere limpiar el diccionario hay que usar el método clear() . diccionario = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964 } diccionario.clear() diccionario . {} . 2.4.5. Copiar diccionarios . No se pueden copiar diccionarios mediante diccionario1 = diccionario2, ya que si se modifica diccionario1 también se modifica diccionario2 . diccionario1 = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964 } diccionario2 = diccionario1 diccionario1[&quot;year&quot;] = 2000 diccionario2[&quot;year&quot;] . 2000 . Por lo que hay que usar el método copy() . diccionario1 = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964 } diccionario2 = diccionario1.copy() diccionario1[&quot;year&quot;] = 2000 diccionario2[&quot;year&quot;] . 1964 . O hay que usar el constructor de diccionarios dict() . diccionario1 = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964 } diccionario2 = dict(diccionario1) diccionario1[&quot;year&quot;] = 2000 diccionario2[&quot;year&quot;] . 1964 . 2.4.6. Diccionarios nested . Los diccionarios pueden tener itemss de cualquier tipo de dato, incluso otros diccionarios. A este tipo de diccionarios se les denomina diccionarios nested . diccionario_nested = { &quot;child1&quot; : { &quot;name&quot; : &quot;Emil&quot;, &quot;year&quot; : 2004 }, &quot;child2&quot; : { &quot;name&quot; : &quot;Tobias&quot;, &quot;year&quot; : 2007 }, &quot;child3&quot; : { &quot;name&quot; : &quot;Linus&quot;, &quot;year&quot; : 2011 } } diccionario_nested . {&#39;child1&#39;: {&#39;name&#39;: &#39;Emil&#39;, &#39;year&#39;: 2004}, &#39;child2&#39;: {&#39;name&#39;: &#39;Tobias&#39;, &#39;year&#39;: 2007}, &#39;child3&#39;: {&#39;name&#39;: &#39;Linus&#39;, &#39;year&#39;: 2011}} . child1 = { &quot;name&quot; : &quot;Emil&quot;, &quot;year&quot; : 2004 } child2 = { &quot;name&quot; : &quot;Tobias&quot;, &quot;year&quot; : 2007 } child3 = { &quot;name&quot; : &quot;Linus&quot;, &quot;year&quot; : 2011 } diccionario_nested = { &quot;child1&quot; : child1, &quot;child2&quot; : child2, &quot;child3&quot; : child3 } diccionario_nested . {&#39;child1&#39;: {&#39;name&#39;: &#39;Emil&#39;, &#39;year&#39;: 2004}, &#39;child2&#39;: {&#39;name&#39;: &#39;Tobias&#39;, &#39;year&#39;: 2007}, &#39;child3&#39;: {&#39;name&#39;: &#39;Linus&#39;, &#39;year&#39;: 2011}} . 2.4.7. M&#233;todos de los diccionarios . Estos son los métodos que se pueden usar en los diccionarios . 2.5. Sets . 2.5.1. Set . Los setss se utilizan en python para guardar un conjunto de items en una sola variable. Se puede guardar items de distinto tipo. Son no ordenados y no tienen indice. . Se diferencian de las listas en que no tienen ni orden ni índice. . Se declaran mediante los símbolos {} . Como set es una palabra reservada en Python creamos un set con el nombre set_ . set_ = {&#39;item0&#39;, 1, 5.3, &quot;item4&quot;, 5, 6.6} set_ . {1, 5, 5.3, 6.6, &#39;item0&#39;, &#39;item4&#39;} . No puede haber items duplicados, si encuentra algún item duplicado se queda solo con uno . set_ = {&#39;item0&#39;, 1, 5.3, &quot;item4&quot;, 5, 6.6, &#39;item0&#39;} set_ . {1, 5, 5.3, 6.6, &#39;item0&#39;, &#39;item4&#39;} . Se puede obtener la longitud del set mediante la función len() . len(set_) . 6 . Como se puede ver la longitud del set es 6 y no 7, ya que se queda con un solo &#39;item0&#39; . Se puede checkear si un item se encuentra en el set . &#39;item4&#39; in set_ . True . 2.5.1.1. A&#241;adir items . Se puede añadir un item al set mediante el método add() . set_.add(8.8) set_ . {1, 5, 5.3, 6.6, 8.8, &#39;item0&#39;, &#39;item4&#39;} . Se puede añadir otro set mediante el método update() . set2 = {&quot;item5&quot;, &quot;item6&quot;, 7} set_.update(set2) set_ . {1, 5, 5.3, 6.6, 7, 8.8, &#39;item0&#39;, &#39;item4&#39;, &#39;item5&#39;, &#39;item6&#39;} . También se pueden añadir items de tipos de datos iterables de Python . lista = [&quot;item9&quot;, 10, 11.2] set_.update(lista) set_ . {1, 10, 11.2, 5, 5.3, 6.6, 7, 8.8, &#39;item0&#39;, &#39;item4&#39;, &#39;item5&#39;, &#39;item6&#39;, &#39;item9&#39;} . 2.5.1.2. Eliminar items . Se puede eliminar un item determinado mediante el método remove() . set_.remove(&#39;item9&#39;) set_ . {1, 10, 11.2, 5, 5.3, 6.6, 7, 8.8, &#39;item0&#39;, &#39;item4&#39;, &#39;item5&#39;, &#39;item6&#39;} . O mediante el método discard() . set_.discard(&#39;item6&#39;) set_ . {1, 10, 11.2, 5, 5.3, 6.6, 7, 8.8, &#39;item0&#39;, &#39;item4&#39;, &#39;item5&#39;} . Mediante el método pop() se puede eliminar el último item, pero como los sets no son ordenados no hay manera de saber cúal es el último item. El método pop() devuelve el item eliminado . print(f&quot;set antes de pop(): {set_}&quot;) eliminado = set_.pop() print(f&quot;Se ha eliminado {eliminado}&quot;) . set antes de pop(): {1, 5, 5.3, 6.6, 8.8, 7, 10, 11.2, &#39;item4&#39;, &#39;item0&#39;, &#39;item5&#39;} Se ha eliminado 1 . Mediante el método clear() se puede vaciar el set . set_.clear() set_ . set() . Por úlitmo, con del se puede eliminar el set . del set_ if &#39;set_&#39; not in locals(): print(&quot;set eliminado&quot;) . set eliminado . 2.5.1.3. Unir items . Una forma de unir sets es mediante el método union() . set1 = {&quot;a&quot;, &quot;b&quot; , &quot;c&quot;} set2 = {1, 2, 3} set3 = set1.union(set2) set3 . {1, 2, 3, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;} . Otra forma es mediante el método update(), pero de esta manera se añade un set en otro, no se crea uno nuevo . set1 = {&quot;a&quot;, &quot;b&quot; , &quot;c&quot;} set2 = {1, 2, 3} set1.update(set2) set1 . {1, 2, 3, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;} . Estos métodos de union elimina los duplicados, pero si queremos obtener los items duplicados en dos sets usamos el método intersection() . set1 = {&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;} set2 = {&quot;google&quot;, &quot;microsoft&quot;, &quot;apple&quot;} set3 = set1.intersection(set2) set3 . {&#39;apple&#39;} . Si queremos obtener los items duplicados en dos sets, pero sin crear un set nuevo, usamos el método intersection_update() . set1 = {&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;} set2 = {&quot;google&quot;, &quot;microsoft&quot;, &quot;apple&quot;} set1.intersection_update(set2) set1 . {&#39;apple&#39;} . Ahora al revés, si queremos quedarnos con los no duplicados usamos el método symmetric_difference(). . La diferencia entre eso y la unión entre dos sets es que en la unión se queda con todos los items, pero los que están duplicados solo los coge una vez. Ahora nos quedamos con los que no están duplicados . set1 = {&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;} set2 = {&quot;google&quot;, &quot;microsoft&quot;, &quot;apple&quot;} set3 = set1.symmetric_difference(set2) set3 . {&#39;banana&#39;, &#39;cherry&#39;, &#39;google&#39;, &#39;microsoft&#39;} . Si queremos quedarnos con los no duplicados sin crear un set nuevo usamos el método symmetric_difference_update() . set1 = {&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;} set2 = {&quot;google&quot;, &quot;microsoft&quot;, &quot;apple&quot;} set1.symmetric_difference_update(set2) set1 . {&#39;banana&#39;, &#39;cherry&#39;, &#39;google&#39;, &#39;microsoft&#39;} . 2.5.1.4. M&#233;todos de los sets . Estos son los métodos que se pueden usar en los sets . 2.5.2. Frozenset . Los frozensets son como los sets pero con la salvedad de que son inmutables, al igual que las tuplas son como las lists pero inmutables. Por lo que no podremos añadir o eliminar items . 2.6. Booleanos . Hay solo dos booleanos en Python: True y False . Mediante la función bool() se puede evaluar si cualquier cosa es True o False . print(bool(&quot;Hello&quot;)) print(bool(15)) print(bool(0)) . True True False . 2.6.1. Otros tipos de datos True o False . Los siguientes datos son True: . Cualquier string que no esté vacío | Cualquier número escepto el 0 | Cualquier lista, tupla, diccionario o set que no esté vacío | . print(bool(&quot;Hola&quot;)) print(bool(&quot;&quot;)) . True False . print(bool(3)) print(bool(0)) . True False . lista = [1, 2, 3] print(bool(lista)) lista = [] print(bool(lista)) . True False . tupla = (1, 2, 3) print(bool(tupla)) tupla = () print(bool(tupla)) . True False . diccionario = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964, &quot;colors&quot;: [&quot;red&quot;, &quot;white&quot;, &quot;blue&quot;] } print(bool(diccionario)) diccionario.clear() print(bool(diccionario)) . True False . set_ = {&#39;item0&#39;, 1, 5.3, &quot;item4&quot;, 5, 6.6} print(bool(set_)) set_.clear() print(bool(set_)) . True False . 2.7. Binarios . 2.7.1. Bytes . El tipo bytes es una secuencia inmutable de bytes. Solo admiten caracteres ASCII. También se pueden representar los bytes mediante números enteros cuyo valores deben cumplir 0 &lt;= x &lt; 256 . Para crear un tipo byte debemos introducir antes el caracter b . byte = b&quot;DeepMaxFN&quot; byte . b&#39;DeepMaxFN&#39; . También se pueden crear mediante su contructor bytes() . byte = bytes(10) byte . b&#39; x00 x00 x00 x00 x00 x00 x00 x00 x00 x00&#39; . byte = bytes(range(10)) byte . b&#39; x00 x01 x02 x03 x04 x05 x06 x07 x08 t&#39; . Se pueden concatenar bytes mediante el operador + . byte1 = b&#39;DeepMax&#39; byte2 = b&#39;FN&#39; byte3 = byte1 + byte2 byte3 . b&#39;DeepMaxFN&#39; . O medainte la repetición con el operador * . byte1 = b&#39;DeepMaxFN &#39; byte2 = byte1 * 3 byte2 . b&#39;DeepMaxFN DeepMaxFN DeepMaxFN &#39; . Podemos comprobar si un caracter está dentro de la cadena . b&#39;D&#39; in byte1 . True . Estos son los métodos que se pueden usar en los bytes . 2.7.2. Bytearray . Los bytearrays son igual que los bytes solo que son mutables . byte_array = bytearray(b&#39;DeepMaxFN&#39;) byte_array . bytearray(b&#39;DeepMaxFN&#39;) . 2.7.3. Memoryview . Los objetos memoryview permiten que el código Python acceda a los datos internos de un objeto que admite el protocolo de búfer sin realizar copias. . La función memoryview() permite el acceso directo de lectura y escritura a los datos orientados a bytes de un objeto sin necesidad de copiarlos primero. Eso puede generar grandes ganancias de rendimiento cuando se opera con objetos grandes, ya que no crea una copia al cortar. . Protocolo de búfer, puede crear otro objeto de acceso para modificar los datos grandes sin copiarlos. Esto hace que el programa utilice menos memoria y aumenta la velocidad de ejecución. . byte_array = bytearray(&#39;XYZ&#39;, &#39;utf-8&#39;) print(f&#39;Antes de acceder a la memoria: {byte_array}&#39;) mem_view = memoryview(byte_array) mem_view[2]= 74 print(f&#39;Después de acceder a la memoria: {byte_array}&#39;) . Antes de acceder a la memoria: bytearray(b&#39;XYZ&#39;) Después de acceder a la memoria: bytearray(b&#39;XYJ&#39;) . 3. Operadores . 3.1. Operadores aritm&#233;ticos . Operador suma + . 3 + 5 . 8 . Oeprador resta - . 3 - 5 . -2 . Operador multiplicación * . 3 * 5 . 15 . Operador división / . 3 / 5 . 0.6 . Operador módulo %. Devuelve el resto de una división . 25 % 2 . 1 . Operador exponente ** . 5 ** 2 . 25 . Operador división entera // . 25 // 2 . 12 . 3.2. Operadores de comparaci&#243;n . Operador es igual == . 1 == 1 . True . Operador es distinto != . 1 != 2 . True . Operador es mayor que &gt; . 3 &gt; 2 . True . Operador es menor que &lt; . 2 &lt; 3 . True . Operador es mayor o igual que &gt;= . 3 &gt;= 3 . True . Operador es menor o igual que &lt;= . 3 &lt;= 3 . True . 3.3. Operadores l&#243;gicos . Operador and . True and True . True . Operador or . True or False . True . Operador not . not False . True . 3.4. Operadores de identidad . Operador is . 5.3 is 5.3 . True . Operador is not . 5.3 is not 5 . True . 3.5. Operadores de pertenencia . Operador in . x = [&quot;apple&quot;, &quot;banana&quot;] &quot;banana&quot; in x . True . Operador not in . x = [&quot;apple&quot;, &quot;banana&quot;] &quot;orange&quot; not in x . True . 3.6. Operadores bit a bit . Operador AND &amp; . a = 60 # 60 = 0011 1100 b = 13 # 13 = 0000 1101 c = a &amp; b; # 12 = 0000 1100 c . 12 . Operador OR | . a = 60 # 60 = 0011 1100 b = 13 # 13 = 0000 1101 c = a | b; # 61 = 0011 1101 c . 61 . Operador XOR ^ . a = 60 # 60 = 0011 1100 b = 13 # 13 = 0000 1101 c = a ^ b; # 49 = 0011 0001 c . 49 . Operador NOT ~ . a = 60 # 60 = 0011 1100 c = ~a; # -61 = 1100 0011 c . -61 . Operador desplazamiento hacia la izquierda &lt;&lt; . a = 60 # 60 = 0011 1100 c = a &lt;&lt; 2; # 240 = 1111 0000 c . 240 . Operador desplazamiento hacia la derecha &gt;&gt; . a = 60 # 60 = 0011 1100 c = a &gt;&gt; 2; # 15 = 0000 1111 c . 15 . 3.7. Operadores de asignaci&#243;n . Operador = . a = 5 a . 5 . Operador +=. x += y es equivalente a x = x + y . a += 5 a . 10 . Operador -=. x -= y es equivalente a `x = x - y . a -= 5 a . 5 . Operador *=. x *= y es equivalente a `x = x * y . a *= 3 a . 15 . Operador /=. x /= y es equivalente a `x = x / y . a /= 3 a . 5.0 . Operador %=. x %= y es equivalente a `x = x % y . a = 25 a %= 2 a . 1 . Operador //=. x //= y es equivalente a `x = x // y . a = 25 a //= 2 a . 12 . Operador **=. x **= y es equivalente a `x = x ** y . a = 5 a **= 2 a . 25 . Operador &amp;=. x &amp;= y es equivalente a `x = x &amp; y . a = 60 # 60 = 0011 1100 b = 13 # 13 = 0000 1101 a &amp;= b; # 12 = 0000 1100 a . 12 . Operador |=. x |= y es equivalente a `x = x | y . a = 60 # 60 = 0011 1100 b = 13 # 13 = 0000 1101 a |= b; # 61 = 0011 1101 a . 61 . Operador ^=. x ^= y es equivalente a `x = x ^ y . a = 60 # 60 = 0011 1100 b = 13 # 13 = 0000 1101 a ^= b; # 49 = 0011 0001 a . 49 . Operador &gt;&gt;=. x &gt;&gt;= y es equivalente a `x = x &gt;&gt; y . a = 60 # 60 = 0011 1100 a &lt;&lt;= 2; # 240 = 1111 0000 a . 240 . Operador &lt;&lt;=. x &lt;&lt;= y es equivalente a `x = x &lt;&lt; y . a = 60 # 60 = 0011 1100 a &gt;&gt;= 2; # 15 = 0000 1111 a . 15 . 4. Control de flujo . Para poder utilizar las herramientas de control de flujo es necesario añadir la sentencia, dos puntos : y en una nueva línea escribir el códgo con indentación . A diferencia de otros lenguajes, Python necesita la indentación (añadir un espacio en blanco) para definir el código de dentro de una herramienta de control de flujo . 4.1. If . Mediante if podemos crear condiciones . if len(&#39;DeepMaxFN&#39;) == 9: print(&#39;DeepMaxFN tiene 9 caracteres&#39;) . DeepMaxFN tiene 9 caracteres . Si queremos crear más de una condición podemos usar elif . if len(&#39;DeepMaxFN&#39;) &lt; 9: print(&#39;DeepMaxFN tiene menos de 9 caracteres&#39;) elif len(&#39;DeepMaxFN&#39;) == 9: print(&#39;DeepMaxFN tiene 9 caracteres&#39;) . DeepMaxFN tiene 9 caracteres . Si lo que queremos es que se ejecute algo en caso de que no se cumpla ninguna de las condiciones indicadas podemos usar else . if len(&#39;DeepMaxFN&#39;) &lt; 9: print(&#39;DeepMaxFN tiene menos de 9 caracteres&#39;) elif len(&#39;DeepMaxFN&#39;) &gt; 9: print(&#39;DeepMaxFN tiene más de 9 caracteres&#39;) else: print(&#39;DeepMaxFN tiene 9 caracteres&#39;) . DeepMaxFN tiene 9 caracteres . Si queremos escribir todo en una sola línea . if len(&#39;DeepMaxFN&#39;) == 9: print(&#39;DeepMaxFN tiene 9 caracteres&#39;) . DeepMaxFN tiene 9 caracteres . Igual, si queremos escribir todo en una línea, pero con varias condiciones . print(&#39;DeepMaxFN tiene menos de 9 caracteres&#39;) if len(&#39;DeepMaxFN&#39;) &lt; 9 else print(&#39;DeepMaxFN tiene más de 9 caracteres&#39;) if len(&#39;DeepMaxFN&#39;) &gt; 9 else print(&#39;DeepMaxFN tiene 9 caracteres&#39;) . DeepMaxFN tiene 9 caracteres . Si por ejemplo queremos hacer la estructura del if pero no queremos, de momento, codificar una de las condiciones podemos usar pass . if len(&#39;DeepMaxFN&#39;) &lt; 9: print(&#39;DeepMaxFN tiene menos de 9 caracteres&#39;) elif len(&#39;DeepMaxFN&#39;) &gt; 9: pass else: print(&#39;DeepMaxFN tiene 9 caracteres&#39;) . DeepMaxFN tiene 9 caracteres . 4.2. While . El bucle while se ejecuta mientras la condición sea True . i = 0 string = &#39;DeepMaxFN&#39; while len(string) &gt; i: print(string[i], end=&#39;&#39;) i += 1 . DeepMaxFN . Si queremos que el bucle pare por alguna condición usamos break . i = 0 string = &#39;DeepMaxFN&#39; while len(string) &gt; i: if string[i] == &#39;F&#39;: break print(string[i], end=&#39;&#39;) i += 1 . DeepMax . Si queremos que una de las iteracciones no se ejecute por alguna razón usamos continue . i = 0 string = &#39;Deep Max FN&#39; while len(string) &gt; i: if string[i] == &#39; &#39;: i += 1 continue print(string[i], end=&#39;&#39;) i += 1 . DeepMaxFN . Mediante else se puede ejecutar un bloque de código si la condición del while no es True . i = 0 string = &#39;DeepMaxFN&#39; while len(string) &gt; i: print(string[i], end=&#39;&#39;) i += 1 else: print(&quot; nSe ha terminado el while&quot;) . DeepMaxFN Se ha terminado el while . 4.3. For . El bucle for se usa para ejecutar código mientras se itera por una secuencia, esta secuencia puede ser un cualquir elemento iterable de Python (string, lista, tupla, range, diccionario, set) . string = &#39;DeepMaxFN&#39; for x in string: print(x, end=&#39;&#39;) . DeepMaxFN . lista = [&#39;D&#39;, &#39;e&#39;, &#39;e&#39;, &#39;p&#39;, &#39;M&#39;, &#39;a&#39;, &#39;x&#39;, &#39;F&#39;, &#39;N&#39;] for x in lista: print(x, end=&#39;&#39;) . DeepMaxFN . tupla = (&#39;D&#39;, &#39;e&#39;, &#39;e&#39;, &#39;p&#39;, &#39;M&#39;, &#39;a&#39;, &#39;x&#39;, &#39;F&#39;, &#39;N&#39;) for x in tupla: print(x, end=&#39;&#39;) . DeepMaxFN . string = &#39;DeepMaxFN&#39; for i in range(len(string)): print(string[i], end=&#39;&#39;) . DeepMaxFN . diccionario = { &quot;letra1&quot;: &quot;D&quot;, &quot;letra2&quot;: &quot;e&quot;, &quot;letra3&quot;: &quot;e&quot;, &quot;letra4&quot;: &quot;p&quot;, &quot;letra5&quot;: &quot;M&quot;, &quot;letra6&quot;: &quot;a&quot;, &quot;letra7&quot;: &quot;x&quot;, &quot;letra8&quot;: &quot;F&quot;, &quot;letra9&quot;: &quot;N&quot; } for x in diccionario.values(): print(x, end=&#39;&#39;) . DeepMaxFN . También se puede iterar por los sets, pero como son elementos no ordenados, no tendremos control del orden de ejecución . set_ = {&#39;D&#39;, &#39;e&#39;, &#39;e&#39;, &#39;p&#39;, &#39;M&#39;, &#39;a&#39;, &#39;x&#39;, &#39;F&#39;, &#39;N&#39;} for x in set_: print(x, end=&#39;&#39;) . epaFDxNM . Si queremos que el bucle pare por alguna condición usamos break . string = &#39;DeepMaxFN&#39; for x in string: if x == &#39;F&#39;: break print(x, end=&#39;&#39;) . DeepMax . Si queremos que una de las iteracciones no se ejecute por alguna razón usamos continue . string = &#39;Deep Max FN&#39; for x in string: if x == &#39; &#39;: continue print(x, end=&#39;&#39;) . DeepMaxFN . Mediante else se puede ejecutar un bloque de código si la condición del while no es True . string = &#39;DeepMaxFN&#39; for x in string: print(x, end=&#39;&#39;) else: print(&quot; nSe ha terminado el for&quot;) . DeepMaxFN Se ha terminado el for . Si por ejemplo queremos hacer la estructura del for pero no queremos, de momento, codificar el interior podemos usar pass . string = &#39;DeepMaxFN&#39; for x in string: pass print(&#39;Interior del for no codificado&#39;) . Interior del for no codificado . 5. Funciones . Una función es una porción de código que se puede ejecutar tantas veces como quieras. Se le puede pasar argumentos y puede devolver datos como resultado . Para definir una función se comienza con la palabra reservada def seguido del nombre de la función, paréntesis (), dos puntos : y a continuación en una nueva línea indentado el código de la función . def funcion(): print(&#39;DeepmaxFN&#39;) . Para llamar a la función solo es necesario escribir su nombre . funcion() . DeepmaxFN . A las funciones se le pueden pasar todos los argumentos que se quiera, dentro de los paréntesis y separados por comas . def funcion(string1, string2): print(string1 + &#39; &#39; + string2) funcion(&quot;Hola&quot;, &quot;DeepMaxFN&quot;) . Hola DeepMaxFN . Cuando se llama a la función hay que pasarle el mismo número de argumentos que se han declarado, si se pasan más o menos obtendremos un error. . Si no sabemos los argumentos que va a recibir la función se puede usar *args, es decir, poniendo un * antes de los argumentos se indica que el número de argumentos es libre. . Al hacer esto se le pasa una tupla (recordemos que es inmutable) con los argumentos . def funcion(*argumentos): numero_argumentos = len(argumentos) for i in range(numero_argumentos): print(argumentos[i], end=&#39; &#39;) funcion(&quot;funcion&quot;, &quot;con&quot;, &quot;varios&quot;, &quot;argumentos&quot;, &quot;sin&quot;, &quot;especificar&quot;, &quot;cuantos&quot;) . funcion con varios argumentos sin especificar cuantos . En caso de no saber el orden de los argumentos de una función, podemos indicar el argumento que le queremos pasar indicando su nombre . def funcion(argumento1, argumento2, argumento3): print(argumento1 + &#39; &#39;+ argumento2 + &#39; &#39; + argumento3) funcion(argumento3 = &quot;DeepmaxFN&quot;, argumento1 = &quot;Blog&quot;, argumento2 = &quot;de&quot;) . Blog de DeepmaxFN . En caso de querer pasar los argumentos con su nombre, pero en caso de no saber cuantos argumentos se van a pasar se puede usar **kargs. En este caso se le pasará un diccionario con los argumentos . def funcion(**kargumentos): print(&quot;Autor del blog: &quot; + kargumentos[&quot;autor&quot;]) funcion(blog = &quot;Blog&quot;, pertenencia = &quot;de&quot;, autor = &quot;DeepMaxFN&quot;) . Autor del blog: DeepMaxFN . Si queremos que algún argumento tenga un valor por defecto lo podemos indicar entre los paréntesis de la función. De esta manera si a la hora de llamar a la función no se pasa dicho argumento, este en la función tendrá el valor por defecto . def funcion(argumento1, argumento2, argumento3 = &quot;DeepMaxFN&quot;): print(argumento1 + &#39; &#39;+ argumento2 + &#39; &#39; + argumento3) funcion(&quot;Blog&quot;, &quot;de&quot;) . Blog de DeepMaxFN . Se puede pasar cualquier tipo de dato como argumento, por ejemplo si se pasa un lista como argumento, dentro de la función, dicho argumento será tratado como una lista . def funcion(argumento): longitud_lista = len(argumento) for i in range(longitud_lista): print(argumento[i], end=&#39; &#39;) funcion([&quot;Blog&quot;, &quot;de&quot;, &quot;DeepMaxFN&quot;]) . Blog de DeepMaxFN . Las funciones pueden devolver datos, esto se hace mediante la palabra reservada return . def funcion(argumento): longitud_lista = len(argumento) string = &quot;&quot; for i in range(longitud_lista): string = string + argumento[i] + &#39; &#39; return string print(funcion([&quot;Blog&quot;, &quot;de&quot;, &quot;DeepMaxFN&quot;])) . Blog de DeepMaxFN . Pueden devolver más de un dato . def funcion(argumento): longitud_lista = len(argumento) string0 = argumento[0] string1 = argumento[1] string2 = argumento[2] return string0, string1, string2 dato0, dato1, dato2 = funcion([&quot;Blog&quot;, &quot;de&quot;, &quot;DeepMaxFN&quot;]) print(dato0 + &#39; &#39; + dato1 + &#39; &#39; + dato2) . Blog de DeepMaxFN . Si uno de los datos devueltos no nos interesa podemos pasar de el mediante _ . def funcion(argumento): longitud_lista = len(argumento) string0 = argumento[0] string1 = argumento[1] string2 = argumento[2] return string0, string1, string2 _, _, dato_de_interes = funcion([&quot;Blog&quot;, &quot;de&quot;, &quot;DeepMaxFN&quot;]) print(dato_de_interes) . DeepMaxFN . Si por ejemplo queremos hacer la estructura de la función pero no queremos, de momento, codificar el interior podemos usar pass . def funcion(): pass funcion() . Una función puede llamarse a si misma, a esto se le llama recursión o recursividad de la función. . Por ejemplo podemos usar esta cualidad para calcular el factorial de un número . def factorial(n): if n == 0 or n == 1: return 1 else: return n * factorial(n-1) factorial(5) . 120 . 6. Funciones lambda . Una función lambda es una pequeña función anónima. . Una función lambda puede tomar cualquier número de argumentos, pero solo puede tener una expresión. . Las funciones lambda se definen de la siguiente manera: . lambda arguments : expression . x = lambda a : a + 10 print(x(5)) . 15 . x = lambda a, b, c : a + b + c print(x(5, 6, 2)) . 13 . El poder de lambda se muestra mejor cuando los usa como una función anónima dentro de otra función. . def myfunc(n): return lambda a : a * n mydoubler = myfunc(2) mytripler = myfunc(3) print(f&quot;mydoubler: {mydoubler(11)}&quot;) print(f&quot;mytripler: {mytripler(11)}&quot;) . mydoubler: 22 mytripler: 33 . 7. Clases y objetos . Python es un lenguaje de programación orientado a objetos. Casi todo en Python es un objeto, con sus propiedades y métodos. . Una clase es como un constructor de objetos o un &quot;plano&quot; para crear objetos. . Para crear una clase se usa la palabra reservada class . class Clase: variable = &#39;DeepMaxFN&#39; . Una vez creada la clase se puede crear un objeto de dicha clase . objeto = Clase() Clase.variable . &#39;DeepMaxFN&#39; . Normalmente las clases tienen una función inicial, que se ejecuta cuando se crea un objeto de la clase. Esta función se denomina dunder init y se escribe __init__(). A la función dunder init se le tiene que pasar siempre la variable self, que indica la propia clase, y a continuación, las variables que se quiera . Con esta función se suelen inicializar las variables de las clases, o se ejecuta el código que se necesite cuando se crea un objeto de la clase . class Persona: def __init__(self, nombre, edad): self.nombre = nombre self.edad = edad objeto_persona = Persona(&quot;Miguel&quot;, 36) print(objeto_persona.nombre) print(objeto_persona.edad) . Miguel 36 . Además de la función inicial dunder init, se pueden crear más funciones. A estas funciones se les llama métodos de la clase. A estos métodos siempre hay que pasarles la variable self . class Persona: def __init__(self, nombre, edad): self.nombre = nombre self.edad = edad def saludar(self): print(f&#39;Hola mi nombre es {self.nombre} y tengo {self.edad} años&#39;) objeto_persona = Persona(&quot;Miguel&quot;, 36) objeto_persona.saludar() . Hola mi nombre es Miguel y tengo 36 años . La variable self no tiene por qué ser llamada self, puede tener cualquier nombre, pero dentro de cada clase tiene que ser siempre el mismo. Pero por convenio se suele usar self . class Persona: def __init__(yo_mismo, nombre, edad): yo_mismo.nombre = nombre yo_mismo.edad = edad def saludar(yo_mismo): print(f&#39;Hola mi nombre es {yo_mismo.nombre} y tengo {yo_mismo.edad} años&#39;) objeto_persona = Persona(&quot;Miguel&quot;, 36) objeto_persona.saludar() . Hola mi nombre es Miguel y tengo 36 años . Se pueden modificar las variables de los objetos . objeto_persona.nombre = &#39;Marta&#39; objeto_persona.saludar() . Hola mi nombre es Marta y tengo 36 años . Incluso eliminarlas . del objeto_persona.nombre . También se puede eliminar el objeto entero . del objeto_persona . Si por ejemplo queremos hacer la estructura de la clase pero no queremos, de momento, codificar el interior podemos usar pass . class Persona: pass objeto_persona = Persona() . 7.1. Herencia . La herencia nos permite definir una clase que hereda todos los métodos y propiedades de otra clase. . La clase padre es la clase de la que se hereda, también llamada clase base. . La clase hija es la clase que hereda de otra clase, también llamada clase derivada. . Creamos una clase padre . class Persona: def __init__(self, nombre, apellido): self.nombre = nombre self.apellido = apellido def imprimir_nombre(self): print(f&#39;Me llamo {self.nombre} {self.apellido}&#39;) objeto_padre = Persona(&quot;Laura&quot;, &quot;Perez&quot;) objeto_padre.imprimir_nombre() . Me llamo Laura Perez . Para crear la clase hija hay que indicar entre paréntesis, a la hora de declarar la clase, de qué clase hereda . class Estudiante(Persona): pass . Y a la hora de crear el objeto de la clase hija, se le pasan los parámetros que la clase padre necesita . objeto_hijo = Estudiante(&quot;Mariano&quot;, &quot;Sanz&quot;) objeto_hijo.imprimir_nombre() . Me llamo Mariano Sanz . Hasta ahora la clase hija ha heredado las funciones de la clase padre, pero podemos modificarlas reescribiéndolas. Por ejemplo reescribiendo la función duder init. . Si se reescribe la función dunder init, si queremos que se llame a la función dunder init de la clase padre hay que llamarla. . Para esto hay dos maneras, una es mediante el nombre de la clase padre, en este caso hay que pasarle la variable self . class Estudiante(Persona): def __init__(self, nombre, apellido): Persona.__init__(self, nombre, apellido) objeto_hijo = Estudiante(&quot;Mariano&quot;, &quot;Sanz&quot;) objeto_hijo.imprimir_nombre() . Me llamo Mariano Sanz . Otra forma es mediante super(), en este caso no hace falta pasarle la variable self . class Estudiante(Persona): def __init__(self, nombre, apellido): super().__init__(nombre, apellido) objeto_hijo = Estudiante(&quot;Mariano&quot;, &quot;Sanz&quot;) objeto_hijo.imprimir_nombre() . Me llamo Mariano Sanz . Al modificar las funciones se puede añadir código nuevo . class Estudiante(Persona): def __init__(self, nombre, apellido, curso): Persona.__init__(self, nombre, apellido) self.curso = curso def imprimir_nombre(self): Persona.imprimir_nombre(self) print(f&#39;Estoy en el curso número {self.curso}&#39;) objeto_hijo = Estudiante(&quot;Mariano&quot;, &quot;Sanz&quot;, 4) objeto_hijo.imprimir_nombre() . Me llamo Mariano Sanz Estoy en el curso número 4 . Por último se pueden añadir nuevos métodos . class Estudiante(Persona): def __init__(self, nombre, apellido, curso): Persona.__init__(self, nombre, apellido) self.curso = curso def imprimir_nombre(self): Persona.imprimir_nombre(self) print(f&#39;Estoy en el curso número {self.curso}&#39;) def imprimir_estudiante(self): print(&quot;Soy un estudiante del curso número {self.curso}&quot;) objeto_hijo = Estudiante(&quot;Mariano&quot;, &quot;Sanz&quot;, 4) objeto_hijo.imprimir_nombre() objeto_hijo.imprimir_estudiante() . Me llamo Mariano Sanz Estoy en el curso número 4 Soy un estudiante del curso número {self.curso} . 8. Iteradores . Un iterador es un objeto que contiene un número contable de valores. . Un iterador es un objeto sobre el que se puede iterar, lo que significa que puede atravesar todos los valores. . Técnicamente, en Python, un iterador es un objeto que implementa el protocolo del iterador, que consta de los métodos __iter__() y __next__(). . Las listas, tuplas, diccionarios y conjuntos son todos objetos iterables. Son contenedores iterables de los que puede obtener un iterador. . Todos estos objetos tienen un método iter() que se usa para obtener un iterador: . tupla = (&quot;manzana&quot;, &quot;plátano&quot;, &quot;cereza&quot;) iterable = iter(tupla) print(next(iterable)) print(next(iterable)) print(next(iterable)) . manzana plátano cereza . string = &quot;plátano&quot; iterable = iter(string) print(next(iterable), end=&#39; &#39;) print(next(iterable), end=&#39; &#39;) print(next(iterable), end=&#39; &#39;) print(next(iterable), end=&#39; &#39;) print(next(iterable), end=&#39; &#39;) print(next(iterable), end=&#39; &#39;) print(next(iterable), end=&#39; &#39;) . p l á t a n o . El bucle for en realidad crea un objeto iterador y ejecuta el método next() para cada bucle. . tupla = (&quot;manzana&quot;, &quot;plátano&quot;, &quot;cereza&quot;) for x in tupla: print(x) . manzana plátano cereza . string = &quot;plátano&quot; for x in string: print(x, end=&#39; &#39;) . p l á t a n o . 8.1. Crear un objeto iterador . Para crear un objeto/clase como iterador, hay que implementar los métodos __iter__() y __next__(). . class Numeros: def __iter__(self): self.a = 1 return self def __next__(self): x = self.a self.a += 1 return x objeto_iterador = Numeros() iterador = iter(objeto_iterador) print(next(iterador), end=&#39; &#39;) print(next(iterador), end=&#39; &#39;) print(next(iterador), end=&#39; &#39;) print(next(iterador), end=&#39; &#39;) print(next(iterador), end=&#39; &#39;) . 1 2 3 4 5 . El ejemplo anterior continuaría para siempre si tuviera suficientes llámadas a next(), o si se usara en un bucle for. . Para evitar que la iteración continúe para siempre, podemos usar la declaración StopIteration. . En el método __next__(), podemos agregar una condición de terminación para generar un error si la iteración se realiza un número específico de veces: . class Numeros: def __iter__(self): self.a = 1 return self def __next__(self): if self.a &lt;= 20: x = self.a self.a += 1 return x else: raise StopIteration objeto_iterador = Numeros() iterador = iter(objeto_iterador) for x in iterador: print(x, end=&#39; &#39;) . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 . 9. Alcance de variables . Una variable solo está disponible dentro de la región en la que se crea. A esto se le llama alcance . 9.1. Alcance local . Una variable creada dentro de una función pertenece al ámbito local de esa función y solo se puede usar dentro de esa función. . def funcion(): x = 300 print(x) funcion() . 300 . La variable x no está disponible fuera de la función, pero está disponible para cualquier función dentro de la función . def funcion(): x = 300 def funcion_interna(): print(x) funcion_interna() funcion() . 300 . 9.2. Alcance global . Una variable creada en el cuerpo principal del código Python es una variable global y pertenece al ámbito global. . Las variables globales están disponibles desde cualquier ámbito, global y local. . x = 300 def funcion(): print(f&#39;Ámbito local: {x}&#39;) funcion() print(f&#39;Ámbito global: {x}&#39;) . Ámbito local: 300 Ámbito global: 300 . Si se crean dos variables, una global y otra local, las dos con el mismo nombre, Python las creará como dos variables distintas . x = 300 def funcion(): x = 200 print(f&#39;Variable local: {x}&#39;) funcion() print(f&#39;Variable global: {x}&#39;) . Variable local: 200 Variable global: 300 . Si se necesita crear una variable global, pero está declarada en el ámbito local, se puede usar la palabra clave global. . La palabra clave global hace que la variable sea global. . def funcion(): global x x = 300 funcion() print(f&#39;Variable global: {x}&#39;) . Variable global: 300 . Además, el uso de la palabra clave global realizar un cambio en una variable global dentro de una función. . x = 300 def funcion(): global x x = 200 funcion() print(f&#39;Variable global: {x}&#39;) . Variable global: 200 . 10. M&#243;dulos . 11. Try... Except .",
            "url": "https://deepmaxfn.github.io/DeepMaxFN-blog/deepmaxfn/python/2021/02/09/Introducci%C3%B3n-a-Python.html",
            "relUrl": "/deepmaxfn/python/2021/02/09/Introducci%C3%B3n-a-Python.html",
            "date": " • Feb 9, 2021"
        }
        
    
  
    
  
    
        ,"post3": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master- badges: true- comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://deepmaxfn.github.io/DeepMaxFN-blog/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "Soy Máximo Fernández, un ingeniero electrónico entusiasta del data science . This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://deepmaxfn.github.io/DeepMaxFN-blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://deepmaxfn.github.io/DeepMaxFN-blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}